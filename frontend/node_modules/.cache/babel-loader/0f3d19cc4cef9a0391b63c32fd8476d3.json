{"ast":null,"code":"import { FunctionExt } from '../../util';\nimport { Point, Line, Angle } from '../../geometry';\nimport { resolve } from './manhattan/options';\nimport { manhattan } from './manhattan/index';\nvar defaults = {\n  maxDirectionChange: 45,\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions: function directions() {\n    var step = resolve(this.step, this);\n    var cost = resolve(this.cost, this);\n    var diagonalCost = Math.ceil(Math.sqrt(step * step << 1)); // eslint-disable-line no-bitwise\n\n    return [{\n      cost: cost,\n      offsetX: step,\n      offsetY: 0\n    }, {\n      cost: diagonalCost,\n      offsetX: step,\n      offsetY: step\n    }, {\n      cost: cost,\n      offsetX: 0,\n      offsetY: step\n    }, {\n      cost: diagonalCost,\n      offsetX: -step,\n      offsetY: step\n    }, {\n      cost: cost,\n      offsetX: -step,\n      offsetY: 0\n    }, {\n      cost: diagonalCost,\n      offsetX: -step,\n      offsetY: -step\n    }, {\n      cost: cost,\n      offsetX: 0,\n      offsetY: -step\n    }, {\n      cost: diagonalCost,\n      offsetX: step,\n      offsetY: -step\n    }];\n  },\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute: function fallbackRoute(from, to, options) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n    var theta = from.theta(to);\n    var route = [];\n    var a = {\n      x: to.x,\n      y: from.y\n    };\n    var b = {\n      x: from.x,\n      y: to.y\n    };\n\n    if (theta % 180 > 90) {\n      var t = a;\n      a = b;\n      b = t;\n    }\n\n    var p1 = theta % 90 < 45 ? a : b;\n    var l1 = new Line(from, p1);\n    var alpha = 90 * Math.ceil(theta / 90);\n    var p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);\n    var l2 = new Line(to, p2);\n    var intersectionPoint = l1.intersectsWithLine(l2);\n    var point = intersectionPoint || to;\n    var directionFrom = intersectionPoint ? point : from;\n    var quadrant = 360 / options.directions.length;\n    var angleTheta = directionFrom.theta(to);\n    var normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n    var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n    options.previousDirectionAngle = directionAngle;\n    if (point) route.push(point.round());\n    route.push(to);\n    return route;\n  }\n};\nexport var metro = function metro(vertices, options, linkView) {\n  return FunctionExt.call(manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);\n};","map":null,"metadata":{},"sourceType":"module"}