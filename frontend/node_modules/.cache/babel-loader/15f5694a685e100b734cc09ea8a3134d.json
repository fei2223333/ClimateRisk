{"ast":null,"code":"function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar PriorityQueue = /*#__PURE__*/_createClass(function PriorityQueue() {\n  var _this = this;\n\n  _classCallCheck(this, PriorityQueue);\n\n  this.arr = [];\n  this.keyIndice = new Map();\n\n  this.size = function () {\n    return _this.arr.length;\n  };\n\n  this.keys = function () {\n    return _this.arr.map(function (e) {\n      return e.key;\n    });\n  };\n\n  this.has = function (key) {\n    return _this.keyIndice.has(key);\n  };\n\n  this.priority = function (key) {\n    var index = _this.keyIndice.get(key);\n\n    if (index !== undefined) {\n      return _this.arr[index].priority;\n    }\n  };\n\n  this.swap = function (i, j) {\n    var arr = _this.arr,\n        keyIndice = _this.keyIndice;\n    var _ref = [arr[i], arr[j]],\n        originI = _ref[0],\n        originJ = _ref[1];\n    arr[i] = originJ;\n    arr[j] = originI;\n    keyIndice.set(originI.key, j);\n    keyIndice.set(originJ.key, i);\n  };\n\n  this.innerDecrease = function (index) {\n    var arr = _this.arr;\n    var priority = arr[index].priority;\n    var parent;\n    var i = index;\n\n    while (i !== 0) {\n      var _arr$parent;\n\n      parent = i >> 1;\n\n      if (((_arr$parent = arr[parent]) === null || _arr$parent === void 0 ? void 0 : _arr$parent.priority) < priority) {\n        break;\n      }\n\n      _this.swap(i, parent);\n\n      i = parent;\n    }\n  };\n\n  this.heapify = function (i) {\n    var arr = _this.arr;\n    var l = i << 1;\n    var r = l + 1;\n    var largest = i;\n\n    if (l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n\n      if (r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n\n      if (largest !== i) {\n        _this.swap(i, largest);\n\n        _this.heapify(largest);\n      }\n    }\n  };\n\n  this.min = function () {\n    if (_this.size() === 0) {\n      throw new Error('Queue underflow');\n    }\n\n    return _this.arr[0].key;\n  };\n\n  this.add = function (key, priority) {\n    var keyIndice = _this.keyIndice,\n        arr = _this.arr;\n\n    if (!keyIndice.has(key)) {\n      var index = arr.length;\n      keyIndice.set(key, index);\n      arr.push({\n        key: key,\n        priority: priority\n      });\n\n      _this.innerDecrease(index);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  this.removeMin = function () {\n    _this.swap(0, _this.arr.length - 1);\n\n    var min = _this.arr.pop();\n\n    _this.keyIndice.delete(min.key);\n\n    _this.heapify(0);\n\n    return min.key;\n  };\n\n  this.decrease = function (key, priority) {\n    if (!_this.has(key)) {\n      throw new Error(\"There's no key named \".concat(key));\n    } // there must be an index\n\n\n    var index = _this.keyIndice.get(key);\n\n    if (priority > _this.arr[index].priority) {\n      throw new Error(\"New priority is greater than current priority.Key: \".concat(key, \" Old: + \").concat(_this.arr[index].priority, \" New: \").concat(priority));\n    }\n\n    _this.arr[index].priority = priority;\n\n    _this.innerDecrease(index);\n  };\n});\n\nexport { PriorityQueue as default };","map":null,"metadata":{},"sourceType":"module"}