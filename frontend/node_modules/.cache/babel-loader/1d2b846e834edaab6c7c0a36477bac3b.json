{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Util } from '../../global';\nimport { FunctionExt } from '../../util';\nimport { Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Graph } from '../../graph/graph';\nexport var Dnd = /*#__PURE__*/function (_View) {\n  _inherits(Dnd, _View);\n\n  function Dnd(options) {\n    var _this;\n\n    _classCallCheck(this, Dnd);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Dnd).call(this));\n    _this.options = Object.assign(Object.assign({}, Dnd.defaults), options);\n    _this.container = document.createElement('div');\n    _this.$container = _this.$(_this.container).addClass(_this.prefixClassName('widget-dnd'));\n    _this.draggingGraph = new Graph(Object.assign(Object.assign({}, _this.options.delegateGraphOptions), {\n      container: document.createElement('div'),\n      width: 1,\n      height: 1\n    }));\n\n    _this.$container.append(_this.draggingGraph.container);\n\n    return _this;\n  }\n\n  _createClass(Dnd, [{\n    key: \"start\",\n    value: function start(node, evt) {\n      var e = evt;\n      e.preventDefault();\n      this.targetModel.startBatch('dnd');\n      this.$container.addClass('dragging').appendTo(this.options.containerParent || document.body);\n      this.sourceNode = node;\n      this.prepareDragging(node, e.clientX, e.clientY);\n      var local = this.updateNodePosition(e.clientX, e.clientY);\n\n      if (this.isSnaplineEnabled()) {\n        this.snapline.captureCursorOffset({\n          e: e,\n          node: node,\n          cell: node,\n          view: this.draggingView,\n          x: local.x,\n          y: local.y\n        });\n        this.draggingNode.on('change:position', this.snap, this);\n      }\n\n      this.delegateDocumentEvents(Dnd.documentEvents, e.data);\n    }\n  }, {\n    key: \"isSnaplineEnabled\",\n    value: function isSnaplineEnabled() {\n      return this.snapline && !this.snapline.disabled;\n    }\n  }, {\n    key: \"prepareDragging\",\n    value: function prepareDragging(sourceNode, clientX, clientY) {\n      var draggingGraph = this.draggingGraph;\n      var draggingModel = draggingGraph.model;\n      var draggingNode = this.options.getDragNode(sourceNode, {\n        sourceNode: sourceNode,\n        draggingGraph: draggingGraph,\n        targetGraph: this.targetGraph\n      });\n      draggingNode.position(0, 0);\n      var padding = 5;\n\n      if (this.isSnaplineEnabled()) {\n        padding += this.snapline.options.tolerance || 0;\n      }\n\n      if (this.isSnaplineEnabled() || this.options.scaled) {\n        var scale = this.targetGraph.transform.getScale();\n        draggingGraph.scale(scale.sx, scale.sy);\n        padding *= Math.max(scale.sx, scale.sy);\n      } else {\n        draggingGraph.scale(1, 1);\n      }\n\n      this.clearDragging();\n\n      if (this.options.animation) {\n        this.$container.stop(true, true);\n      }\n\n      draggingModel.resetCells([draggingNode]);\n      var delegateView = draggingGraph.findViewByCell(draggingNode);\n      delegateView.undelegateEvents();\n      delegateView.cell.off('changed');\n      draggingGraph.fitToContent({\n        padding: padding,\n        allowNewOrigin: 'any'\n      });\n      var bbox = delegateView.getBBox();\n      this.geometryBBox = delegateView.getBBox({\n        useCellGeometry: true\n      });\n      this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft());\n      this.draggingNode = draggingNode;\n      this.draggingView = delegateView;\n      this.draggingBBox = draggingNode.getBBox();\n      this.padding = padding;\n      this.originOffset = this.updateGraphPosition(clientX, clientY);\n    }\n  }, {\n    key: \"updateGraphPosition\",\n    value: function updateGraphPosition(clientX, clientY) {\n      var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n      var delta = this.delta;\n      var nodeBBox = this.geometryBBox;\n      var padding = this.padding || 5;\n      var offset = {\n        left: clientX - delta.x - nodeBBox.width / 2 - padding,\n        top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop\n      };\n\n      if (this.draggingGraph) {\n        this.$container.offset(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"updateNodePosition\",\n    value: function updateNodePosition(x, y) {\n      var local = this.targetGraph.clientToLocal(x, y);\n      var bbox = this.draggingBBox;\n      local.x -= bbox.width / 2;\n      local.y -= bbox.height / 2;\n      this.draggingNode.position(local.x, local.y);\n      return local;\n    }\n  }, {\n    key: \"snap\",\n    value: function snap(_ref) {\n      var cell = _ref.cell,\n          current = _ref.current,\n          options = _ref.options;\n      var node = cell;\n\n      if (options.snapped) {\n        var bbox = this.draggingBBox;\n        node.position(bbox.x + options.tx, bbox.y + options.ty, {\n          silent: true\n        });\n        this.draggingView.translate();\n        node.position(current.x, current.y, {\n          silent: true\n        });\n        this.snapOffset = {\n          x: options.tx,\n          y: options.ty\n        };\n      } else {\n        this.snapOffset = null;\n      }\n    }\n  }, {\n    key: \"onDragging\",\n    value: function onDragging(evt) {\n      var draggingView = this.draggingView;\n\n      if (draggingView) {\n        evt.preventDefault();\n        var e = this.normalizeEvent(evt);\n        var clientX = e.clientX;\n        var clientY = e.clientY;\n        this.updateGraphPosition(clientX, clientY);\n        var local = this.updateNodePosition(clientX, clientY);\n        var embeddingMode = this.targetGraph.options.embedding.enabled;\n        var isValidArea = (embeddingMode || this.isSnaplineEnabled()) && this.isInsideValidArea({\n          x: clientX,\n          y: clientY\n        });\n\n        if (embeddingMode) {\n          draggingView.setEventData(e, {\n            graph: this.targetGraph,\n            candidateEmbedView: this.candidateEmbedView\n          });\n          var data = draggingView.getEventData(e);\n\n          if (isValidArea) {\n            draggingView.processEmbedding(e, data);\n          } else {\n            draggingView.clearEmbedding(data);\n          }\n\n          this.candidateEmbedView = data.candidateEmbedView;\n        } // update snapline\n\n\n        if (this.isSnaplineEnabled()) {\n          if (isValidArea) {\n            this.snapline.snapOnMoving({\n              e: e,\n              view: draggingView,\n              x: local.x,\n              y: local.y\n            });\n          } else {\n            this.snapline.hide();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"onDragEnd\",\n    value: function onDragEnd(evt) {\n      var _this2 = this;\n\n      var draggingNode = this.draggingNode;\n\n      if (draggingNode) {\n        var e = this.normalizeEvent(evt);\n        var draggingView = this.draggingView;\n        var draggingBBox = this.draggingBBox;\n        var snapOffset = this.snapOffset;\n        var x = draggingBBox.x;\n        var y = draggingBBox.y;\n\n        if (snapOffset) {\n          x += snapOffset.x;\n          y += snapOffset.y;\n        }\n\n        draggingNode.position(x, y, {\n          silent: true\n        });\n        var ret = this.drop(draggingNode, {\n          x: e.clientX,\n          y: e.clientY\n        });\n\n        var callback = function callback(node) {\n          if (node) {\n            _this2.onDropped(draggingNode);\n\n            if (_this2.targetGraph.options.embedding.enabled && draggingView) {\n              draggingView.setEventData(e, {\n                cell: node,\n                graph: _this2.targetGraph,\n                candidateEmbedView: _this2.candidateEmbedView\n              });\n              draggingView.finalizeEmbedding(e, draggingView.getEventData(e));\n            }\n          } else {\n            _this2.onDropInvalid();\n          }\n\n          _this2.candidateEmbedView = null;\n\n          _this2.targetModel.stopBatch('dnd');\n        };\n\n        if (FunctionExt.isAsync(ret)) {\n          // stop dragging\n          this.undelegateDocumentEvents();\n          ret.then(callback); // eslint-disable-line\n        } else {\n          callback(ret);\n        }\n      }\n    }\n  }, {\n    key: \"clearDragging\",\n    value: function clearDragging() {\n      if (this.draggingNode) {\n        this.sourceNode = null;\n        this.draggingNode.remove();\n        this.draggingNode = null;\n        this.draggingView = null;\n        this.delta = null;\n        this.padding = null;\n        this.snapOffset = null;\n        this.originOffset = null;\n        this.undelegateDocumentEvents();\n      }\n    }\n  }, {\n    key: \"onDropped\",\n    value: function onDropped(draggingNode) {\n      if (this.draggingNode === draggingNode) {\n        this.clearDragging();\n        this.$container.removeClass('dragging').remove();\n      }\n    }\n  }, {\n    key: \"onDropInvalid\",\n    value: function onDropInvalid() {\n      var _this3 = this;\n\n      var draggingNode = this.draggingNode;\n\n      if (draggingNode) {\n        var anim = this.options.animation;\n\n        if (anim) {\n          var duration = typeof anim === 'object' && anim.duration || 150;\n          var easing = typeof anim === 'object' && anim.easing || 'swing';\n          this.draggingView = null;\n          this.$container.animate(this.originOffset, duration, easing, function () {\n            return _this3.onDropped(draggingNode);\n          });\n        } else {\n          this.onDropped(draggingNode);\n        }\n      }\n    }\n  }, {\n    key: \"isInsideValidArea\",\n    value: function isInsideValidArea(p) {\n      var targetRect;\n      var targetGraph = this.targetGraph;\n      var targetScroller = this.targetScroller;\n\n      if (targetScroller) {\n        if (targetScroller.options.autoResize) {\n          targetRect = this.getDropArea(targetScroller.container);\n        } else {\n          var outter = this.getDropArea(targetScroller.container);\n          targetRect = this.getDropArea(targetGraph.container).intersectsWithRect(outter);\n        }\n      } else {\n        targetRect = this.getDropArea(targetGraph.container);\n      }\n\n      return targetRect && targetRect.containsPoint(p);\n    }\n  }, {\n    key: \"getDropArea\",\n    value: function getDropArea(elem) {\n      var $elem = this.$(elem);\n      var offset = $elem.offset();\n      var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n      var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;\n      return Rectangle.create({\n        x: offset.left + parseInt($elem.css('border-left-width'), 10) - scrollLeft,\n        y: offset.top + parseInt($elem.css('border-top-width'), 10) - scrollTop,\n        width: $elem.innerWidth(),\n        height: $elem.innerHeight()\n      });\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(draggingNode, pos) {\n      var _this4 = this;\n\n      if (this.isInsideValidArea(pos)) {\n        var targetGraph = this.targetGraph;\n        var targetModel = targetGraph.model;\n        var local = targetGraph.clientToLocal(pos);\n        var sourceNode = this.sourceNode;\n        var droppingNode = this.options.getDropNode(draggingNode, {\n          sourceNode: sourceNode,\n          draggingNode: draggingNode,\n          targetGraph: this.targetGraph,\n          draggingGraph: this.draggingGraph\n        });\n        var bbox = droppingNode.getBBox();\n        local.x += bbox.x - bbox.width / 2;\n        local.y += bbox.y - bbox.height / 2;\n        var gridSize = this.snapOffset ? 1 : targetGraph.getGridSize();\n        droppingNode.position(Util.snapToGrid(local.x, gridSize), Util.snapToGrid(local.y, gridSize));\n        droppingNode.removeZIndex();\n        var validateNode = this.options.validateNode;\n        var ret = validateNode ? validateNode(droppingNode, {\n          sourceNode: sourceNode,\n          draggingNode: draggingNode,\n          droppingNode: droppingNode,\n          targetGraph: targetGraph,\n          draggingGraph: this.draggingGraph\n        }) : true;\n\n        if (typeof ret === 'boolean') {\n          if (ret) {\n            targetModel.addCell(droppingNode, {\n              stencil: this.cid\n            });\n            return droppingNode;\n          }\n\n          return null;\n        }\n\n        return FunctionExt.toDeferredBoolean(ret).then(function (valid) {\n          if (valid) {\n            targetModel.addCell(droppingNode, {\n              stencil: _this4.cid\n            });\n            return droppingNode;\n          }\n\n          return null;\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      if (this.draggingGraph) {\n        this.draggingGraph.view.remove();\n        this.draggingGraph.dispose();\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.remove();\n    }\n  }, {\n    key: \"targetScroller\",\n    get: function get() {\n      var target = this.options.target;\n      return Graph.isGraph(target) ? target.scroller.widget : target;\n    }\n  }, {\n    key: \"targetGraph\",\n    get: function get() {\n      var target = this.options.target;\n      return Graph.isGraph(target) ? target : target.graph;\n    }\n  }, {\n    key: \"targetModel\",\n    get: function get() {\n      return this.targetGraph.model;\n    }\n  }, {\n    key: \"snapline\",\n    get: function get() {\n      return this.targetGraph.snapline.widget;\n    }\n  }]);\n\n  return Dnd;\n}(View);\n\n__decorate([View.dispose()], Dnd.prototype, \"dispose\", null);\n\n(function (Dnd) {\n  Dnd.defaults = {\n    animation: false,\n    getDragNode: function getDragNode(sourceNode) {\n      return sourceNode.clone();\n    },\n    getDropNode: function getDropNode(draggingNode) {\n      return draggingNode.clone();\n    }\n  };\n  Dnd.documentEvents = {\n    mousemove: 'onDragging',\n    touchmove: 'onDragging',\n    mouseup: 'onDragEnd',\n    touchend: 'onDragEnd',\n    touchcancel: 'onDragEnd'\n  };\n})(Dnd || (Dnd = {}));","map":null,"metadata":{},"sourceType":"module"}