{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Dom, FunctionExt } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Cell } from '../model';\nimport { View, CellView } from '../view';\nimport { Base } from './base';\nexport var Renderer = /*#__PURE__*/function (_Base) {\n  _inherits(Renderer, _Base);\n\n  function Renderer() {\n    _classCallCheck(this, Renderer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Renderer).apply(this, arguments));\n  }\n\n  _createClass(Renderer, [{\n    key: \"init\",\n    value: function init() {\n      this.resetUpdates();\n      this.startListening(); // Renders existing cells in the model.\n\n      this.resetViews(this.model.getCells()); // Starts rendering loop.\n\n      if (!this.isFrozen() && this.isAsync()) {\n        this.updateViewsAsync();\n      }\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      this.model.on('sorted', this.onSortModel, this);\n      this.model.on('reseted', this.onModelReseted, this);\n      this.model.on('batch:stop', this.onBatchStop, this);\n      this.model.on('cell:added', this.onCellAdded, this);\n      this.model.on('cell:removed', this.onCellRemoved, this);\n      this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);\n      this.model.on('cell:change:visible', this.onCellVisibleChanged, this);\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      this.model.off('sorted', this.onSortModel, this);\n      this.model.off('reseted', this.onModelReseted, this);\n      this.model.off('batch:stop', this.onBatchStop, this);\n      this.model.off('cell:added', this.onCellAdded, this);\n      this.model.off('cell:removed', this.onCellRemoved, this);\n      this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);\n      this.model.off('cell:change:visible', this.onCellVisibleChanged, this);\n    }\n  }, {\n    key: \"resetUpdates\",\n    value: function resetUpdates() {\n      this.updates = {\n        priorities: [{}, {}, {}],\n        mounted: {},\n        mountedCids: [],\n        unmounted: {},\n        unmountedCids: [],\n        count: 0,\n        sort: false,\n        frozen: false,\n        freezeKey: null,\n        animationId: null\n      };\n    }\n  }, {\n    key: \"onSortModel\",\n    value: function onSortModel() {\n      if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {\n        return;\n      }\n\n      this.sortViews();\n    }\n  }, {\n    key: \"onModelReseted\",\n    value: function onModelReseted(_ref) {\n      var options = _ref.options;\n      this.removeZPivots();\n      this.resetViews(this.model.getCells(), options);\n    }\n  }, {\n    key: \"onBatchStop\",\n    value: function onBatchStop(_ref2) {\n      var name = _ref2.name,\n          data = _ref2.data;\n\n      if (this.isFrozen()) {\n        return;\n      }\n\n      var model = this.model;\n\n      if (!this.isAsync()) {\n        var updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;\n\n        if (updateDelayingBatches.includes(name) && !model.hasActiveBatch(updateDelayingBatches)) {\n          this.updateViews(data);\n        }\n      }\n\n      var sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;\n\n      if (sortDelayingBatches.includes(name) && !model.hasActiveBatch(sortDelayingBatches)) {\n        this.sortViews();\n      }\n    }\n  }, {\n    key: \"onCellAdded\",\n    value: function onCellAdded(_ref3) {\n      var cell = _ref3.cell,\n          options = _ref3.options;\n      var position = options.position;\n\n      if (this.isAsync() || typeof position !== 'number') {\n        this.renderView(cell, options);\n      } else {\n        if (options.maxPosition === position) {\n          this.freeze({\n            key: 'addCells'\n          });\n        }\n\n        this.renderView(cell, options);\n\n        if (position === 0) {\n          this.unfreeze({\n            key: 'addCells'\n          });\n        }\n      }\n    }\n  }, {\n    key: \"onCellRemoved\",\n    value: function onCellRemoved(_ref4) {\n      var cell = _ref4.cell,\n          options = _ref4.options;\n      var view = this.findViewByCell(cell);\n\n      if (view) {\n        this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);\n      }\n    }\n  }, {\n    key: \"onCellZIndexChanged\",\n    value: function onCellZIndexChanged(_ref5) {\n      var cell = _ref5.cell,\n          options = _ref5.options;\n\n      if (this.options.sorting === 'approx') {\n        var view = this.findViewByCell(cell);\n\n        if (view) {\n          this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);\n        }\n      }\n    }\n  }, {\n    key: \"onCellVisibleChanged\",\n    value: function onCellVisibleChanged(_ref6) {\n      var cell = _ref6.cell,\n          visible = _ref6.current,\n          options = _ref6.options;\n\n      // Hide connected edges before cell\n      if (!visible) {\n        this.processEdgeOnTerminalVisibleChanged(cell, false);\n      }\n\n      var view = this.findViewByCell(cell);\n\n      if (!visible && view) {\n        this.removeView(cell);\n      } else if (visible && view == null) {\n        this.renderView(cell, options);\n      } // Show connected edges after cell rendered\n\n\n      if (visible) {\n        this.processEdgeOnTerminalVisibleChanged(cell, true);\n      }\n    }\n  }, {\n    key: \"processEdgeOnTerminalVisibleChanged\",\n    value: function processEdgeOnTerminalVisibleChanged(node, visible) {\n      var getOpposite = function getOpposite(edge, currentTerminal) {\n        var sourceId = edge.getSourceCellId();\n\n        if (sourceId !== currentTerminal.id) {\n          return edge.getSourceCell();\n        }\n\n        var targetId = edge.getTargetCellId();\n\n        if (targetId !== currentTerminal.id) {\n          return edge.getTargetCell();\n        }\n\n        return null;\n      };\n\n      this.model.getConnectedEdges(node).forEach(function (edge) {\n        var opposite = getOpposite(edge, node);\n\n        if (opposite == null || opposite.isVisible()) {\n          visible ? edge.show() : edge.hide();\n        }\n      });\n    }\n  }, {\n    key: \"isEdgeTerminalVisible\",\n    value: function isEdgeTerminalVisible(edge, terminal) {\n      var cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();\n      var cell = cellId ? this.model.getCell(cellId) : null;\n\n      if (cell && !cell.isVisible()) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"requestConnectedEdgesUpdate\",\n    value: function requestConnectedEdgesUpdate(view) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (CellView.isCellView(view)) {\n        var cell = view.cell;\n        var edges = this.model.getConnectedEdges(cell);\n\n        for (var j = 0, n = edges.length; j < n; j += 1) {\n          var edge = edges[j];\n          var edgeView = this.findViewByCell(edge);\n\n          if (!edgeView) {\n            continue;\n          }\n\n          var flagLabels = ['update'];\n\n          if (edge.getTargetCell() === cell) {\n            flagLabels.push('target');\n          }\n\n          if (edge.getSourceCell() === cell) {\n            flagLabels.push('source');\n          }\n\n          this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);\n        }\n      }\n    }\n  }, {\n    key: \"forcePostponedViewUpdate\",\n    value: function forcePostponedViewUpdate(view, flag) {\n      if (!view || !CellView.isCellView(view)) {\n        return false;\n      }\n\n      var cell = view.cell;\n\n      if (cell.isNode()) {\n        return false;\n      }\n\n      var edgeView = view;\n\n      if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {\n        // EdgeView is waiting for the source/target cellView to be rendered.\n        // This can happen when the cells are not in the viewport.\n        var sourceFlag = 0;\n        var sourceView = this.findViewByCell(cell.getSourceCell());\n\n        if (sourceView && !this.isViewMounted(sourceView)) {\n          sourceFlag = this.dumpView(sourceView);\n          edgeView.updateTerminalMagnet('source');\n        }\n\n        var targetFlag = 0;\n        var targetView = this.findViewByCell(cell.getTargetCell());\n\n        if (targetView && !this.isViewMounted(targetView)) {\n          targetFlag = this.dumpView(targetView);\n          edgeView.updateTerminalMagnet('target');\n        }\n\n        if (sourceFlag === 0 && targetFlag === 0) {\n          // If leftover flag is 0, all view updates were done.\n          return !this.dumpView(edgeView);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"scheduleViewUpdate\",\n    value: function scheduleViewUpdate(view, flag, priority) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var cid = view.cid;\n      var updates = this.updates;\n      var cache = updates.priorities[priority];\n\n      if (!cache) {\n        cache = updates.priorities[priority] = {};\n      }\n\n      var currentFlag = cache[cid] || 0;\n\n      if ((currentFlag & flag) === flag) {\n        return;\n      }\n\n      if (!currentFlag) {\n        updates.count += 1;\n      }\n\n      if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {\n        // When a view is removed we need to remove the\n        // insert flag as this is a reinsert.\n        cache[cid] ^= Renderer.FLAG_INSERT;\n      } else if (flag & Renderer.FLAG_INSERT && currentFlag & Renderer.FLAG_REMOVE) {\n        // When a view is added we need to remove the remove\n        // flag as this is view was previously removed.\n        cache[cid] ^= Renderer.FLAG_REMOVE;\n      }\n\n      cache[cid] |= flag;\n      this.graph.hook.onViewUpdated(view, flag, options);\n    }\n  }, {\n    key: \"requestViewUpdate\",\n    value: function requestViewUpdate(view, flag, priority) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.scheduleViewUpdate(view, flag, priority, options);\n      var isAsync = this.isAsync();\n\n      if (this.isFrozen() || isAsync && options.async !== false || this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {\n        return;\n      }\n\n      var stats = this.updateViews(options);\n\n      if (isAsync) {\n        this.graph.trigger('render:done', {\n          stats: stats,\n          options: options\n        });\n      }\n    }\n    /**\n     * Adds view into the DOM and update it.\n     */\n\n  }, {\n    key: \"dumpView\",\n    value: function dumpView(view) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (view == null) {\n        return 0;\n      }\n\n      var cid = view.cid;\n      var updates = this.updates;\n      var cache = updates.priorities[view.priority];\n      var flag = this.registerMountedView(view) | cache[cid];\n      delete cache[cid];\n\n      if (!flag) {\n        return 0;\n      }\n\n      return this.updateView(view, flag, options);\n    }\n    /**\n     * Adds all views into the DOM and update them.\n     */\n\n  }, {\n    key: \"dumpViews\",\n    value: function dumpViews() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.checkView(options);\n      this.updateViews(options);\n    }\n    /**\n     * Ensure the view associated with the cell is attached\n     * to the DOM and updated.\n     */\n\n  }, {\n    key: \"requireView\",\n    value: function requireView(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var view = this.findViewByCell(cell);\n\n      if (view == null) {\n        return null;\n      }\n\n      this.dumpView(view, options);\n      return view;\n    }\n  }, {\n    key: \"updateView\",\n    value: function updateView(view, flag) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (view == null) {\n        return 0;\n      }\n\n      if (CellView.isCellView(view)) {\n        if (flag & Renderer.FLAG_REMOVE) {\n          this.removeView(view.cell);\n          return 0;\n        }\n\n        if (flag & Renderer.FLAG_INSERT) {\n          this.insertView(view);\n          flag ^= Renderer.FLAG_INSERT; // eslint-disable-line\n        }\n      }\n\n      if (!flag) {\n        return 0;\n      }\n\n      return view.confirmUpdate(flag, options);\n    }\n  }, {\n    key: \"updateViews\",\n    value: function updateViews() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var result;\n      var batchCount = 0;\n      var updatedCount = 0;\n      var priority = Renderer.MIN_PRIORITY;\n\n      do {\n        result = this.updateViewsBatch(options);\n        batchCount += 1;\n        updatedCount += result.updatedCount;\n        priority = Math.min(result.priority, priority);\n      } while (!result.empty);\n\n      return {\n        priority: priority,\n        batchCount: batchCount,\n        updatedCount: updatedCount\n      };\n    }\n  }, {\n    key: \"updateViewsBatch\",\n    value: function updateViewsBatch() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var updates = this.updates;\n      var priorities = updates.priorities;\n      var batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;\n      var empty = true;\n      var priority = Renderer.MIN_PRIORITY;\n      var mountedCount = 0;\n      var unmountedCount = 0;\n      var updatedCount = 0;\n      var postponedCount = 0;\n      var checkView = options.checkView || this.options.checkView;\n\n      if (typeof checkView !== 'function') {\n        checkView = null;\n      } // eslint-disable-next-line\n\n\n      main: for (var p = 0, n = priorities.length; p < n; p += 1) {\n        var cache = priorities[p]; // eslint-disable-next-line\n\n        for (var cid in cache) {\n          if (updatedCount >= batchSize) {\n            empty = false; // goto next batch\n\n            break main; // eslint-disable-line no-labels\n          }\n\n          var view = View.views[cid];\n\n          if (!view) {\n            delete cache[cid];\n            continue;\n          }\n\n          var currentFlag = cache[cid]; // Do not check a view for viewport if we are about to remove the view.\n\n          if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {\n            var isUnmounted = (cid in updates.unmounted);\n\n            if (checkView && !FunctionExt.call(checkView, this.graph, {\n              view: view,\n              unmounted: isUnmounted\n            })) {\n              // Unmount view\n              if (!isUnmounted) {\n                this.registerUnmountedView(view);\n                view.unmount();\n              }\n\n              updates.unmounted[cid] |= currentFlag;\n              delete cache[cid];\n              unmountedCount += 1;\n              continue;\n            } // Mount view\n\n\n            if (isUnmounted) {\n              currentFlag |= Renderer.FLAG_INSERT;\n              mountedCount += 1;\n            }\n\n            currentFlag |= this.registerMountedView(view);\n          }\n\n          var cellView = view;\n          var leftoverFlag = this.updateView(view, currentFlag, options);\n\n          if (leftoverFlag > 0) {\n            var cell = cellView.cell;\n\n            if (cell && cell.isEdge()) {\n              // remove edge view when source cell is invisible\n              if (cellView.hasAction(leftoverFlag, 'source') && !this.isEdgeTerminalVisible(cell, 'source')) {\n                leftoverFlag = cellView.removeAction(leftoverFlag, 'source');\n                leftoverFlag |= Renderer.FLAG_REMOVE;\n              } // remove edge view when target cell is invisible\n\n\n              if (cellView.hasAction(leftoverFlag, 'target') && !this.isEdgeTerminalVisible(cell, 'target')) {\n                leftoverFlag = cellView.removeAction(leftoverFlag, 'target');\n                leftoverFlag |= Renderer.FLAG_REMOVE;\n              }\n            }\n          }\n\n          if (leftoverFlag > 0) {\n            // update has not finished\n            cache[cid] = leftoverFlag;\n\n            if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) || cache[cid]) {\n              postponedCount += 1;\n              empty = false;\n              continue;\n            }\n          }\n\n          if (priority > p) {\n            priority = p;\n          }\n\n          updatedCount += 1;\n          delete cache[cid];\n        }\n      }\n\n      return {\n        empty: empty,\n        priority: priority,\n        mountedCount: mountedCount,\n        unmountedCount: unmountedCount,\n        updatedCount: updatedCount,\n        postponedCount: postponedCount\n      };\n    }\n  }, {\n    key: \"updateViewsAsync\",\n    value: function updateViewsAsync() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        processed: 0,\n        priority: Renderer.MIN_PRIORITY\n      };\n      var updates = this.updates;\n      var animationId = updates.animationId;\n\n      if (animationId) {\n        Dom.cancelAnimationFrame(animationId);\n\n        if (data.processed === 0) {\n          var beforeFn = options.before;\n\n          if (typeof beforeFn === 'function') {\n            FunctionExt.call(beforeFn, this.graph, this.graph);\n          }\n        }\n\n        var stats = this.updateViewsBatch(options);\n        var checkout = this.checkViewImpl({\n          checkView: options.checkView,\n          mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,\n          unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount\n        });\n        var processed = data.processed;\n        var total = updates.count;\n        var mountedCount = checkout.mountedCount;\n        var unmountedCount = checkout.unmountedCount;\n\n        if (stats.updatedCount > 0) {\n          // Some updates have been just processed\n          processed += stats.updatedCount + stats.unmountedCount;\n          data.priority = Math.min(stats.priority, data.priority);\n\n          if (stats.empty && mountedCount === 0) {\n            stats.priority = data.priority;\n            stats.mountedCount += mountedCount;\n            stats.unmountedCount += unmountedCount;\n            this.graph.trigger('render:done', {\n              stats: stats,\n              options: options\n            });\n            data.processed = 0;\n            updates.count = 0;\n          } else {\n            data.processed = processed;\n          }\n        } // Progress callback\n\n\n        var progressFn = options.progress;\n\n        if (total && typeof progressFn === 'function') {\n          FunctionExt.call(progressFn, this.graph, {\n            total: total,\n            done: stats.empty,\n            current: processed\n          });\n        } // The current frame could have been canceled in a callback\n\n\n        if (updates.animationId !== animationId) {\n          return;\n        }\n      }\n\n      updates.animationId = Dom.requestAnimationFrame(function () {\n        _this.updateViewsAsync(options, data);\n      });\n    }\n  }, {\n    key: \"registerMountedView\",\n    value: function registerMountedView(view) {\n      var cid = view.cid;\n      var updates = this.updates;\n\n      if (cid in updates.mounted) {\n        return 0;\n      }\n\n      updates.mounted[cid] = true;\n      updates.mountedCids.push(cid);\n      var flag = updates.unmounted[cid] || 0;\n      delete updates.unmounted[cid];\n      return flag;\n    }\n  }, {\n    key: \"registerUnmountedView\",\n    value: function registerUnmountedView(view) {\n      var cid = view.cid;\n      var updates = this.updates;\n\n      if (cid in updates.unmounted) {\n        return 0;\n      }\n\n      updates.unmounted[cid] |= Renderer.FLAG_INSERT;\n      var flag = updates.unmounted[cid];\n      updates.unmountedCids.push(cid);\n      delete updates.mounted[cid];\n      return flag;\n    }\n  }, {\n    key: \"isViewMounted\",\n    value: function isViewMounted(view) {\n      if (view == null) {\n        return false;\n      }\n\n      var cid = view.cid;\n      return cid in this.updates.mounted;\n    }\n  }, {\n    key: \"getMountedViews\",\n    value: function getMountedViews() {\n      return Object.keys(this.updates.mounted).map(function (cid) {\n        return CellView.views[cid];\n      });\n    }\n  }, {\n    key: \"getUnmountedViews\",\n    value: function getUnmountedViews() {\n      return Object.keys(this.updates.unmounted).map(function (cid) {\n        return CellView.views[cid];\n      });\n    }\n  }, {\n    key: \"checkMountedViews\",\n    value: function checkMountedViews(viewportFn, batchSize) {\n      var unmountCount = 0;\n\n      if (typeof viewportFn !== 'function') {\n        return unmountCount;\n      }\n\n      var updates = this.updates;\n      var mounted = updates.mounted;\n      var mountedCids = updates.mountedCids;\n      var size = batchSize == null ? mountedCids.length : Math.min(mountedCids.length, batchSize);\n\n      for (var i = 0; i < size; i += 1) {\n        var cid = mountedCids[i];\n\n        if (!(cid in mounted)) {\n          continue;\n        }\n\n        var view = CellView.views[cid];\n\n        if (view == null) {\n          continue;\n        }\n\n        var shouldMount = FunctionExt.call(viewportFn, this.graph, {\n          view: view,\n          unmounted: true\n        });\n\n        if (shouldMount) {\n          // Push at the end of all mounted ids\n          mountedCids.push(cid);\n          continue;\n        }\n\n        unmountCount += 1;\n        var flag = this.registerUnmountedView(view);\n\n        if (flag) {\n          view.unmount();\n        }\n      } // Get rid of views, that have been unmounted\n\n\n      mountedCids.splice(0, size);\n      return unmountCount;\n    }\n  }, {\n    key: \"checkUnmountedViews\",\n    value: function checkUnmountedViews(checkView, batchSize) {\n      var mountCount = 0;\n\n      if (typeof checkView !== 'function') {\n        checkView = null; // eslint-disable-line\n      }\n\n      var updates = this.updates;\n      var unmounted = updates.unmounted;\n      var unmountedCids = updates.unmountedCids;\n      var size = batchSize == null ? unmountedCids.length : Math.min(unmountedCids.length, batchSize);\n\n      for (var i = 0; i < size; i += 1) {\n        var cid = unmountedCids[i];\n\n        if (!(cid in unmounted)) {\n          continue;\n        }\n\n        var view = CellView.views[cid];\n\n        if (view == null) {\n          continue;\n        }\n\n        if (checkView && !FunctionExt.call(checkView, this.graph, {\n          view: view,\n          unmounted: false\n        })) {\n          unmountedCids.push(cid);\n          continue;\n        }\n\n        mountCount += 1;\n        var flag = this.registerMountedView(view);\n\n        if (flag) {\n          this.scheduleViewUpdate(view, flag, view.priority, {\n            mounting: true\n          });\n        }\n      } // Get rid of views, that have been mounted\n\n\n      unmountedCids.splice(0, size);\n      return mountCount;\n    }\n  }, {\n    key: \"checkViewImpl\",\n    value: function checkViewImpl() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        mountedBatchSize: Number.MAX_SAFE_INTEGER,\n        unmountedBatchSize: Number.MAX_SAFE_INTEGER\n      };\n      var checkView = options.checkView || this.options.checkView;\n      var unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);\n      var mountedCount = this.checkUnmountedViews(checkView, // Do not check views, that have been just unmounted\n      // and pushed at the end of the cids array\n      unmountedCount > 0 ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize) : options.mountedBatchSize);\n      return {\n        mountedCount: mountedCount,\n        unmountedCount: unmountedCount\n      };\n    }\n    /**\n     * Determine every view in the graph should be attached/detached.\n     */\n\n  }, {\n    key: \"checkView\",\n    value: function checkView() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.checkViewImpl(options);\n    }\n  }, {\n    key: \"isFrozen\",\n    value: function isFrozen() {\n      return !!this.options.frozen;\n    }\n    /**\n     * Freeze the graph then the graph does not automatically re-render upon\n     * changes in the graph. This is useful when adding large numbers of cells.\n     */\n\n  }, {\n    key: \"freeze\",\n    value: function freeze() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var key = options.key;\n      var updates = this.updates;\n      var frozen = this.options.frozen;\n      var freezeKey = updates.freezeKey;\n\n      if (key && key !== freezeKey) {\n        if (frozen && freezeKey) {\n          // key passed, but the graph is already freezed with another key\n          return;\n        }\n\n        updates.frozen = frozen;\n        updates.freezeKey = key;\n      }\n\n      this.options.frozen = true;\n      var animationId = updates.animationId;\n      updates.animationId = null;\n\n      if (this.isAsync() && animationId != null) {\n        Dom.cancelAnimationFrame(animationId);\n      }\n\n      this.graph.trigger('freeze', {\n        key: key\n      });\n    }\n  }, {\n    key: \"unfreeze\",\n    value: function unfreeze() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var key = options.key;\n      var updates = this.updates;\n      var freezeKey = updates.freezeKey; // key passed, but the graph is already freezed with another key\n\n      if (key && freezeKey && key !== freezeKey) {\n        return;\n      }\n\n      updates.freezeKey = null; // key passed, but the graph is already freezed\n\n      if (key && key === freezeKey && updates.frozen) {\n        return;\n      }\n\n      var callback = function callback() {\n        _this2.options.frozen = updates.frozen = false;\n\n        if (updates.sort) {\n          _this2.sortViews();\n\n          updates.sort = false;\n        }\n\n        var afterFn = options.after;\n\n        if (afterFn) {\n          FunctionExt.call(afterFn, _this2.graph, _this2.graph);\n        }\n\n        _this2.graph.trigger('unfreeze', {\n          key: key\n        });\n      };\n\n      if (this.isAsync()) {\n        this.freeze();\n        var onProgress = options.progress;\n        this.updateViewsAsync(Object.assign(Object.assign({}, options), {\n          progress: function progress(_ref7) {\n            var done = _ref7.done,\n                current = _ref7.current,\n                total = _ref7.total;\n\n            if (onProgress) {\n              FunctionExt.call(onProgress, _this2.graph, {\n                done: done,\n                current: current,\n                total: total\n              });\n            } // sort views after async render\n\n\n            if (done) {\n              callback();\n            }\n          }\n        }));\n      } else {\n        this.updateViews(options);\n        callback();\n      }\n    }\n  }, {\n    key: \"isAsync\",\n    value: function isAsync() {\n      return !!this.options.async;\n    }\n  }, {\n    key: \"setAsync\",\n    value: function setAsync(async) {\n      this.options.async = async;\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.freeze();\n      this.removeViews();\n    }\n  }, {\n    key: \"resetViews\",\n    value: function resetViews() {\n      var cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.resetUpdates();\n      this.removeViews();\n      this.freeze({\n        key: 'reset'\n      });\n\n      for (var i = 0, n = cells.length; i < n; i += 1) {\n        this.renderView(cells[i], options);\n      }\n\n      this.unfreeze({\n        key: 'reset'\n      });\n      this.sortViews();\n    }\n  }, {\n    key: \"removeView\",\n    value: function removeView(cell) {\n      var view = this.views[cell.id];\n\n      if (view) {\n        var cid = view.cid;\n        var updates = this.updates;\n        var mounted = updates.mounted;\n        var unmounted = updates.unmounted;\n        view.remove();\n        delete this.views[cell.id];\n        delete mounted[cid];\n        delete unmounted[cid];\n      }\n\n      return view;\n    }\n  }, {\n    key: \"removeViews\",\n    value: function removeViews() {\n      var _this3 = this;\n\n      if (this.views) {\n        Object.keys(this.views).forEach(function (id) {\n          var view = _this3.views[id];\n\n          if (view) {\n            _this3.removeView(view.cell);\n          }\n        });\n      }\n\n      this.views = {};\n    }\n  }, {\n    key: \"renderView\",\n    value: function renderView(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var id = cell.id;\n      var views = this.views;\n      var flag = 0;\n      var view = views[id];\n\n      if (!cell.isVisible()) {\n        return;\n      }\n\n      if (cell.isEdge()) {\n        if (!this.isEdgeTerminalVisible(cell, 'source') || !this.isEdgeTerminalVisible(cell, 'target')) {\n          return;\n        }\n      }\n\n      if (view) {\n        flag = Renderer.FLAG_INSERT;\n      } else {\n        var tmp = this.graph.hook.createCellView(cell);\n\n        if (tmp) {\n          view = views[cell.id] = tmp;\n          view.graph = this.graph;\n          flag = this.registerUnmountedView(view) | view.getBootstrapFlag();\n        }\n      }\n\n      if (view) {\n        this.requestViewUpdate(view, flag, view.priority, options);\n      }\n    }\n  }, {\n    key: \"isExactSorting\",\n    value: function isExactSorting() {\n      return this.options.sorting === 'exact';\n    }\n  }, {\n    key: \"sortViews\",\n    value: function sortViews() {\n      if (!this.isExactSorting()) {\n        return;\n      }\n\n      if (this.isFrozen()) {\n        // sort views once unfrozen\n        this.updates.sort = true;\n        return;\n      }\n\n      this.sortViewsExact();\n    }\n  }, {\n    key: \"sortElements\",\n    value: function sortElements(elems, comparator) {\n      // Highly inspired by the jquery.sortElements plugin by Padolsey.\n      // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n      var placements = elems.map(function (elem) {\n        var parentNode = elem.parentNode; // Since the element itself will change position, we have\n        // to have some way of storing it's original position in\n        // the DOM. The easiest way is to have a 'flag' node:\n\n        var nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);\n        return function (targetNode) {\n          if (parentNode === targetNode) {\n            throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n          } // Insert before flag\n\n\n          parentNode.insertBefore(targetNode, nextSibling); // Remove flag\n\n          parentNode.removeChild(nextSibling);\n        };\n      });\n      elems.sort(comparator).forEach(function (elem, index) {\n        return placements[index](elem);\n      });\n    }\n  }, {\n    key: \"sortViewsExact\",\n    value: function sortViewsExact() {\n      // const elems = this.view.stage.querySelectorAll('[data-cell-id]')\n      // const length = elems.length\n      // const cells = []\n      // for (let i = 0; i < length; i++) {\n      //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')\n      //   cells.push({\n      //     id: cell.id,\n      //     zIndex: cell.getZIndex() || 0,\n      //     elem: elems[i],\n      //   })\n      // }\n      // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)\n      // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves\n      // if (moves && moves.length) {\n      //   moves.forEach((move) => {\n      //     if (move.type) {\n      //       const elem = move.item.elem as Element\n      //       const parentNode = elem.parentNode\n      //       const index = move.index\n      //       if (parentNode) {\n      //         if (index === length - 1) {\n      //           parentNode.appendChild(elem)\n      //         } else if (index < length - 1) {\n      //           parentNode.insertBefore(elem, elems[index + 1])\n      //         }\n      //       }\n      //     }\n      //   })\n      // }\n      // Run insertion sort algorithm in order to efficiently sort DOM\n      // elements according to their associated cell `zIndex` attribute.\n      var elems = this.view.$(this.view.stage).children('[data-cell-id]').toArray();\n      var model = this.model;\n      this.sortElements(elems, function (a, b) {\n        var cellA = model.getCell(a.getAttribute('data-cell-id') || '');\n        var cellB = model.getCell(b.getAttribute('data-cell-id') || '');\n        var z1 = cellA.getZIndex() || 0;\n        var z2 = cellB.getZIndex() || 0;\n        return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;\n      });\n    }\n  }, {\n    key: \"addZPivot\",\n    value: function addZPivot() {\n      var zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (this.zPivots == null) {\n        this.zPivots = {};\n      }\n\n      var pivots = this.zPivots;\n      var pivot = pivots[zIndex];\n\n      if (pivot) {\n        return pivot;\n      }\n\n      pivot = pivots[zIndex] = document.createComment(\"z-index:\".concat(zIndex + 1));\n      var neighborZ = -Infinity; // eslint-disable-next-line\n\n      for (var key in pivots) {\n        var currentZ = +key;\n\n        if (currentZ < zIndex && currentZ > neighborZ) {\n          neighborZ = currentZ;\n\n          if (neighborZ === zIndex - 1) {\n            continue;\n          }\n        }\n      }\n\n      var layer = this.view.stage;\n\n      if (neighborZ !== -Infinity) {\n        var neighborPivot = pivots[neighborZ];\n        layer.insertBefore(pivot, neighborPivot.nextSibling);\n      } else {\n        layer.insertBefore(pivot, layer.firstChild);\n      }\n\n      return pivot;\n    }\n  }, {\n    key: \"removeZPivots\",\n    value: function removeZPivots() {\n      var _this4 = this;\n\n      if (this.zPivots) {\n        Object.keys(this.zPivots).forEach(function (z) {\n          var elem = _this4.zPivots[z];\n\n          if (elem && elem.parentNode) {\n            elem.parentNode.removeChild(elem);\n          }\n        });\n      }\n\n      this.zPivots = {};\n    }\n  }, {\n    key: \"insertView\",\n    value: function insertView(view) {\n      var stage = this.view.stage;\n\n      switch (this.options.sorting) {\n        case 'approx':\n          {\n            var zIndex = view.cell.getZIndex();\n            var pivot = this.addZPivot(zIndex);\n            stage.insertBefore(view.container, pivot);\n            break;\n          }\n\n        case 'exact':\n        default:\n          stage.appendChild(view.container);\n          break;\n      }\n    }\n  }, {\n    key: \"findViewByCell\",\n    value: function findViewByCell(cell) {\n      if (cell == null) {\n        return null;\n      }\n\n      var id = Cell.isCell(cell) ? cell.id : cell;\n      return this.views[id];\n    }\n  }, {\n    key: \"findViewByElem\",\n    value: function findViewByElem(elem) {\n      if (elem == null) {\n        return null;\n      }\n\n      var target = typeof elem === 'string' ? this.view.stage.querySelector(elem) : elem instanceof Element ? elem : elem[0];\n\n      if (target) {\n        var id = this.view.findAttr('data-cell-id', target);\n\n        if (id) {\n          return this.views[id];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"findViewsFromPoint\",\n    value: function findViewsFromPoint(p) {\n      var _this5 = this;\n\n      var ref = {\n        x: p.x,\n        y: p.y\n      };\n      return this.model.getCells().map(function (cell) {\n        return _this5.findViewByCell(cell);\n      }).filter(function (view) {\n        if (view != null) {\n          return Dom.getBBox(view.container, {\n            target: _this5.view.stage\n          }).containsPoint(ref);\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"findEdgeViewsInArea\",\n    value: function findEdgeViewsInArea(rect) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var area = Rectangle.create(rect);\n      return this.model.getEdges().map(function (edge) {\n        return _this6.findViewByCell(edge);\n      }).filter(function (view) {\n        if (view) {\n          var bbox = Dom.getBBox(view.container, {\n            target: _this6.view.stage\n          });\n\n          if (bbox.width === 0) {\n            bbox.inflate(1, 0);\n          } else if (bbox.height === 0) {\n            bbox.inflate(0, 1);\n          }\n\n          return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"findViewsInArea\",\n    value: function findViewsInArea(rect) {\n      var _this7 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var area = Rectangle.create(rect);\n      return this.model.getNodes().map(function (node) {\n        return _this7.findViewByCell(node);\n      }).filter(function (view) {\n        if (view) {\n          var bbox = Dom.getBBox(view.container, {\n            target: _this7.view.stage\n          });\n          return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.resetUpdates();\n      this.stopListening();\n    }\n  }]);\n\n  return Renderer;\n}(Base);\n\n__decorate([Base.dispose()], Renderer.prototype, \"dispose\", null);\n\n(function (Renderer) {\n  Renderer.FLAG_INSERT = 1 << 30;\n  Renderer.FLAG_REMOVE = 1 << 29;\n  Renderer.MOUNT_BATCH_SIZE = 1000;\n  Renderer.UPDATE_BATCH_SIZE = 1000;\n  Renderer.MIN_PRIORITY = 2;\n  Renderer.SORT_DELAYING_BATCHES = ['add', 'to-front', 'to-back'];\n  Renderer.UPDATE_DELAYING_BATCHES = ['translate'];\n})(Renderer || (Renderer = {}));","map":null,"metadata":{},"sourceType":"module"}