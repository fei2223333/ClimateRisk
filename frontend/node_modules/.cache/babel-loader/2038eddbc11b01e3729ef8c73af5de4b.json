{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Util } from '../../global';\nimport { StringExt, FunctionExt } from '../../util';\nimport { Point, Rectangle, Angle } from '../../geometry';\nimport { Cell } from '../../model/cell';\nimport { notify } from '../transform/util';\nexport var NodePreset = /*#__PURE__*/function () {\n  function NodePreset(halo) {\n    _classCallCheck(this, NodePreset);\n\n    this.halo = halo;\n  }\n\n  _createClass(NodePreset, [{\n    key: \"getPresets\",\n    value: function getPresets() {\n      return {\n        className: 'type-node',\n        handles: [{\n          name: 'remove',\n          position: 'nw',\n          events: {\n            mousedown: this.removeCell.bind(this)\n          },\n          icon: null\n        }, {\n          name: 'resize',\n          position: 'se',\n          events: {\n            mousedown: this.startResize.bind(this),\n            mousemove: this.doResize.bind(this),\n            mouseup: this.stopResize.bind(this)\n          },\n          icon: null\n        }, {\n          name: 'clone',\n          position: 'n',\n          events: {\n            mousedown: this.startClone.bind(this),\n            mousemove: this.doClone.bind(this),\n            mouseup: this.stopClone.bind(this)\n          },\n          icon: null\n        }, {\n          name: 'link',\n          position: 'e',\n          events: {\n            mousedown: this.startLink.bind(this),\n            mousemove: this.doLink.bind(this),\n            mouseup: this.stopLink.bind(this)\n          },\n          icon: null\n        }, {\n          name: 'fork',\n          position: 'ne',\n          events: {\n            mousedown: this.startFork.bind(this),\n            mousemove: this.doFork.bind(this),\n            mouseup: this.stopFork.bind(this)\n          },\n          icon: null\n        }, {\n          name: 'unlink',\n          position: 'w',\n          events: {\n            mousedown: this.unlink.bind(this)\n          },\n          icon: null\n        }, {\n          name: 'rotate',\n          position: 'sw',\n          events: {\n            mousedown: this.startRotate.bind(this),\n            mousemove: this.doRotate.bind(this),\n            mouseup: this.stopRotate.bind(this)\n          },\n          icon: null\n        }],\n        bbox: function bbox(view) {\n          if (this.options.useCellGeometry) {\n            var node = view.cell;\n            return node.getBBox();\n          }\n\n          return view.getBBox();\n        },\n        content: function content(view) {\n          var template = StringExt.template('x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>');\n          var cell = view.cell;\n          var bbox = cell.getBBox();\n          return template({\n            x: Math.floor(bbox.x),\n            y: Math.floor(bbox.y),\n            width: Math.floor(bbox.width),\n            height: Math.floor(bbox.height),\n            angle: Math.floor(cell.getAngle())\n          });\n        },\n        magnet: function magnet(view) {\n          return view.container;\n        },\n        tinyThreshold: 40,\n        smallThreshold: 80,\n        loopEdgePreferredSide: 'top',\n        loopEdgeWidth: 40,\n        rotateGrid: 15,\n        rotateEmbeds: false\n      };\n    }\n  }, {\n    key: \"removeCell\",\n    value: function removeCell() {\n      this.model.removeConnectedEdges(this.cell);\n      this.cell.remove();\n    } // #region create edge\n\n  }, {\n    key: \"startLink\",\n    value: function startLink(_ref) {\n      var x = _ref.x,\n          y = _ref.y;\n      this.halo.startBatch();\n      var graph = this.graph;\n      var edge = this.createEdgeConnectedToSource();\n      edge.setTarget({\n        x: x,\n        y: y\n      });\n      this.model.addEdge(edge, {\n        validation: false,\n        halo: this.halo.cid,\n        async: false\n      });\n      graph.view.undelegateEvents();\n      this.edgeView = graph.renderer.findViewByCell(edge);\n      this.edgeView.prepareArrowheadDragging('target', {\n        x: x,\n        y: y,\n        fallbackAction: 'remove'\n      });\n    }\n  }, {\n    key: \"createEdgeConnectedToSource\",\n    value: function createEdgeConnectedToSource() {\n      var magnet = this.getMagnet(this.view, 'source');\n      var terminal = this.getEdgeTerminal(this.view, magnet);\n      var edge = this.graph.hook.getDefaultEdge(this.view, magnet);\n      edge.setSource(terminal);\n      return edge;\n    }\n  }, {\n    key: \"getMagnet\",\n    value: function getMagnet(view, terminal) {\n      var magnet = this.options.magnet;\n\n      if (typeof magnet === 'function') {\n        var val = FunctionExt.call(magnet, this.halo, view, terminal);\n\n        if (val instanceof SVGElement) {\n          return val;\n        }\n      }\n\n      throw new Error('`magnet()` has to return an SVGElement');\n    }\n  }, {\n    key: \"getEdgeTerminal\",\n    value: function getEdgeTerminal(view, magnet) {\n      var terminal = {\n        cell: view.cell.id\n      };\n\n      if (magnet !== view.container) {\n        var port = magnet.getAttribute('port');\n\n        if (port) {\n          terminal.port = port;\n        } else {\n          terminal.selector = view.getSelector(magnet);\n        }\n      }\n\n      return terminal;\n    }\n  }, {\n    key: \"doLink\",\n    value: function doLink(_ref2) {\n      var e = _ref2.e,\n          x = _ref2.x,\n          y = _ref2.y;\n\n      if (this.edgeView) {\n        this.edgeView.onMouseMove(e, x, y);\n      }\n    }\n  }, {\n    key: \"stopLink\",\n    value: function stopLink(_ref3) {\n      var e = _ref3.e,\n          x = _ref3.x,\n          y = _ref3.y;\n      var edgeView = this.edgeView;\n\n      if (edgeView) {\n        edgeView.onMouseUp(e, x, y);\n        var edge = edgeView.cell;\n\n        if (edge.hasLoop()) {\n          this.makeLoopEdge(edge);\n        }\n\n        this.halo.stopBatch();\n        this.halo.trigger('action:edge:addde', {\n          edge: edge\n        });\n        this.edgeView = null;\n      }\n\n      this.graph.view.delegateEvents();\n    }\n  }, {\n    key: \"makeLoopEdge\",\n    value: function makeLoopEdge(edge) {\n      var vertex1 = null;\n      var vertex2 = null;\n      var loopEdgeWidth = this.options.loopEdgeWidth;\n      var graphOptions = this.graph.options;\n      var graphRect = new Rectangle(0, 0, graphOptions.width, graphOptions.height);\n      var bbox = this.graph.graphToLocal(this.view.getBBox());\n      var found = [this.options.loopEdgePreferredSide, 'top', 'bottom', 'left', 'right'].some(function (position) {\n        var point = null;\n        var dx = 0;\n        var dy = 0;\n\n        switch (position) {\n          case 'top':\n            point = new Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth);\n            dx = loopEdgeWidth / 2;\n            break;\n\n          case 'bottom':\n            point = new Point(bbox.x + bbox.width / 2, bbox.y + bbox.height + loopEdgeWidth);\n            dx = loopEdgeWidth / 2;\n            break;\n\n          case 'left':\n            point = new Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2);\n            dy = loopEdgeWidth / 2;\n            break;\n\n          case 'right':\n            point = new Point(bbox.x + bbox.width + loopEdgeWidth, bbox.y + bbox.height / 2);\n            dy = loopEdgeWidth / 2;\n            break;\n\n          default:\n            break;\n        }\n\n        if (point) {\n          vertex1 = point.translate(-dx, -dy);\n          vertex2 = point.translate(dx, dy);\n          return graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2);\n        }\n\n        return false;\n      });\n\n      if (found && vertex1 && vertex2) {\n        edge.setVertices([vertex1, vertex2]);\n      }\n    } // #endregion\n    // #region resize\n\n  }, {\n    key: \"startResize\",\n    value: function startResize(_ref4) {\n      var e = _ref4.e;\n      this.halo.startBatch();\n      this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(Angle.normalize(this.node.getAngle()) / 45)];\n      this.view.addClass('node-resizing');\n      notify('node:resize', e, this.view);\n    }\n  }, {\n    key: \"doResize\",\n    value: function doResize(_ref5) {\n      var e = _ref5.e,\n          dx = _ref5.dx,\n          dy = _ref5.dy;\n      var size = this.node.getSize();\n      var width = Math.max(size.width + (this.flip ? dx : dy), 1);\n      var height = Math.max(size.height + (this.flip ? dy : dx), 1);\n      this.node.resize(width, height, {\n        absolute: true\n      });\n      notify('node:resizing', e, this.view);\n    }\n  }, {\n    key: \"stopResize\",\n    value: function stopResize(_ref6) {\n      var e = _ref6.e;\n      this.view.removeClass('node-resizing');\n      notify('node:resized', e, this.view);\n      this.halo.stopBatch();\n    } // #endregion\n    // #region clone\n\n  }, {\n    key: \"startClone\",\n    value: function startClone(_ref7) {\n      var e = _ref7.e,\n          x = _ref7.x,\n          y = _ref7.y;\n      this.halo.startBatch();\n      var options = this.options;\n      var cloned = options.clone(this.cell, {\n        clone: true\n      });\n\n      if (!Cell.isCell(cloned)) {\n        throw new Error(\"option 'clone()' has to return a cell\");\n      }\n\n      this.centerNodeAtCursor(cloned, x, y);\n      this.model.addCell(cloned, {\n        halo: this.halo.cid,\n        async: false\n      });\n      var cloneView = this.graph.renderer.findViewByCell(cloned);\n      cloneView.onMouseDown(e, x, y);\n      this.halo.setEventData(e, {\n        cloneView: cloneView\n      });\n    }\n  }, {\n    key: \"centerNodeAtCursor\",\n    value: function centerNodeAtCursor(cell, x, y) {\n      var center = cell.getBBox().getCenter();\n      var dx = x - center.x;\n      var dy = y - center.y;\n      cell.translate(dx, dy);\n    }\n  }, {\n    key: \"doClone\",\n    value: function doClone(_ref8) {\n      var e = _ref8.e,\n          x = _ref8.x,\n          y = _ref8.y;\n      var view = this.halo.getEventData(e).cloneView;\n\n      if (view) {\n        view.onMouseMove(e, x, y);\n      }\n    }\n  }, {\n    key: \"stopClone\",\n    value: function stopClone(_ref9) {\n      var e = _ref9.e,\n          x = _ref9.x,\n          y = _ref9.y;\n      var nodeView = this.halo.getEventData(e).cloneView;\n\n      if (nodeView) {\n        nodeView.onMouseUp(e, x, y);\n      }\n\n      this.halo.stopBatch();\n    } // #endregion\n    // #region fork\n\n  }, {\n    key: \"startFork\",\n    value: function startFork(_ref10) {\n      var e = _ref10.e,\n          x = _ref10.x,\n          y = _ref10.y;\n      this.halo.startBatch();\n      var cloned = this.options.clone(this.cell, {\n        fork: true\n      });\n\n      if (!Cell.isCell(cloned)) {\n        throw new Error(\"option 'clone()' has to return a cell\");\n      }\n\n      this.centerNodeAtCursor(cloned, x, y);\n      this.model.addCell(cloned, {\n        halo: this.halo.cid,\n        async: false\n      });\n      var edge = this.createEdgeConnectedToSource();\n      var cloneView = this.graph.renderer.findViewByCell(cloned);\n      var magnet = this.getMagnet(cloneView, 'target');\n      var terminal = this.getEdgeTerminal(cloneView, magnet);\n      edge.setTarget(terminal);\n      this.model.addEdge(edge, {\n        halo: this.halo.cid,\n        async: false\n      });\n      cloneView.onMouseDown(e, x, y);\n      this.halo.setEventData(e, {\n        cloneView: cloneView\n      });\n    }\n  }, {\n    key: \"doFork\",\n    value: function doFork(_ref11) {\n      var e = _ref11.e,\n          x = _ref11.x,\n          y = _ref11.y;\n      var view = this.halo.getEventData(e).cloneView;\n\n      if (view) {\n        view.onMouseMove(e, x, y);\n      }\n    }\n  }, {\n    key: \"stopFork\",\n    value: function stopFork(_ref12) {\n      var e = _ref12.e,\n          x = _ref12.x,\n          y = _ref12.y;\n      var view = this.halo.getEventData(e).cloneView;\n\n      if (view) {\n        view.onMouseUp(e, x, y);\n      }\n\n      this.halo.stopBatch();\n    } // #endregion\n    // #region rotate\n\n  }, {\n    key: \"startRotate\",\n    value: function startRotate(_ref13) {\n      var _this = this;\n\n      var e = _ref13.e,\n          x = _ref13.x,\n          y = _ref13.y;\n      this.halo.startBatch();\n      var center = this.node.getBBox().getCenter();\n      var nodes = [this.node];\n\n      if (this.options.rotateEmbeds) {\n        this.node.getDescendants({\n          deep: true\n        }).reduce(function (memo, cell) {\n          if (cell.isNode()) {\n            memo.push(cell);\n          }\n\n          return memo;\n        }, nodes);\n      }\n\n      this.halo.setEventData(e, {\n        center: center,\n        nodes: nodes,\n        rotateStartAngles: nodes.map(function (node) {\n          return node.getAngle();\n        }),\n        clientStartAngle: new Point(x, y).theta(center)\n      });\n      nodes.forEach(function (node) {\n        var view = _this.graph.findViewByCell(node);\n\n        if (view) {\n          view.addClass('node-rotating');\n          notify('node:rotate', e, view);\n        }\n      });\n    }\n  }, {\n    key: \"doRotate\",\n    value: function doRotate(_ref14) {\n      var _this2 = this;\n\n      var e = _ref14.e,\n          x = _ref14.x,\n          y = _ref14.y;\n      var data = this.halo.getEventData(e);\n      var delta = data.clientStartAngle - new Point(x, y).theta(data.center);\n      data.nodes.forEach(function (node, index) {\n        var startAngle = data.rotateStartAngles[index];\n        var targetAngle = Util.snapToGrid(startAngle + delta, _this2.options.rotateGrid);\n        node.rotate(targetAngle, {\n          absolute: true,\n          center: data.center,\n          halo: _this2.halo.cid\n        });\n        notify('node:rotating', e, _this2.graph.findViewByCell(node));\n      });\n    }\n  }, {\n    key: \"stopRotate\",\n    value: function stopRotate(_ref15) {\n      var _this3 = this;\n\n      var e = _ref15.e;\n      var data = this.halo.getEventData(e);\n      data.nodes.forEach(function (node) {\n        var view = _this3.graph.findViewByCell(node);\n\n        view.removeClass('node-rotating');\n        notify('node:rotated', e, view);\n      });\n      this.halo.stopBatch();\n    } // #endregion\n    // #region unlink\n\n  }, {\n    key: \"unlink\",\n    value: function unlink() {\n      this.halo.startBatch();\n      this.model.removeConnectedEdges(this.cell);\n      this.halo.stopBatch();\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this.halo.options;\n    }\n  }, {\n    key: \"graph\",\n    get: function get() {\n      return this.halo.graph;\n    }\n  }, {\n    key: \"model\",\n    get: function get() {\n      return this.halo.model;\n    }\n  }, {\n    key: \"view\",\n    get: function get() {\n      return this.halo.view;\n    }\n  }, {\n    key: \"cell\",\n    get: function get() {\n      return this.halo.cell;\n    }\n  }, {\n    key: \"node\",\n    get: function get() {\n      return this.cell;\n    }\n  }]);\n\n  return NodePreset;\n}();","map":null,"metadata":{},"sourceType":"module"}