{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ComboForceLayout = void 0;\n\nvar base_1 = require(\"./base\");\n\nvar util_1 = require(\"../util\");\n/**\n * force layout for graph with combos\n */\n\n\nvar ComboForceLayout =\n/** @class */\nfunction (_super) {\n  __extends(ComboForceLayout, _super);\n\n  function ComboForceLayout(options) {\n    var _this = _super.call(this) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 100;\n    /** 重力大小，影响图的紧凑程度 */\n\n    _this.gravity = 10;\n    /** 群组中心力大小 */\n\n    _this.comboGravity = 10;\n    /** 默认边长度 */\n\n    _this.linkDistance = 10;\n    /** 每次迭代位移的衰减相关参数 */\n\n    _this.alpha = 1;\n    _this.alphaMin = 0.001;\n    _this.alphaDecay = 1 - Math.pow(_this.alphaMin, 1 / 300);\n    _this.alphaTarget = 0;\n    /** 节点运动速度衰减参数 */\n\n    _this.velocityDecay = 0.6;\n    /** 边引力大小 */\n\n    _this.edgeStrength = 0.6;\n    /** 节点引力大小 */\n\n    _this.nodeStrength = 30;\n    /** 是否开启防止重叠 */\n\n    _this.preventOverlap = false;\n    /** 是否开启节点之间的防止重叠 */\n\n    _this.preventNodeOverlap = false;\n    /** 是否开启 Combo 之间的防止重叠 */\n\n    _this.preventComboOverlap = false;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.collideStrength = undefined;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.nodeCollideStrength = 0.5;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.comboCollideStrength = 0.5;\n    /** Combo 最小间距，防止重叠时的间隙 */\n\n    _this.comboSpacing = 20;\n    /** Combo 内部的 padding */\n\n    _this.comboPadding = 10;\n    /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n\n    _this.optimizeRangeFactor = 1;\n    /** 每次迭代的回调函数 */\n\n    _this.onTick = function () {};\n    /** 迭代结束的回调函数 */\n\n\n    _this.onLayoutEnd = function () {};\n    /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n\n\n    _this.depthAttractiveForceScale = 1;\n    /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n\n    _this.depthRepulsiveForceScale = 2;\n    /** 内部计算参数 */\n\n    _this.nodes = [];\n    _this.edges = [];\n    _this.combos = [];\n    _this.comboTrees = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.bias = [];\n    _this.nodeMap = {};\n    _this.oriComboMap = {};\n    _this.indexMap = {};\n    _this.comboMap = {};\n    _this.previousLayouted = false;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  ComboForceLayout.prototype.getDefaultCfg = function () {\n    return {\n      maxIteration: 100,\n      center: [0, 0],\n      gravity: 10,\n      speed: 1,\n      comboGravity: 30,\n      preventOverlap: false,\n      preventComboOverlap: true,\n      preventNodeOverlap: true,\n      nodeSpacing: undefined,\n      collideStrength: undefined,\n      nodeCollideStrength: 0.5,\n      comboCollideStrength: 0.5,\n      comboSpacing: 20,\n      comboPadding: 10,\n      edgeStrength: 0.6,\n      nodeStrength: 30,\n      linkDistance: 10\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  ComboForceLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var center = self.center;\n    self.comboTree = {\n      id: \"comboTreeRoot\",\n      depth: -1,\n      children: self.comboTrees\n    };\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    self.initVals(); // layout\n\n    self.run();\n    if (self.onLayoutEnd) self.onLayoutEnd();\n  };\n\n  ComboForceLayout.prototype.run = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var maxIteration = self.previousLayouted ? self.maxIteration / 5 : self.maxIteration;\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    var center = self.center;\n    var velocityDecay = self.velocityDecay; // init the positions to make the nodes with same combo gather around the combo\n\n    var comboMap = self.comboMap;\n    if (!self.previousLayouted) self.initPos(comboMap);\n\n    var _loop_1 = function _loop_1(i) {\n      var displacements = [];\n      nodes.forEach(function (_, j) {\n        displacements[j] = {\n          x: 0,\n          y: 0\n        };\n      });\n      self.applyCalculate(displacements); // gravity for combos\n\n      self.applyComboCenterForce(displacements); // move\n\n      nodes.forEach(function (n, j) {\n        if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y)) return;\n        n.x += displacements[j].x * velocityDecay;\n        n.y += displacements[j].y * velocityDecay;\n      });\n      self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n      self.onTick();\n    }; // iterate\n\n\n    for (var i = 0; i < maxIteration; i++) {\n      _loop_1(i);\n    } // move to center\n\n\n    var meanCenter = [0, 0];\n    nodes.forEach(function (n) {\n      if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y)) return;\n      meanCenter[0] += n.x;\n      meanCenter[1] += n.y;\n    });\n    meanCenter[0] /= nodes.length;\n    meanCenter[1] /= nodes.length;\n    var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n    nodes.forEach(function (n, j) {\n      if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y)) return;\n      n.x += centerOffset[0];\n      n.y += centerOffset[1];\n    }); // arrange the empty combo\n\n    self.combos.forEach(function (combo) {\n      var mapped = comboMap[combo.id];\n\n      if (mapped && mapped.empty) {\n        combo.x = mapped.cx || combo.x;\n        combo.y = mapped.cy || combo.y;\n      }\n    });\n    self.previousLayouted = true;\n  };\n\n  ComboForceLayout.prototype.initVals = function () {\n    var self = this;\n    var edges = self.edges;\n    var nodes = self.nodes;\n    var combos = self.combos;\n    var count = {};\n    var nodeMap = {};\n    var indexMap = {};\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = node;\n      indexMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.indexMap = indexMap;\n    var oriComboMap = {};\n    combos.forEach(function (combo) {\n      oriComboMap[combo.id] = combo;\n    });\n    self.oriComboMap = oriComboMap;\n    self.comboMap = self.getComboMap();\n    var preventOverlap = self.preventOverlap;\n    self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n    self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n    var collideStrength = self.collideStrength;\n\n    if (collideStrength) {\n      self.comboCollideStrength = collideStrength;\n      self.nodeCollideStrength = collideStrength;\n    }\n\n    self.comboCollideStrength = self.comboCollideStrength ? self.comboCollideStrength : 0;\n    self.nodeCollideStrength = self.nodeCollideStrength ? self.nodeCollideStrength : 0; // get edge bias\n\n    for (var i = 0; i < edges.length; ++i) {\n      var source = (0, util_1.getEdgeTerminal)(edges[i], 'source');\n      var target = (0, util_1.getEdgeTerminal)(edges[i], 'target');\n      if (count[source]) count[source]++;else count[source] = 1;\n      if (count[target]) count[target]++;else count[target] = 1;\n    }\n\n    var bias = [];\n\n    for (var i = 0; i < edges.length; ++i) {\n      var source = (0, util_1.getEdgeTerminal)(edges[i], 'source');\n      var target = (0, util_1.getEdgeTerminal)(edges[i], 'target');\n      bias[i] = count[source] / (count[source] + count[target]);\n    }\n\n    this.bias = bias;\n    var nodeSize = self.nodeSize;\n    var nodeSpacing = self.nodeSpacing;\n    var nodeSizeFunc;\n    var nodeSpacingFunc; // nodeSpacing to function\n\n    if ((0, util_1.isNumber)(nodeSpacing)) {\n      nodeSpacingFunc = function nodeSpacingFunc() {\n        return nodeSpacing;\n      };\n    } else if ((0, util_1.isFunction)(nodeSpacing)) {\n      nodeSpacingFunc = nodeSpacing;\n    } else {\n      nodeSpacingFunc = function nodeSpacingFunc() {\n        return 0;\n      };\n    }\n\n    this.nodeSpacing = nodeSpacingFunc; // nodeSize to function\n\n    if (!nodeSize) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        if (d.size) {\n          if ((0, util_1.isArray)(d.size)) {\n            var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return res / 2;\n          }\n\n          if ((0, util_1.isObject)(d.size)) {\n            var res = d.size.width > d.size.height ? d.size.width : d.size.height;\n            return res / 2;\n          }\n\n          return d.size / 2;\n        }\n\n        return 10;\n      };\n    } else if ((0, util_1.isFunction)(nodeSize)) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return nodeSize(d);\n      };\n    } else if ((0, util_1.isArray)(nodeSize)) {\n      var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      var radius_1 = larger / 2;\n\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return radius_1;\n      };\n    } else {\n      // number type\n      var radius_2 = nodeSize / 2;\n\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return radius_2;\n      };\n    }\n\n    this.nodeSize = nodeSizeFunc; // comboSpacing to function\n\n    var comboSpacing = self.comboSpacing;\n    var comboSpacingFunc;\n\n    if ((0, util_1.isNumber)(comboSpacing)) {\n      comboSpacingFunc = function comboSpacingFunc() {\n        return comboSpacing;\n      };\n    } else if ((0, util_1.isFunction)(comboSpacing)) {\n      comboSpacingFunc = comboSpacing;\n    } else {\n      // null type\n      comboSpacingFunc = function comboSpacingFunc() {\n        return 0;\n      };\n    }\n\n    this.comboSpacing = comboSpacingFunc; // comboPadding to function\n\n    var comboPadding = self.comboPadding;\n    var comboPaddingFunc;\n\n    if ((0, util_1.isNumber)(comboPadding)) {\n      comboPaddingFunc = function comboPaddingFunc() {\n        return comboPadding;\n      };\n    } else if ((0, util_1.isArray)(comboPadding)) {\n      comboPaddingFunc = function comboPaddingFunc() {\n        return Math.max.apply(null, comboPadding);\n      };\n    } else if ((0, util_1.isFunction)(comboPadding)) {\n      comboPaddingFunc = comboPadding;\n    } else {\n      // null type\n      comboPaddingFunc = function comboPaddingFunc() {\n        return 0;\n      };\n    }\n\n    this.comboPadding = comboPaddingFunc; // linkDistance to function\n\n    var linkDistance = this.linkDistance;\n    var linkDistanceFunc;\n\n    if (!linkDistance) {\n      linkDistance = 10;\n    }\n\n    if ((0, util_1.isNumber)(linkDistance)) {\n      linkDistanceFunc = function linkDistanceFunc(d) {\n        return linkDistance;\n      };\n    } else {\n      linkDistanceFunc = linkDistance;\n    }\n\n    this.linkDistance = linkDistanceFunc; // linkStrength to function\n\n    var edgeStrength = this.edgeStrength;\n    var edgeStrengthFunc;\n\n    if (!edgeStrength) {\n      edgeStrength = 1;\n    }\n\n    if ((0, util_1.isNumber)(edgeStrength)) {\n      edgeStrengthFunc = function edgeStrengthFunc(d) {\n        return edgeStrength;\n      };\n    } else {\n      edgeStrengthFunc = edgeStrength;\n    }\n\n    this.edgeStrength = edgeStrengthFunc; // nodeStrength to function\n\n    var nodeStrength = this.nodeStrength;\n    var nodeStrengthFunc;\n\n    if (!nodeStrength) {\n      nodeStrength = 30;\n    }\n\n    if ((0, util_1.isNumber)(nodeStrength)) {\n      nodeStrengthFunc = function nodeStrengthFunc(d) {\n        return nodeStrength;\n      };\n    } else {\n      nodeStrengthFunc = nodeStrength;\n    }\n\n    this.nodeStrength = nodeStrengthFunc;\n  };\n\n  ComboForceLayout.prototype.initPos = function (comboMap) {\n    var self = this;\n    var nodes = self.nodes;\n    nodes.forEach(function (node, i) {\n      var comboId = node.comboId;\n      var combo = comboMap[comboId];\n\n      if (comboId && combo) {\n        node.x = combo.cx + 100 / (i + 1);\n        node.y = combo.cy + 100 / (i + 1);\n      } else {\n        node.x = 100 / (i + 1);\n        node.y = 100 / (i + 1);\n      }\n    });\n  };\n\n  ComboForceLayout.prototype.getComboMap = function () {\n    var self = this;\n    var nodeMap = self.nodeMap;\n    var comboTrees = self.comboTrees;\n    var oriComboMap = self.oriComboMap;\n    var comboMap = {};\n    (comboTrees || []).forEach(function (ctree) {\n      var treeChildren = [];\n      (0, util_1.traverseTreeUp)(ctree, function (treeNode) {\n        if (treeNode.itemType === \"node\") return true; // skip it\n\n        if (!oriComboMap[treeNode.id]) return true; // means it is hidden, skip it\n\n        if (comboMap[treeNode.id] === undefined) {\n          var combo = {\n            id: treeNode.id,\n            name: treeNode.id,\n            cx: 0,\n            cy: 0,\n            count: 0,\n            depth: self.oriComboMap[treeNode.id].depth || 0,\n            children: []\n          };\n          comboMap[treeNode.id] = combo;\n        }\n\n        var children = treeNode.children;\n\n        if (children) {\n          children.forEach(function (child) {\n            if (!comboMap[child.id] && !nodeMap[child.id]) return true; // means it is hidden\n\n            treeChildren.push(child);\n          });\n        }\n\n        var c = comboMap[treeNode.id];\n        c.cx = 0;\n        c.cy = 0;\n\n        if (treeChildren.length === 0) {\n          c.empty = true;\n          var oriCombo = oriComboMap[treeNode.id];\n          c.cx = oriCombo.x;\n          c.cy = oriCombo.y;\n        }\n\n        treeChildren.forEach(function (child) {\n          c.count++;\n\n          if (child.itemType !== \"node\") {\n            var childCombo = comboMap[child.id];\n            if ((0, util_1.isNumber)(childCombo.cx)) c.cx += childCombo.cx;\n            if ((0, util_1.isNumber)(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n\n          var node = nodeMap[child.id]; // means the node is hidden, skip it\n\n          if (!node) return;\n\n          if ((0, util_1.isNumber)(node.x)) {\n            c.cx += node.x;\n          }\n\n          if ((0, util_1.isNumber)(node.y)) {\n            c.cy += node.y;\n          }\n        });\n        c.cx /= c.count || 1;\n        c.cy /= c.count || 1;\n        c.children = treeChildren;\n        return true;\n      });\n    });\n    return comboMap;\n  };\n\n  ComboForceLayout.prototype.applyComboCenterForce = function (displacements) {\n    var self = this;\n    var gravity = self.gravity;\n    var comboGravity = self.comboGravity || gravity;\n    var alpha = this.alpha;\n    var comboTrees = self.comboTrees;\n    var indexMap = self.indexMap;\n    var nodeMap = self.nodeMap;\n    var comboMap = self.comboMap;\n    (comboTrees || []).forEach(function (ctree) {\n      (0, util_1.traverseTreeUp)(ctree, function (treeNode) {\n        if (treeNode.itemType === \"node\") return true; // skip it\n\n        var combo = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n        if (!combo) return true;\n        var c = comboMap[treeNode.id]; // higher depth the combo, larger the gravity\n\n        var gravityScale = (c.depth + 1) / 10 * 0.5; // apply combo center force for all the descend nodes in this combo\n        // and update the center position and count for this combo\n\n        var comboX = c.cx;\n        var comboY = c.cy;\n        c.cx = 0;\n        c.cy = 0;\n        c.children.forEach(function (child) {\n          if (child.itemType !== \"node\") {\n            var childCombo = comboMap[child.id];\n            if (childCombo && (0, util_1.isNumber)(childCombo.cx)) c.cx += childCombo.cx;\n            if (childCombo && (0, util_1.isNumber)(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n\n          var node = nodeMap[child.id];\n          var vecX = node.x - comboX || 0.005;\n          var vecY = node.y - comboY || 0.005;\n          var l = Math.sqrt(vecX * vecX + vecY * vecY);\n          var childIdx = indexMap[node.id];\n          var params = comboGravity * alpha / l * gravityScale;\n          displacements[childIdx].x -= vecX * params;\n          displacements[childIdx].y -= vecY * params;\n          if ((0, util_1.isNumber)(node.x)) c.cx += node.x;\n          if ((0, util_1.isNumber)(node.y)) c.cy += node.y;\n        });\n        c.cx /= c.count || 1;\n        c.cy /= c.count || 1;\n        return true;\n      });\n    });\n  };\n\n  ComboForceLayout.prototype.applyCalculate = function (displacements) {\n    var self = this;\n    var comboMap = self.comboMap;\n    var nodes = self.nodes; // store the vx, vy, and distance to reduce dulplicate calculation\n\n    var vecMap = {};\n    nodes.forEach(function (v, i) {\n      nodes.forEach(function (u, j) {\n        if (i < j) return;\n        var vx = v.x - u.x || 0.005;\n        var vy = v.y - u.y || 0.005;\n        var vl2 = vx * vx + vy * vy;\n        var vl = Math.sqrt(vl2);\n        if (vl2 < 1) vl2 = vl;\n        vecMap[\"\".concat(v.id, \"-\").concat(u.id)] = {\n          vx: vx,\n          vy: vy,\n          vl2: vl2,\n          vl: vl\n        };\n        vecMap[\"\".concat(u.id, \"-\").concat(v.id)] = {\n          vl2: vl2,\n          vl: vl,\n          vx: -vx,\n          vy: -vy\n        };\n      });\n    }); // get the sizes of the combos\n\n    self.updateComboSizes(comboMap);\n    self.calRepulsive(displacements, vecMap);\n    self.calAttractive(displacements, vecMap);\n    var preventComboOverlap = self.preventComboOverlap;\n    if (preventComboOverlap) self.comboNonOverlapping(displacements, comboMap);\n  };\n  /**\n   * Update the sizes of the combos according to their children\n   * Used for combos nonoverlap, but not re-render the combo shapes\n   */\n\n\n  ComboForceLayout.prototype.updateComboSizes = function (comboMap) {\n    var self = this;\n    var comboTrees = self.comboTrees;\n    var nodeMap = self.nodeMap;\n    var nodeSize = self.nodeSize;\n    var comboSpacing = self.comboSpacing;\n    var comboPadding = self.comboPadding;\n    (comboTrees || []).forEach(function (ctree) {\n      var treeChildren = [];\n      (0, util_1.traverseTreeUp)(ctree, function (treeNode) {\n        if (treeNode.itemType === \"node\") return true; // skip it\n\n        var c = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n        if (!c) return false;\n        var children = treeNode.children;\n\n        if (children) {\n          children.forEach(function (child) {\n            // means the combo is hidden.\n            if (!comboMap[child.id] && !nodeMap[child.id]) return;\n            treeChildren.push(child);\n          });\n        }\n\n        c.minX = Infinity;\n        c.minY = Infinity;\n        c.maxX = -Infinity;\n        c.maxY = -Infinity;\n        treeChildren.forEach(function (child) {\n          if (child.itemType !== \"node\") return true; // skip it\n\n          var node = nodeMap[child.id];\n          if (!node) return true; // means it is hidden\n\n          var r = nodeSize(node);\n          var nodeMinX = node.x - r;\n          var nodeMinY = node.y - r;\n          var nodeMaxX = node.x + r;\n          var nodeMaxY = node.y + r;\n          if (c.minX > nodeMinX) c.minX = nodeMinX;\n          if (c.minY > nodeMinY) c.minY = nodeMinY;\n          if (c.maxX < nodeMaxX) c.maxX = nodeMaxX;\n          if (c.maxY < nodeMaxY) c.maxY = nodeMaxY;\n        });\n        var minSize = self.oriComboMap[treeNode.id].size || 10;\n        if ((0, util_1.isArray)(minSize)) minSize = minSize[0];\n        var maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n        c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n        return true;\n      });\n    });\n  };\n  /**\n   * prevent the overlappings among combos\n   */\n\n\n  ComboForceLayout.prototype.comboNonOverlapping = function (displacements, comboMap) {\n    var self = this;\n    var comboTree = self.comboTree;\n    var comboCollideStrength = self.comboCollideStrength;\n    var indexMap = self.indexMap;\n    var nodeMap = self.nodeMap;\n    (0, util_1.traverseTreeUp)(comboTree, function (treeNode) {\n      if (!comboMap[treeNode.id] && !nodeMap[treeNode.id] && treeNode.id !== \"comboTreeRoot\") {\n        return false;\n      } // means it is hidden\n\n\n      var children = treeNode.children; // 同个子树下的子 combo 间两两对比\n\n      if (children && children.length > 1) {\n        children.forEach(function (v, i) {\n          if (v.itemType === \"node\") return false; // skip it\n\n          var cv = comboMap[v.id];\n          if (!cv) return; // means it is hidden, skip it\n\n          children.forEach(function (u, j) {\n            if (i <= j) return false;\n            if (u.itemType === \"node\") return false; // skip it\n\n            var cu = comboMap[u.id];\n            if (!cu) return false; // means it is hidden, skip it\n\n            var vx = cv.cx - cu.cx || 0.005;\n            var vy = cv.cy - cu.cy || 0.005;\n            var l = vx * vx + vy * vy;\n            var rv = cv.r || 1;\n            var ru = cu.r || 1;\n            var r = rv + ru;\n            var ru2 = ru * ru;\n            var rv2 = rv * rv; // overlapping\n\n            if (l < r * r) {\n              var vnodes = v.children;\n              if (!vnodes || vnodes.length === 0) return false; // skip it\n\n              var unodes_1 = u.children;\n              if (!unodes_1 || unodes_1.length === 0) return false; // skip it\n\n              var sqrtl = Math.sqrt(l);\n              var ll = (r - sqrtl) / sqrtl * comboCollideStrength;\n              var xl_1 = vx * ll;\n              var yl_1 = vy * ll;\n              var rratio_1 = ru2 / (rv2 + ru2);\n              var irratio_1 = 1 - rratio_1; // 两兄弟 combo 的子节点上施加斥力\n\n              vnodes.forEach(function (vn) {\n                if (vn.itemType !== \"node\") return false; // skip it\n\n                if (!nodeMap[vn.id]) return; // means it is hidden, skip it\n\n                var vindex = indexMap[vn.id];\n                unodes_1.forEach(function (un) {\n                  if (un.itemType !== \"node\") return false;\n                  if (!nodeMap[un.id]) return false; // means it is hidden, skip it\n\n                  var uindex = indexMap[un.id];\n                  displacements[vindex].x += xl_1 * rratio_1;\n                  displacements[vindex].y += yl_1 * rratio_1;\n                  displacements[uindex].x -= xl_1 * irratio_1;\n                  displacements[uindex].y -= yl_1 * irratio_1;\n                });\n              });\n            }\n          });\n        });\n      }\n\n      return true;\n    });\n  };\n  /**\n   * Calculate the repulsive force between each node pair\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n\n\n  ComboForceLayout.prototype.calRepulsive = function (displacements, vecMap) {\n    var self = this;\n    var nodes = self.nodes;\n    var max = self.width * self.optimizeRangeFactor;\n    var nodeStrength = self.nodeStrength;\n    var alpha = self.alpha;\n    var nodeCollideStrength = self.nodeCollideStrength;\n    var preventNodeOverlap = self.preventNodeOverlap;\n    var nodeSizeFunc = self.nodeSize;\n    var nodeSpacingFunc = self.nodeSpacing;\n    var scale = self.depthRepulsiveForceScale;\n    var center = self.center;\n    nodes.forEach(function (v, i) {\n      if (!v.x || !v.y) return; // center gravity\n\n      if (center) {\n        var gravity = self.gravity;\n        var vecX = v.x - center[0] || 0.005;\n        var vecY = v.y - center[1] || 0.005;\n        var l = Math.sqrt(vecX * vecX + vecY * vecY);\n        displacements[i].x -= vecX * gravity * alpha / l;\n        displacements[i].y -= vecY * gravity * alpha / l;\n      }\n\n      nodes.forEach(function (u, j) {\n        if (i === j) {\n          return;\n        }\n\n        if (!u.x || !u.y) return;\n        var _a = vecMap[\"\".concat(v.id, \"-\").concat(u.id)],\n            vl2 = _a.vl2,\n            vl = _a.vl;\n        if (vl > max) return;\n        var _b = vecMap[\"\".concat(v.id, \"-\").concat(u.id)],\n            vx = _b.vx,\n            vy = _b.vy;\n        var depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;\n        depthDiff = depthDiff < 1 ? 1 : depthDiff;\n        if (u.comboId !== v.comboId) depthDiff += 1;\n        var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n        var params = nodeStrength(u) * alpha / vl2 * depthParam;\n        displacements[i].x += vx * params;\n        displacements[i].y += vy * params; // prevent node overlappings\n\n        if (i < j && preventNodeOverlap) {\n          var ri = nodeSizeFunc(v) + nodeSpacingFunc(v) || 1;\n          var rj = nodeSizeFunc(u) + nodeSpacingFunc(u) || 1;\n          var r = ri + rj;\n\n          if (vl2 < r * r) {\n            var ll = (r - vl) / vl * nodeCollideStrength;\n            var rj2 = rj * rj;\n            var rratio = rj2 / (ri * ri + rj2);\n            var xl = vx * ll;\n            var yl = vy * ll;\n            displacements[i].x += xl * rratio;\n            displacements[i].y += yl * rratio;\n            rratio = 1 - rratio;\n            displacements[j].x -= xl * rratio;\n            displacements[j].y -= yl * rratio;\n          }\n        }\n      });\n    });\n  };\n  /**\n   * Calculate the attractive force between the node pair with edge\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n\n\n  ComboForceLayout.prototype.calAttractive = function (displacements, vecMap) {\n    var self = this;\n    var edges = self.edges;\n    var linkDistance = self.linkDistance;\n    var alpha = self.alpha;\n    var edgeStrength = self.edgeStrength;\n    var bias = self.bias;\n    var scale = self.depthAttractiveForceScale;\n    edges.forEach(function (e, i) {\n      var source = (0, util_1.getEdgeTerminal)(e, 'source');\n      var target = (0, util_1.getEdgeTerminal)(e, 'target');\n      if (!source || !target || source === target) return;\n      var uIndex = self.indexMap[source];\n      var vIndex = self.indexMap[target];\n      var u = self.nodeMap[source];\n      var v = self.nodeMap[target];\n      if (!u || !v) return;\n      var depthDiff = u.depth === v.depth ? 0 : Math.log(Math.abs(u.depth - v.depth) / 10);\n\n      if (u.comboId === v.comboId) {\n        depthDiff = depthDiff / 2;\n      }\n\n      var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n\n      if (u.comboId !== v.comboId && depthParam === 1) {\n        depthParam = scale / 2;\n      } else if (u.comboId === v.comboId) {\n        depthParam = 2;\n      }\n\n      if (!(0, util_1.isNumber)(v.x) || !(0, util_1.isNumber)(u.x) || !(0, util_1.isNumber)(v.y) || !(0, util_1.isNumber)(u.y)) {\n        return;\n      }\n\n      var _a = vecMap[\"\".concat(target, \"-\").concat(source)],\n          vl = _a.vl,\n          vx = _a.vx,\n          vy = _a.vy;\n      var l = (vl - linkDistance(e)) / vl * alpha * edgeStrength(e) * depthParam;\n      var vecX = vx * l;\n      var vecY = vy * l;\n      var b = bias[i];\n      displacements[vIndex].x -= vecX * b;\n      displacements[vIndex].y -= vecY * b;\n      displacements[uIndex].x += vecX * (1 - b);\n      displacements[uIndex].y += vecY * (1 - b);\n    });\n  };\n\n  ComboForceLayout.prototype.getType = function () {\n    return \"comboForce\";\n  };\n\n  return ComboForceLayout;\n}(base_1.Base);\n\nexports.ComboForceLayout = ComboForceLayout;","map":null,"metadata":{},"sourceType":"script"}