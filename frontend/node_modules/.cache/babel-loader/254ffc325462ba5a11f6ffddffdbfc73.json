{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Util, Config } from '../global';\nimport { ArrayExt, FunctionExt, Dom, Vector } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Cell } from '../model/cell';\nimport { CellView } from './cell';\nimport { Markup } from './markup';\nexport var NodeView = /*#__PURE__*/function (_CellView) {\n  _inherits(NodeView, _CellView);\n\n  function NodeView() {\n    var _this;\n\n    _classCallCheck(this, NodeView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeView).apply(this, arguments));\n    _this.scalableNode = null;\n    _this.rotatableNode = null;\n    _this.scalableSelector = 'scalable';\n    _this.rotatableSelector = 'rotatable';\n    _this.defaultPortMarkup = Markup.getPortMarkup();\n    _this.defaultPortLabelMarkup = Markup.getPortLabelMarkup();\n    _this.defaultPortContainerMarkup = Markup.getPortContainerMarkup();\n    _this.portsCache = {}; // #endregion\n\n    return _this;\n  }\n\n  _createClass(NodeView, [{\n    key: \"getContainerClassName\",\n    value: function getContainerClassName() {\n      var classList = [_get(_getPrototypeOf(NodeView.prototype), \"getContainerClassName\", this).call(this), this.prefixClassName('node')];\n\n      if (!this.can('nodeMovable')) {\n        classList.push(this.prefixClassName('node-immovable'));\n      }\n\n      return classList.join(' ');\n    }\n  }, {\n    key: \"updateClassName\",\n    value: function updateClassName(e) {\n      var target = e.target;\n\n      if (target.hasAttribute('magnet')) {\n        // port\n        var className = this.prefixClassName('port-unconnectable');\n\n        if (this.can('magnetConnectable')) {\n          Dom.removeClass(target, className);\n        } else {\n          Dom.addClass(target, className);\n        }\n      } else {\n        // node\n        var _className = this.prefixClassName('node-immovable');\n\n        if (this.can('nodeMovable')) {\n          this.removeClass(_className);\n        } else {\n          this.addClass(_className);\n        }\n      }\n    }\n  }, {\n    key: \"isNodeView\",\n    value: function isNodeView() {\n      return true;\n    }\n  }, {\n    key: \"confirmUpdate\",\n    value: function confirmUpdate(flag) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ret = flag;\n\n      if (this.hasAction(ret, 'ports')) {\n        this.removePorts();\n        this.cleanPortsCache();\n      }\n\n      if (this.hasAction(ret, 'render')) {\n        this.render();\n        ret = this.removeAction(ret, ['render', 'update', 'resize', 'translate', 'rotate', 'ports', 'tools']);\n      } else {\n        ret = this.handleAction(ret, 'resize', function () {\n          return _this2.resize(options);\n        }, 'update');\n        ret = this.handleAction(ret, 'update', function () {\n          return _this2.update();\n        }, // `update()` will render ports when useCSSSelectors are enabled\n        Config.useCSSSelector ? 'ports' : null);\n        ret = this.handleAction(ret, 'translate', function () {\n          return _this2.translate();\n        });\n        ret = this.handleAction(ret, 'rotate', function () {\n          return _this2.rotate();\n        });\n        ret = this.handleAction(ret, 'ports', function () {\n          return _this2.renderPorts();\n        });\n        ret = this.handleAction(ret, 'tools', function () {\n          return _this2.renderTools();\n        });\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"update\",\n    value: function update(partialAttrs) {\n      this.cleanCache(); // When CSS selector strings are used, make sure no rule matches port nodes.\n\n      if (Config.useCSSSelector) {\n        this.removePorts();\n      }\n\n      var node = this.cell;\n      var size = node.getSize();\n      var attrs = node.getAttrs();\n      this.updateAttrs(this.container, attrs, {\n        attrs: partialAttrs === attrs ? null : partialAttrs,\n        rootBBox: new Rectangle(0, 0, size.width, size.height),\n        selectors: this.selectors,\n        scalableNode: this.scalableNode,\n        rotatableNode: this.rotatableNode\n      });\n\n      if (Config.useCSSSelector) {\n        this.renderPorts();\n      }\n    }\n  }, {\n    key: \"renderMarkup\",\n    value: function renderMarkup() {\n      var markup = this.cell.markup;\n\n      if (markup) {\n        if (typeof markup === 'string') {\n          return this.renderStringMarkup(markup);\n        }\n\n        return this.renderJSONMarkup(markup);\n      }\n\n      throw new TypeError('Invalid node markup.');\n    }\n  }, {\n    key: \"renderJSONMarkup\",\n    value: function renderJSONMarkup(markup) {\n      var ret = this.parseJSONMarkup(markup, this.container);\n\n      var one = function one(elems) {\n        return Array.isArray(elems) ? elems[0] : elems;\n      };\n\n      this.selectors = ret.selectors;\n      this.rotatableNode = one(this.selectors[this.rotatableSelector]);\n      this.scalableNode = one(this.selectors[this.scalableSelector]);\n      this.container.appendChild(ret.fragment);\n    }\n  }, {\n    key: \"renderStringMarkup\",\n    value: function renderStringMarkup(markup) {\n      Dom.append(this.container, Vector.toNodes(Vector.createVectors(markup)));\n      this.rotatableNode = Dom.findOne(this.container, \".\".concat(this.rotatableSelector));\n      this.scalableNode = Dom.findOne(this.container, \".\".concat(this.scalableSelector));\n      this.selectors = {};\n\n      if (this.rootSelector) {\n        this.selectors[this.rootSelector] = this.container;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.empty();\n      this.renderMarkup();\n\n      if (this.scalableNode) {\n        // Double update is necessary for elements with the scalable group only\n        // Note the `resize()` triggers the other `update`.\n        this.update();\n      }\n\n      this.resize();\n\n      if (this.rotatableNode) {\n        this.rotate();\n        this.translate();\n      } else {\n        this.updateTransform();\n      }\n\n      if (!Config.useCSSSelector) {\n        this.renderPorts();\n      }\n\n      this.renderTools();\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.scalableNode) {\n        return this.updateSize(opt);\n      }\n\n      if (this.cell.getAngle()) {\n        this.rotate();\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"translate\",\n    value: function translate() {\n      if (this.rotatableNode) {\n        return this.updateTranslation();\n      }\n\n      this.updateTransform();\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate() {\n      if (this.rotatableNode) {\n        this.updateRotation(); // It's necessary to call the update for the nodes outside\n        // the rotatable group referencing nodes inside the group\n\n        this.update();\n        return;\n      }\n\n      this.updateTransform();\n    }\n  }, {\n    key: \"getTranslationString\",\n    value: function getTranslationString() {\n      var position = this.cell.getPosition();\n      return \"translate(\".concat(position.x, \",\").concat(position.y, \")\");\n    }\n  }, {\n    key: \"getRotationString\",\n    value: function getRotationString() {\n      var angle = this.cell.getAngle();\n\n      if (angle) {\n        var size = this.cell.getSize();\n        return \"rotate(\".concat(angle, \",\").concat(size.width / 2, \",\").concat(size.height / 2, \")\");\n      }\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      var transform = this.getTranslationString();\n      var rot = this.getRotationString();\n\n      if (rot) {\n        transform += \" \".concat(rot);\n      }\n\n      this.container.setAttribute('transform', transform);\n    }\n  }, {\n    key: \"updateRotation\",\n    value: function updateRotation() {\n      if (this.rotatableNode != null) {\n        var transform = this.getRotationString();\n\n        if (transform != null) {\n          this.rotatableNode.setAttribute('transform', transform);\n        } else {\n          this.rotatableNode.removeAttribute('transform');\n        }\n      }\n    }\n  }, {\n    key: \"updateTranslation\",\n    value: function updateTranslation() {\n      this.container.setAttribute('transform', this.getTranslationString());\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize() {\n      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var cell = this.cell;\n      var size = cell.getSize();\n      var angle = cell.getAngle();\n      var scalableNode = this.scalableNode; // Getting scalable group's bbox.\n      // Due to a bug in webkit's native SVG .getBBox implementation, the\n      // bbox of groups with path children includes the paths' control points.\n      // To work around the issue, we need to check whether there are any path\n      // elements inside the scalable group.\n\n      var recursive = false;\n\n      if (scalableNode.getElementsByTagName('path').length > 0) {\n        // If scalable has at least one descendant that is a path, we need\n        // toswitch to recursive bbox calculation. Otherwise, group bbox\n        // calculation works and so we can use the (faster) native function.\n        recursive = true;\n      }\n\n      var scalableBBox = Dom.getBBox(scalableNode, {\n        recursive: recursive\n      }); // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero\n      // which can happen if the element does not have any content.\n\n      var sx = size.width / (scalableBBox.width || 1);\n      var sy = size.height / (scalableBBox.height || 1);\n      scalableNode.setAttribute('transform', \"scale(\".concat(sx, \",\").concat(sy, \")\")); // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n      // Order of transformations is significant but we want to reconstruct the object always in the order:\n      // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n      // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n      // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n      // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n      // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n      // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\n      var rotatableNode = this.rotatableNode;\n\n      if (rotatableNode != null) {\n        var transform = rotatableNode.getAttribute('transform');\n\n        if (transform) {\n          rotatableNode.setAttribute('transform', \"\".concat(transform, \" rotate(\").concat(-angle, \",\").concat(size.width / 2, \",\").concat(size.height / 2, \")\"));\n          var rotatableBBox = Dom.getBBox(scalableNode, {\n            target: this.graph.view.stage\n          }); // Store new x, y and perform rotate() again against the new rotation origin.\n\n          cell.prop('position', {\n            x: rotatableBBox.x,\n            y: rotatableBBox.y\n          }, Object.assign({\n            updated: true\n          }, opt));\n          this.translate();\n          this.rotate();\n        }\n      } // Update must always be called on non-rotated element. Otherwise,\n      // relative positioning would work with wrong (rotated) bounding boxes.\n\n\n      this.update();\n    } // #region ports\n\n  }, {\n    key: \"findPortElem\",\n    value: function findPortElem(portId, selector) {\n      var cache = portId ? this.portsCache[portId] : null;\n\n      if (!cache) {\n        return null;\n      }\n\n      var portRoot = cache.portContentElement;\n      var portSelectors = cache.portContentSelectors || {};\n      return this.findOne(selector, portRoot, portSelectors);\n    }\n  }, {\n    key: \"initializePorts\",\n    value: function initializePorts() {\n      this.cleanPortsCache();\n    }\n  }, {\n    key: \"refreshPorts\",\n    value: function refreshPorts() {\n      this.removePorts();\n      this.cleanPortsCache();\n      this.renderPorts();\n    }\n  }, {\n    key: \"cleanPortsCache\",\n    value: function cleanPortsCache() {\n      this.portsCache = {};\n    }\n  }, {\n    key: \"removePorts\",\n    value: function removePorts() {\n      var _this3 = this;\n\n      Object.keys(this.portsCache).forEach(function (portId) {\n        var cached = _this3.portsCache[portId];\n        Dom.remove(cached.portElement);\n      });\n    }\n  }, {\n    key: \"renderPorts\",\n    value: function renderPorts() {\n      var _this4 = this;\n\n      var container = this.getPortsContainer(); // References to rendered elements without z-index\n\n      var references = [];\n      container.childNodes.forEach(function (child) {\n        references.push(child);\n      });\n      var portsGropsByZ = ArrayExt.groupBy(this.cell.getParsedPorts(), 'zIndex');\n      var autoZIndexKey = 'auto'; // render non-z first\n\n      if (portsGropsByZ[autoZIndexKey]) {\n        portsGropsByZ[autoZIndexKey].forEach(function (port) {\n          var portElement = _this4.getPortElement(port);\n\n          container.append(portElement);\n          references.push(portElement);\n        });\n      }\n\n      Object.keys(portsGropsByZ).forEach(function (key) {\n        if (key !== autoZIndexKey) {\n          var zIndex = parseInt(key, 10);\n\n          _this4.appendPorts(portsGropsByZ[key], zIndex, references);\n        }\n      });\n      this.updatePorts();\n    }\n  }, {\n    key: \"getPortsContainer\",\n    value: function getPortsContainer() {\n      return this.rotatableNode || this.container;\n    }\n  }, {\n    key: \"appendPorts\",\n    value: function appendPorts(ports, zIndex, refs) {\n      var _this5 = this;\n\n      var elems = ports.map(function (p) {\n        return _this5.getPortElement(p);\n      });\n\n      if (refs[zIndex] || zIndex < 0) {\n        Dom.before(refs[Math.max(zIndex, 0)], elems);\n      } else {\n        Dom.append(this.getPortsContainer(), elems);\n      }\n    }\n  }, {\n    key: \"getPortElement\",\n    value: function getPortElement(port) {\n      var cached = this.portsCache[port.id];\n\n      if (cached) {\n        return cached.portElement;\n      }\n\n      return this.createPortElement(port);\n    }\n  }, {\n    key: \"createPortElement\",\n    value: function createPortElement(port) {\n      var renderResult = Markup.renderMarkup(this.getPortContainerMarkup());\n      var portElement = renderResult.elem;\n\n      if (portElement == null) {\n        throw new Error('Invalid port container markup.');\n      }\n\n      renderResult = Markup.renderMarkup(this.getPortMarkup(port));\n      var portContentElement = renderResult.elem;\n      var portContentSelectors = renderResult.selectors;\n\n      if (portContentElement == null) {\n        throw new Error('Invalid port markup.');\n      }\n\n      this.setAttrs({\n        port: port.id,\n        'port-group': port.group\n      }, portContentElement);\n      renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label));\n      var portLabelElement = renderResult.elem;\n      var portLabelSelectors = renderResult.selectors;\n\n      if (portLabelElement == null) {\n        throw new Error('Invalid port label markup.');\n      }\n\n      var portSelectors;\n\n      if (portContentSelectors && portLabelSelectors) {\n        // eslint-disable-next-line\n        for (var key in portLabelSelectors) {\n          if (portContentSelectors[key] && key !== this.rootSelector) {\n            throw new Error('Selectors within port must be unique.');\n          }\n        }\n\n        portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);\n      } else {\n        portSelectors = portContentSelectors || portLabelSelectors;\n      }\n\n      Dom.addClass(portElement, 'x6-port');\n      Dom.addClass(portContentElement, 'x6-port-body');\n      Dom.addClass(portLabelElement, 'x6-port-label');\n      portElement.appendChild(portContentElement);\n      portElement.appendChild(portLabelElement);\n      this.portsCache[port.id] = {\n        portElement: portElement,\n        portSelectors: portSelectors,\n        portLabelElement: portLabelElement,\n        portLabelSelectors: portLabelSelectors,\n        portContentElement: portContentElement,\n        portContentSelectors: portContentSelectors\n      };\n      this.graph.hook.onPortRendered({\n        port: port,\n        node: this.cell,\n        container: portElement,\n        selectors: portSelectors,\n        labelContainer: portLabelElement,\n        labelSelectors: portLabelSelectors,\n        contentContainer: portContentElement,\n        contentSelectors: portContentSelectors\n      });\n      return portElement;\n    }\n  }, {\n    key: \"updatePorts\",\n    value: function updatePorts() {\n      var _this6 = this;\n\n      // Layout ports without group\n      this.updatePortGroup(); // Layout ports with explicit group\n\n      var groups = this.cell.getParsedGroups();\n      Object.keys(groups).forEach(function (groupName) {\n        return _this6.updatePortGroup(groupName);\n      });\n    }\n  }, {\n    key: \"updatePortGroup\",\n    value: function updatePortGroup(groupName) {\n      var bbox = Rectangle.fromSize(this.cell.getSize());\n      var metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);\n\n      for (var i = 0, n = metrics.length; i < n; i += 1) {\n        var metric = metrics[i];\n        var portId = metric.portId;\n        var cached = this.portsCache[portId] || {};\n        var portLayout = metric.portLayout;\n        this.applyPortTransform(cached.portElement, portLayout);\n\n        if (metric.portAttrs != null) {\n          var options = {\n            selectors: cached.portSelectors || {}\n          };\n\n          if (metric.portSize) {\n            options.rootBBox = Rectangle.fromSize(metric.portSize);\n          }\n\n          this.updateAttrs(cached.portElement, metric.portAttrs, options);\n        }\n\n        var labelLayout = metric.labelLayout;\n\n        if (labelLayout) {\n          this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));\n\n          if (labelLayout.attrs) {\n            var _options = {\n              selectors: cached.portLabelSelectors || {}\n            };\n\n            if (metric.labelSize) {\n              _options.rootBBox = Rectangle.fromSize(metric.labelSize);\n            }\n\n            this.updateAttrs(cached.portLabelElement, labelLayout.attrs, _options);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"applyPortTransform\",\n    value: function applyPortTransform(element, layout) {\n      var initialAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var angle = layout.angle;\n      var position = layout.position;\n      var matrix = Dom.createSVGMatrix().rotate(initialAngle).translate(position.x || 0, position.y || 0).rotate(angle || 0);\n      Dom.transform(element, matrix, {\n        absolute: true\n      });\n    }\n  }, {\n    key: \"getPortContainerMarkup\",\n    value: function getPortContainerMarkup() {\n      return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup;\n    }\n  }, {\n    key: \"getPortMarkup\",\n    value: function getPortMarkup(port) {\n      return port.markup || this.cell.portMarkup || this.defaultPortMarkup;\n    }\n  }, {\n    key: \"getPortLabelMarkup\",\n    value: function getPortLabelMarkup(label) {\n      return label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup;\n    }\n  }, {\n    key: \"getEventArgs\",\n    value: function getEventArgs(e, x, y) {\n      var view = this; // eslint-disable-line\n\n      var node = view.cell;\n      var cell = node;\n\n      if (x == null || y == null) {\n        return {\n          e: e,\n          view: view,\n          node: node,\n          cell: cell\n        };\n      }\n\n      return {\n        e: e,\n        x: x,\n        y: y,\n        view: view,\n        node: node,\n        cell: cell\n      };\n    }\n  }, {\n    key: \"notifyMouseDown\",\n    value: function notifyMouseDown(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseDown\", this).call(this, e, x, y);\n\n      this.notify('node:mousedown', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"notifyMouseMove\",\n    value: function notifyMouseMove(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseMove\", this).call(this, e, x, y);\n\n      this.notify('node:mousemove', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"notifyMouseUp\",\n    value: function notifyMouseUp(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseUp\", this).call(this, e, x, y);\n\n      this.notify('node:mouseup', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onClick\",\n    value: function onClick(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onClick\", this).call(this, e, x, y);\n\n      this.notify('node:click', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onDblClick\",\n    value: function onDblClick(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onDblClick\", this).call(this, e, x, y);\n\n      this.notify('node:dblclick', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onContextMenu\",\n    value: function onContextMenu(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onContextMenu\", this).call(this, e, x, y);\n\n      this.notify('node:contextmenu', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(e, x, y) {\n      if (this.isPropagationStopped(e)) {\n        return;\n      }\n\n      this.notifyMouseDown(e, x, y);\n      this.startNodeDragging(e, x, y);\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(e, x, y) {\n      var data = this.getEventData(e);\n      var action = data.action;\n\n      if (action === 'magnet') {\n        this.dragMagnet(e, x, y);\n      } else {\n        if (action === 'move') {\n          var meta = data;\n          var view = meta.targetView || this;\n          view.dragNode(e, x, y);\n          view.notify('node:moving', {\n            e: e,\n            x: x,\n            y: y,\n            view: view,\n            cell: view.cell,\n            node: view.cell\n          });\n        }\n\n        this.notifyMouseMove(e, x, y);\n      }\n\n      this.setEventData(e, data);\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(e, x, y) {\n      var data = this.getEventData(e);\n      var action = data.action;\n\n      if (action === 'magnet') {\n        this.stopMagnetDragging(e, x, y);\n      } else {\n        this.notifyMouseUp(e, x, y);\n\n        if (action === 'move') {\n          var meta = data;\n          var view = meta.targetView || this;\n          view.stopNodeDragging(e, x, y);\n        }\n      }\n\n      var magnet = data.targetMagnet;\n\n      if (magnet) {\n        this.onMagnetClick(e, magnet, x, y);\n      }\n\n      this.checkMouseleave(e);\n    }\n  }, {\n    key: \"onMouseOver\",\n    value: function onMouseOver(e) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseOver\", this).call(this, e);\n\n      this.notify('node:mouseover', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseOut\",\n    value: function onMouseOut(e) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseOut\", this).call(this, e);\n\n      this.notify('node:mouseout', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseEnter\",\n    value: function onMouseEnter(e) {\n      this.updateClassName(e);\n\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseEnter\", this).call(this, e);\n\n      this.notify('node:mouseenter', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave(e) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseLeave\", this).call(this, e);\n\n      this.notify('node:mouseleave', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(e, x, y, delta) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseWheel\", this).call(this, e, x, y, delta);\n\n      this.notify('node:mousewheel', Object.assign({\n        delta: delta\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onMagnetClick\",\n    value: function onMagnetClick(e, magnet, x, y) {\n      var count = this.graph.view.getMouseMovedCount(e);\n\n      if (count > this.graph.options.clickThreshold) {\n        return;\n      }\n\n      this.notify('node:magnet:click', Object.assign({\n        magnet: magnet\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onMagnetDblClick\",\n    value: function onMagnetDblClick(e, magnet, x, y) {\n      this.notify('node:magnet:dblclick', Object.assign({\n        magnet: magnet\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onMagnetContextMenu\",\n    value: function onMagnetContextMenu(e, magnet, x, y) {\n      this.notify('node:magnet:contextmenu', Object.assign({\n        magnet: magnet\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onMagnetMouseDown\",\n    value: function onMagnetMouseDown(e, magnet, x, y) {\n      this.startMagnetDragging(e, x, y);\n    }\n  }, {\n    key: \"onCustomEvent\",\n    value: function onCustomEvent(e, name, x, y) {\n      this.notify('node:customevent', Object.assign({\n        name: name\n      }, this.getEventArgs(e, x, y)));\n\n      _get(_getPrototypeOf(NodeView.prototype), \"onCustomEvent\", this).call(this, e, name, x, y);\n    }\n  }, {\n    key: \"prepareEmbedding\",\n    value: function prepareEmbedding(e) {\n      // const cell = data.cell || this.cell\n      // const graph = data.graph || this.graph\n      // const model = graph.model\n      // model.startBatch('to-front')\n      // // Bring the model to the front with all his embeds.\n      // cell.toFront({ deep: true, ui: true })\n      // const maxZ = model\n      //   .getNodes()\n      //   .reduce((max, cell) => Math.max(max, cell.getZIndex() || 0), 0)\n      // const connectedEdges = model.getConnectedEdges(cell, {\n      //   deep: true,\n      //   enclosed: true,\n      // })\n      // connectedEdges.forEach((edge) => {\n      //   const zIndex = edge.getZIndex() || 0\n      //   if (zIndex <= maxZ) {\n      //     edge.setZIndex(maxZ + 1, { ui: true })\n      //   }\n      // })\n      // model.stopBatch('to-front')\n      // Before we start looking for suitable parent we remove the current one.\n      // const parent = cell.getParent()\n      // if (parent) {\n      //   parent.unembed(cell, { ui: true })\n      // }\n      var data = this.getEventData(e);\n      var node = data.cell || this.cell;\n      var view = this.graph.findViewByCell(node);\n      var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);\n      this.notify('node:embed', {\n        e: e,\n        node: node,\n        view: view,\n        cell: node,\n        x: localPoint.x,\n        y: localPoint.y,\n        currentParent: node.getParent()\n      });\n    }\n  }, {\n    key: \"processEmbedding\",\n    value: function processEmbedding(e, data) {\n      var _this7 = this;\n\n      var cell = data.cell || this.cell;\n      var graph = data.graph || this.graph;\n      var options = graph.options.embedding;\n      var findParent = options.findParent;\n      var candidates = typeof findParent === 'function' ? FunctionExt.call(findParent, graph, {\n        view: this,\n        node: this.cell\n      }).filter(function (c) {\n        return Cell.isCell(c) && _this7.cell.id !== c.id && !c.isDescendantOf(_this7.cell);\n      }) : graph.model.getNodesUnderNode(cell, {\n        by: findParent\n      }); // Picks the node with the highest `z` index\n\n      if (options.frontOnly) {\n        candidates = candidates.slice(-1);\n      }\n\n      var newCandidateView = null;\n      var prevCandidateView = data.candidateEmbedView;\n      var validateEmbeding = options.validate;\n\n      for (var i = candidates.length - 1; i >= 0; i -= 1) {\n        var candidate = candidates[i];\n\n        if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n          // candidate remains the same\n          newCandidateView = prevCandidateView;\n          break;\n        } else {\n          var view = candidate.findView(graph);\n\n          if (FunctionExt.call(validateEmbeding, graph, {\n            child: this.cell,\n            parent: view.cell,\n            childView: this,\n            parentView: view\n          })) {\n            // flip to the new candidate\n            newCandidateView = view;\n            break;\n          }\n        }\n      }\n\n      this.clearEmbedding(data);\n\n      if (newCandidateView) {\n        newCandidateView.highlight(null, {\n          type: 'embedding'\n        });\n      }\n\n      data.candidateEmbedView = newCandidateView;\n      var localPoint = graph.snapToGrid(e.clientX, e.clientY);\n      this.notify('node:embedding', {\n        e: e,\n        cell: cell,\n        node: cell,\n        view: graph.findViewByCell(cell),\n        x: localPoint.x,\n        y: localPoint.y,\n        currentParent: cell.getParent(),\n        candidateParent: newCandidateView ? newCandidateView.cell : null\n      });\n    }\n  }, {\n    key: \"clearEmbedding\",\n    value: function clearEmbedding(data) {\n      var candidateView = data.candidateEmbedView;\n\n      if (candidateView) {\n        candidateView.unhighlight(null, {\n          type: 'embedding'\n        });\n        data.candidateEmbedView = null;\n      }\n    }\n  }, {\n    key: \"finalizeEmbedding\",\n    value: function finalizeEmbedding(e, data) {\n      var cell = data.cell || this.cell;\n      var graph = data.graph || this.graph;\n      var view = graph.findViewByCell(cell);\n      var parent = cell.getParent();\n      var candidateView = data.candidateEmbedView;\n\n      if (candidateView) {\n        // Candidate view is chosen to become the parent of the node.\n        candidateView.unhighlight(null, {\n          type: 'embedding'\n        });\n        data.candidateEmbedView = null;\n\n        if (parent == null || parent.id !== candidateView.cell.id) {\n          candidateView.cell.insertChild(cell, undefined, {\n            ui: true\n          });\n        }\n      } else if (parent) {\n        parent.unembed(cell, {\n          ui: true\n        });\n      }\n\n      graph.model.getConnectedEdges(cell, {\n        deep: true\n      }).forEach(function (edge) {\n        edge.updateParent({\n          ui: true\n        });\n      });\n      var localPoint = graph.snapToGrid(e.clientX, e.clientY);\n\n      if (view) {\n        view.notify('node:embedded', {\n          e: e,\n          cell: cell,\n          x: localPoint.x,\n          y: localPoint.y,\n          node: cell,\n          view: graph.findViewByCell(cell),\n          previousParent: parent,\n          currentParent: cell.getParent()\n        });\n      }\n    }\n  }, {\n    key: \"getDelegatedView\",\n    value: function getDelegatedView() {\n      var cell = this.cell;\n      var view = this; // eslint-disable-line\n\n      while (view) {\n        if (cell.isEdge()) {\n          break;\n        }\n\n        if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n          return view;\n        }\n\n        cell = cell.getParent();\n        view = this.graph.renderer.findViewByCell(cell);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"startMagnetDragging\",\n    value: function startMagnetDragging(e, x, y) {\n      if (!this.can('magnetConnectable')) {\n        return;\n      }\n\n      e.stopPropagation();\n      var magnet = e.currentTarget;\n      var graph = this.graph;\n      this.setEventData(e, {\n        targetMagnet: magnet\n      });\n\n      if (graph.hook.validateMagnet(this, magnet, e)) {\n        if (graph.options.magnetThreshold <= 0) {\n          this.startConnectting(e, magnet, x, y);\n        }\n\n        this.setEventData(e, {\n          action: 'magnet'\n        });\n        this.stopPropagation(e);\n      } else {\n        this.onMouseDown(e, x, y);\n      }\n\n      graph.view.delegateDragEvents(e, this);\n    }\n  }, {\n    key: \"startConnectting\",\n    value: function startConnectting(e, magnet, x, y) {\n      this.graph.model.startBatch('add-edge');\n      var edgeView = this.createEdgeFromMagnet(magnet, x, y);\n      edgeView.notifyMouseDown(e, x, y); // backwards compatibility events\n\n      edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {\n        x: x,\n        y: y,\n        isNewEdge: true,\n        fallbackAction: 'remove'\n      }));\n      this.setEventData(e, {\n        edgeView: edgeView\n      });\n    }\n  }, {\n    key: \"createEdgeFromMagnet\",\n    value: function createEdgeFromMagnet(magnet, x, y) {\n      var graph = this.graph;\n      var model = graph.model;\n      var edge = graph.hook.getDefaultEdge(this, magnet);\n      edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));\n      edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {\n        x: x,\n        y: y\n      }));\n      edge.addTo(model, {\n        async: false,\n        ui: true\n      });\n      return edge.findView(graph);\n    }\n  }, {\n    key: \"dragMagnet\",\n    value: function dragMagnet(e, x, y) {\n      var data = this.getEventData(e);\n      var edgeView = data.edgeView;\n\n      if (edgeView) {\n        edgeView.onMouseMove(e, x, y);\n        this.autoScrollGraph(e.clientX, e.clientY);\n      } else {\n        var graph = this.graph;\n        var magnetThreshold = graph.options.magnetThreshold;\n        var currentTarget = this.getEventTarget(e);\n        var targetMagnet = data.targetMagnet; // magnetThreshold when the pointer leaves the magnet\n\n        if (magnetThreshold === 'onleave') {\n          if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {\n            return;\n          } // eslint-disable-next-line no-lonely-if\n\n        } else {\n          // magnetThreshold defined as a number of movements\n          if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n            return;\n          }\n        }\n\n        this.startConnectting(e, targetMagnet, x, y);\n      }\n    }\n  }, {\n    key: \"stopMagnetDragging\",\n    value: function stopMagnetDragging(e, x, y) {\n      var data = this.eventData(e);\n      var edgeView = data.edgeView;\n\n      if (edgeView) {\n        edgeView.onMouseUp(e, x, y);\n        this.graph.model.stopBatch('add-edge');\n      }\n    }\n  }, {\n    key: \"notifyUnhandledMouseDown\",\n    value: function notifyUnhandledMouseDown(e, x, y) {\n      this.notify('node:unhandled:mousedown', {\n        e: e,\n        x: x,\n        y: y,\n        view: this,\n        cell: this.cell,\n        node: this.cell\n      });\n    }\n  }, {\n    key: \"notifyNodeMove\",\n    value: function notifyNodeMove(name, e, x, y, cell) {\n      var _this8 = this;\n\n      var cells = [cell];\n      var selection = this.graph.selection.widget;\n\n      if (selection && selection.options.movable) {\n        var selectedCells = this.graph.getSelectedCells();\n\n        if (selectedCells.includes(cell)) {\n          cells = selectedCells.filter(function (c) {\n            return c.isNode();\n          });\n        }\n      }\n\n      cells.forEach(function (c) {\n        _this8.notify(name, {\n          e: e,\n          x: x,\n          y: y,\n          cell: c,\n          node: c,\n          view: c.findView(_this8.graph)\n        });\n      });\n    }\n  }, {\n    key: \"startNodeDragging\",\n    value: function startNodeDragging(e, x, y) {\n      var targetView = this.getDelegatedView();\n\n      if (targetView == null || !targetView.can('nodeMovable')) {\n        return this.notifyUnhandledMouseDown(e, x, y);\n      }\n\n      this.setEventData(e, {\n        targetView: targetView,\n        action: 'move'\n      });\n      var position = Point.create(targetView.cell.getPosition());\n      targetView.setEventData(e, {\n        moving: false,\n        offset: position.diff(x, y),\n        restrict: this.graph.hook.getRestrictArea(targetView)\n      });\n    }\n  }, {\n    key: \"dragNode\",\n    value: function dragNode(e, x, y) {\n      var node = this.cell;\n      var graph = this.graph;\n      var gridSize = graph.getGridSize();\n      var data = this.getEventData(e);\n      var offset = data.offset;\n      var restrict = data.restrict;\n\n      if (!data.moving) {\n        data.moving = true;\n        this.addClass('node-moving');\n        this.notifyNodeMove('node:move', e, x, y, this.cell);\n      }\n\n      this.autoScrollGraph(e.clientX, e.clientY);\n      var posX = Util.snapToGrid(x + offset.x, gridSize);\n      var posY = Util.snapToGrid(y + offset.y, gridSize);\n      node.setPosition(posX, posY, {\n        restrict: restrict,\n        deep: true,\n        ui: true\n      });\n\n      if (graph.options.embedding.enabled) {\n        if (!data.embedding) {\n          this.prepareEmbedding(e);\n          data.embedding = true;\n        }\n\n        this.processEmbedding(e, data);\n      }\n    }\n  }, {\n    key: \"stopNodeDragging\",\n    value: function stopNodeDragging(e, x, y) {\n      var data = this.getEventData(e);\n\n      if (data.embedding) {\n        this.finalizeEmbedding(e, data);\n      }\n\n      if (data.moving) {\n        this.removeClass('node-moving');\n        this.notifyNodeMove('node:moved', e, x, y, this.cell);\n      }\n\n      data.moving = false;\n      data.embedding = false;\n    }\n  }, {\n    key: \"autoScrollGraph\",\n    value: function autoScrollGraph(x, y) {\n      var scroller = this.graph.scroller.widget;\n\n      if (scroller) {\n        scroller.autoScroll(x, y);\n      }\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return NodeView.toStringTag;\n    }\n  }]);\n\n  return NodeView;\n}(CellView);\n\n(function (NodeView) {\n  NodeView.toStringTag = \"X6.\".concat(NodeView.name);\n\n  function isNodeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof NodeView) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var view = instance;\n\n    if ((tag == null || tag === NodeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.findPortElem === 'function' && typeof view.resize === 'function' && typeof view.rotate === 'function' && typeof view.translate === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  NodeView.isNodeView = isNodeView;\n})(NodeView || (NodeView = {}));\n\nNodeView.config({\n  isSvgElement: true,\n  priority: 0,\n  bootstrap: ['render'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    size: ['resize', 'ports', 'tools'],\n    angle: ['rotate', 'tools'],\n    position: ['translate', 'tools'],\n    ports: ['ports'],\n    tools: ['tools']\n  }\n});\nNodeView.registry.register('node', NodeView, true);","map":null,"metadata":{},"sourceType":"module"}