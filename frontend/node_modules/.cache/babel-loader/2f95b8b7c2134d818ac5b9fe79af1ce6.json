{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.width = exports.sep = exports.positionX = exports.balance = exports.alignCoordinates = exports.findSmallestWidthAlignment = exports.buildBlockGraph = exports.horizontalCompaction = exports.verticalAlignment = exports.hasConflict = exports.addConflict = exports.findOtherInnerSegmentNode = exports.findType2Conflicts = exports.findType1Conflicts = void 0;\n/*\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nvar graphlib_1 = require(\"@antv/graphlib\");\n\nvar util_1 = require(\"../util\");\n\nvar BlockGraph =\n/** @class */\nfunction (_super) {\n  __extends(BlockGraph, _super);\n\n  function BlockGraph() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return BlockGraph;\n}(graphlib_1.Graph);\n\nvar findType1Conflicts = function findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  var visitLayer = function visitLayer(prevLayer, layer) {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    var k0 = 0; // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n\n    var scanPos = 0;\n    var prevLayerLength = prevLayer.length;\n    var lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, i) {\n      var _a;\n\n      var w = (0, exports.findOtherInnerSegmentNode)(g, v);\n      var k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        (_a = layer.slice(scanPos, i + 1)) === null || _a === void 0 ? void 0 : _a.forEach(function (scanNode) {\n          var _a;\n\n          (_a = g.predecessors(scanNode)) === null || _a === void 0 ? void 0 : _a.forEach(function (u) {\n            var _a;\n\n            var uLabel = g.node(u);\n            var uPos = uLabel.order;\n\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && ((_a = g.node(scanNode)) === null || _a === void 0 ? void 0 : _a.dummy))) {\n              (0, exports.addConflict)(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n    return layer;\n  };\n\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n\n  return conflicts;\n};\n\nexports.findType1Conflicts = findType1Conflicts;\n\nvar findType2Conflicts = function findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  var scan = function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    var range = [];\n\n    for (var i = southPos; i < southEnd; i++) {\n      range.push(i);\n    }\n\n    range.forEach(function (i) {\n      var _a, _b;\n\n      v = south[i];\n\n      if ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) {\n        (_b = g.predecessors(v)) === null || _b === void 0 ? void 0 : _b.forEach(function (u) {\n          var uNode = g.node(u);\n\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            (0, exports.addConflict)(conflicts, u, v);\n          }\n        });\n      }\n    });\n  };\n\n  var visitLayer = function visitLayer(north, south) {\n    var prevNorthPos = -1;\n    var nextNorthPos;\n    var southPos = 0;\n    south === null || south === void 0 ? void 0 : south.forEach(function (v, southLookahead) {\n      var _a;\n\n      if (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) === \"border\") {\n        var predecessors = g.predecessors(v) || [];\n\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n    return south;\n  };\n\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n\n  return conflicts;\n};\n\nexports.findType2Conflicts = findType2Conflicts;\n\nvar findOtherInnerSegmentNode = function findOtherInnerSegmentNode(g, v) {\n  var _a, _b;\n\n  if ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) {\n    return (_b = g.predecessors(v)) === null || _b === void 0 ? void 0 : _b.find(function (u) {\n      return g.node(u).dummy;\n    });\n  }\n};\n\nexports.findOtherInnerSegmentNode = findOtherInnerSegmentNode;\n\nvar addConflict = function addConflict(conflicts, v, w) {\n  var vv = v;\n  var ww = w;\n\n  if (vv > ww) {\n    var tmp = vv;\n    vv = ww;\n    ww = tmp;\n  }\n\n  var conflictsV = conflicts[vv];\n\n  if (!conflictsV) {\n    conflicts[vv] = conflictsV = {};\n  }\n\n  conflictsV[ww] = true;\n};\n\nexports.addConflict = addConflict;\n\nvar hasConflict = function hasConflict(conflicts, v, w) {\n  var vv = v;\n  var ww = w;\n\n  if (vv > ww) {\n    var tmp = v;\n    vv = ww;\n    ww = tmp;\n  }\n\n  return !!conflicts[vv];\n};\n\nexports.hasConflict = hasConflict;\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\n\nvar verticalAlignment = function verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {};\n  var align = {};\n  var pos = {}; // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    var prevIdx = -1;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v) {\n      var ws = neighborFn(v);\n\n      if (ws.length) {\n        ws = ws.sort(function (a, b) {\n          return pos[a] - pos[b];\n        });\n        var mp = (ws.length - 1) / 2;\n\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n\n          if (align[v] === v && prevIdx < pos[w] && !(0, exports.hasConflict)(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n  return {\n    root: root,\n    align: align\n  };\n};\n\nexports.verticalAlignment = verticalAlignment;\n\nvar horizontalCompaction = function horizontalCompaction(g, layering, root, align, reverseSep) {\n  var _a; // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n\n\n  var xs = {};\n  var blockG = (0, exports.buildBlockGraph)(g, layering, root, reverseSep);\n  var borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  var iterate = function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }; // First pass, assign smallest coordinates\n\n\n  var pass1 = function pass1(elem) {\n    xs[elem] = (blockG.inEdges(elem) || []).reduce(function (acc, e) {\n      return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e));\n    }, 0);\n  }; // Second pass, assign greatest coordinates\n\n\n  var pass2 = function pass2(elem) {\n    var min = (blockG.outEdges(elem) || []).reduce(function (acc, e) {\n      return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n    var node = g.node(elem);\n\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  };\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG)); // Assign x coordinates to all nodes\n\n  (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n    xs[v] = xs[root[v]];\n  });\n  return xs;\n};\n\nexports.horizontalCompaction = horizontalCompaction;\n\nvar buildBlockGraph = function buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new BlockGraph();\n  var graphLabel = g.graph();\n  var sepFn = (0, exports.sep)(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    var u;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n\n      if (u) {\n        var uRoot = root[u];\n        var prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n\n      u = v;\n    });\n  });\n  return blockGraph;\n};\n\nexports.buildBlockGraph = buildBlockGraph;\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\n\nvar findSmallestWidthAlignment = function findSmallestWidthAlignment(g, xss) {\n  return (0, util_1.minBy)(Object.values(xss), function (xs) {\n    var _a;\n\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n    (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n      var x = xs[v];\n      var halfWidth = (0, exports.width)(g, v) / 2;\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n    return max - min;\n  });\n};\n\nexports.findSmallestWidthAlignment = findSmallestWidthAlignment;\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\n\nfunction alignCoordinates(xss, alignTo) {\n  // @ts-ignore\n  var alignToVals = Object.values(alignTo);\n  var alignToMin = Math.min.apply(Math, alignToVals);\n  var alignToMax = Math.max.apply(Math, alignToVals);\n  [\"u\", \"d\"].forEach(function (vert) {\n    [\"l\", \"r\"].forEach(function (horiz) {\n      var alignment = vert + horiz;\n      var xs = xss[alignment];\n      var delta;\n      if (xs === alignTo) return;\n      var xsVals = Object.values(xs);\n      delta = horiz === \"l\" ? alignToMin - Math.min.apply(Math, xsVals) : alignToMax - Math.max.apply(Math, xsVals);\n\n      if (delta) {\n        xss[alignment] = {};\n        Object.keys(xs).forEach(function (key) {\n          xss[alignment][key] = xs[key] + delta;\n        });\n      }\n    });\n  });\n}\n\nexports.alignCoordinates = alignCoordinates;\n\nvar balance = function balance(xss, align) {\n  var result = {};\n  Object.keys(xss.ul).forEach(function (key) {\n    if (align) {\n      result[key] = xss[align.toLowerCase()][key];\n    } else {\n      var values = Object.values(xss).map(function (x) {\n        return x[key];\n      });\n      var xs = values.sort(function (a, b) {\n        return a - b;\n      });\n      result[key] = (xs[1] + xs[2]) / 2;\n    }\n  });\n  return result;\n};\n\nexports.balance = balance;\n\nvar positionX = function positionX(g) {\n  var layering = (0, util_1.buildLayerMatrix)(g);\n  var conflicts = Object.assign((0, exports.findType1Conflicts)(g, layering), (0, exports.findType2Conflicts)(g, layering));\n  var xss = {};\n  var adjustedLayering;\n  [\"u\", \"d\"].forEach(function (vert) {\n    adjustedLayering = vert === \"u\" ? layering : Object.values(layering).reverse();\n    [\"l\", \"r\"].forEach(function (horiz) {\n      if (horiz === \"r\") {\n        adjustedLayering = adjustedLayering.map(function (inner) {\n          return Object.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      var align = (0, exports.verticalAlignment)(g, adjustedLayering, conflicts, neighborFn);\n      var xs = (0, exports.horizontalCompaction)(g, adjustedLayering, align.root, align.align, horiz === \"r\");\n\n      if (horiz === \"r\") {\n        Object.keys(xs).forEach(function (key) {\n          xs[key] = -xs[key];\n        });\n      }\n\n      xss[vert + horiz] = xs;\n    });\n  });\n  var smallestWidth = (0, exports.findSmallestWidthAlignment)(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return (0, exports.balance)(xss, g.graph().align);\n};\n\nexports.positionX = positionX;\n\nvar sep = function sep(nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n    sum += vLabel.width / 2;\n\n    if (vLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((vLabel.labelpos || \"\").toLowerCase()) {\n        case \"l\":\n          delta = -vLabel.width / 2;\n          break;\n\n        case \"r\":\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n\n    delta = 0;\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += wLabel.width / 2;\n\n    if (wLabel.labelpos) {\n      switch ((wLabel.labelpos || \"\").toLowerCase()) {\n        case \"l\":\n          delta = wLabel.width / 2;\n          break;\n\n        case \"r\":\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n\n    delta = 0;\n    return sum;\n  };\n};\n\nexports.sep = sep;\n\nvar width = function width(g, v) {\n  return g.node(v).width || 0;\n};\n\nexports.width = width;","map":null,"metadata":{},"sourceType":"script"}