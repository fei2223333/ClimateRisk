{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Line } from '../line';\nimport { Curve } from '../curve';\nimport { Point } from '../point';\nimport { LineTo } from './lineto';\nimport { Segment } from './segment';\nexport var MoveTo = /*#__PURE__*/function (_Segment) {\n  _inherits(MoveTo, _Segment);\n\n  function MoveTo(x, y) {\n    var _this;\n\n    _classCallCheck(this, MoveTo);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MoveTo).call(this));\n    _this.isVisible = false;\n    _this.isSubpathStart = true;\n\n    if (Line.isLine(x) || Curve.isCurve(x)) {\n      _this.endPoint = x.end.clone().round(2);\n    } else {\n      _this.endPoint = Point.create(x, y).round(2);\n    }\n\n    return _this;\n  }\n\n  _createClass(MoveTo, [{\n    key: \"bbox\",\n    value: function bbox() {\n      return null;\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint() {\n      return this.end.clone();\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength() {\n      return 0;\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength() {\n      return 0;\n    }\n  }, {\n    key: \"closestPointT\",\n    value: function closestPointT() {\n      return 1;\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent() {\n      return null;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return 0;\n    }\n  }, {\n    key: \"lengthAtT\",\n    value: function lengthAtT() {\n      return 0;\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt() {\n      return [this.clone(), this.clone()];\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength() {\n      return [this.clone(), this.clone()];\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      return [];\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt() {\n      return this.end.clone();\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength() {\n      return this.end.clone();\n    }\n  }, {\n    key: \"pointAtT\",\n    value: function pointAtT() {\n      return this.end.clone();\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt() {\n      return null;\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength() {\n      return null;\n    }\n  }, {\n    key: \"tangentAtT\",\n    value: function tangentAtT() {\n      return null;\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      return false;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.end.scale(sx, sy, origin);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.end.rotate(angle, origin);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.end.translate(tx, ty);\n      } else {\n        this.end.translate(tx);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new MoveTo(this.end);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(s) {\n      return this.type === s.type && this.end.equals(s.end);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.type,\n        end: this.end.toJSON()\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var end = this.end;\n      return \"\".concat(this.type, \" \").concat(end.x, \" \").concat(end.y);\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'M';\n    }\n  }]);\n\n  return MoveTo;\n}(Segment);\n\n(function (MoveTo) {\n  function create() {\n    var len = arguments.length;\n    var arg0 = arguments.length <= 0 ? undefined : arguments[0]; // line provided\n\n    if (Line.isLine(arg0)) {\n      return new MoveTo(arg0);\n    } // curve provided\n\n\n    if (Curve.isCurve(arg0)) {\n      return new MoveTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new MoveTo(arg0);\n      } // this is a moveto-with-subsequent-poly-line segment\n\n\n      var _segments = []; // points come one by one\n\n      for (var i = 0; i < len; i += 1) {\n        if (i === 0) {\n          _segments.push(new MoveTo(i < 0 || arguments.length <= i ? undefined : arguments[i]));\n        } else {\n          _segments.push(new LineTo(i < 0 || arguments.length <= i ? undefined : arguments[i]));\n        }\n      }\n\n      return _segments;\n    } // coordinates provided\n\n\n    if (len === 2) {\n      return new MoveTo(+(arguments.length <= 0 ? undefined : arguments[0]), +(arguments.length <= 1 ? undefined : arguments[1]));\n    } // this is a moveto-with-subsequent-poly-line segment\n\n\n    var segments = [];\n\n    for (var _i = 0; _i < len; _i += 2) {\n      var x = +(_i < 0 || arguments.length <= _i ? undefined : arguments[_i]);\n      var y = +(_i + 1 < 0 || arguments.length <= _i + 1 ? undefined : arguments[_i + 1]);\n\n      if (_i === 0) {\n        segments.push(new MoveTo(x, y));\n      } else {\n        segments.push(new LineTo(x, y));\n      }\n    }\n\n    return segments;\n  }\n\n  MoveTo.create = create;\n})(MoveTo || (MoveTo = {}));","map":null,"metadata":{},"sourceType":"module"}