{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { FunctionExt, ObjectExt } from '../util';\nimport { Model } from '../model/model';\nimport { CellView } from '../view/cell';\nimport { NodeView } from '../view/node';\nimport { EdgeView } from '../view/edge';\nimport { Knob } from '../addon/knob';\nimport { MiniMap } from '../addon/minimap';\nimport { Snapline } from '../addon/snapline';\nimport { Scroller } from '../addon/scroller';\nimport { Selection } from '../addon/selection';\nimport { Clipboard } from '../addon/clipboard';\nimport { Transform } from '../addon/transform';\nimport { HTML } from '../shape/standard/html';\nimport { Edge as StandardEdge } from '../shape/standard/edge';\nimport { Base } from './base';\nimport { Options } from './options';\nimport { Renderer } from './renderer';\nimport { GraphView } from './view';\nimport { DefsManager } from './defs';\nimport { GridManager } from './grid';\nimport { CoordManager } from './coord';\nimport { SnaplineManager } from './snapline';\nimport { ScrollerManager } from './scroller';\nimport { ClipboardManager } from './clipboard';\nimport { HighlightManager } from './highlight';\nimport { TransformManager } from './transform';\nimport { SelectionManager } from './selection';\nimport { BackgroundManager } from './background';\nimport { HistoryManager } from './history';\nimport { MiniMapManager } from './minimap';\nimport { Keyboard } from './keyboard';\nimport { MouseWheel } from './mousewheel';\nimport { PrintManager } from './print';\nimport { FormatManager } from './format';\nimport { KnobManager } from './knob';\nimport { PanningManager } from './panning';\nimport { SizeManager } from './size';\nvar Decorator;\n\n(function (Decorator) {\n  function hook(nullable, hookName) {\n    return function (target, methodName, descriptor) {\n      var raw = descriptor.value;\n      var name = hookName || methodName;\n\n      descriptor.value = function () {\n        var hook = this.options[name];\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (hook != null) {\n          this.getNativeValue = raw.bind.apply(raw, [this].concat(args));\n          var ret = FunctionExt.call.apply(FunctionExt, [hook, this.graph].concat(args));\n          this.getNativeValue = null;\n\n          if (ret != null || nullable === true && ret === null) {\n            return ret;\n          }\n        }\n\n        return raw.call.apply(raw, [this].concat(args));\n      };\n    };\n  }\n\n  Decorator.hook = hook;\n\n  function after(hookName) {\n    return function (target, methodName, descriptor) {\n      var raw = descriptor.value;\n      var name = hookName || methodName;\n\n      descriptor.value = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        var ret = raw.call.apply(raw, [this].concat(args));\n        var hook = this.options[name];\n\n        if (hook != null) {\n          ret = FunctionExt.call.apply(FunctionExt, [hook, this.graph].concat(args)) && ret;\n        }\n\n        return ret;\n      };\n    };\n  }\n\n  Decorator.after = after;\n})(Decorator || (Decorator = {}));\n\nexport var Hook = /*#__PURE__*/function (_Base) {\n  _inherits(Hook, _Base);\n\n  function Hook() {\n    _classCallCheck(this, Hook);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Hook).apply(this, arguments));\n  }\n\n  _createClass(Hook, [{\n    key: \"createModel\",\n    value: function createModel() {\n      if (this.options.model) {\n        return this.options.model;\n      }\n\n      var model = new Model();\n      model.graph = this.graph;\n      return model;\n    }\n  }, {\n    key: \"createView\",\n    value: function createView() {\n      return new GraphView(this.graph);\n    }\n  }, {\n    key: \"createRenderer\",\n    value: function createRenderer() {\n      return new Renderer(this.graph);\n    }\n  }, {\n    key: \"createDefsManager\",\n    value: function createDefsManager() {\n      return new DefsManager(this.graph);\n    }\n  }, {\n    key: \"createGridManager\",\n    value: function createGridManager() {\n      return new GridManager(this.graph);\n    }\n  }, {\n    key: \"createCoordManager\",\n    value: function createCoordManager() {\n      return new CoordManager(this.graph);\n    }\n  }, {\n    key: \"createKnobManager\",\n    value: function createKnobManager() {\n      return new KnobManager(this.graph);\n    }\n  }, {\n    key: \"createTransform\",\n    value: function createTransform(node, widgetOptions) {\n      var options = this.getTransformOptions(node);\n\n      if (options.resizable || options.rotatable) {\n        return new Transform(Object.assign(Object.assign({\n          node: node,\n          graph: this.graph\n        }, options), widgetOptions));\n      }\n\n      if (options.clearAll) {\n        Transform.removeInstances(this.graph);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createKnob\",\n    value: function createKnob(node, widgetOptions) {\n      var _this = this;\n\n      var options = Options.parseOptionGroup(this.graph, node, this.options.knob);\n      var localOptions = Object.assign(Object.assign({}, options), widgetOptions);\n\n      if (localOptions.clearAll) {\n        Knob.removeInstances(this.graph);\n      }\n\n      localOptions.clearAll = false;\n      var knob = node.prop('knob');\n      var widgets = [];\n      var meta = Array.isArray(knob) ? knob : [knob];\n      meta.forEach(function (knob, index) {\n        if (knob) {\n          if (knob.enabled === false) {\n            return;\n          }\n\n          if (typeof knob.enabled === 'function' && knob.enabled.call(_this.graph, node) === false) {\n            return;\n          }\n        } else {\n          return;\n        }\n\n        if (options.enabled) {\n          widgets.push(new Knob(Object.assign({\n            node: node,\n            index: index,\n            graph: _this.graph\n          }, localOptions)));\n        }\n      });\n      return widgets;\n    }\n  }, {\n    key: \"getTransformOptions\",\n    value: function getTransformOptions(node) {\n      var resizing = Options.parseOptionGroup(this.graph, node, this.options.resizing);\n      var rotating = Options.parseOptionGroup(this.graph, node, this.options.rotating);\n      var transforming = Options.parseOptionGroup(this.graph, node, this.options.transforming);\n      var options = Object.assign(Object.assign({}, transforming), {\n        resizable: resizing.enabled,\n        minWidth: resizing.minWidth,\n        maxWidth: resizing.maxWidth,\n        minHeight: resizing.minHeight,\n        maxHeight: resizing.maxHeight,\n        orthogonalResizing: resizing.orthogonal,\n        restrictedResizing: resizing.restrict != null ? resizing.restrict : resizing.restricted,\n        autoScrollOnResizing: resizing.autoScroll,\n        preserveAspectRatio: resizing.preserveAspectRatio,\n        allowReverse: resizing.allowReverse,\n        rotatable: rotating.enabled,\n        rotateGrid: rotating.grid\n      });\n      return options;\n    }\n  }, {\n    key: \"createTransformManager\",\n    value: function createTransformManager() {\n      return new TransformManager(this.graph);\n    }\n  }, {\n    key: \"createHighlightManager\",\n    value: function createHighlightManager() {\n      return new HighlightManager(this.graph);\n    }\n  }, {\n    key: \"createBackgroundManager\",\n    value: function createBackgroundManager() {\n      return new BackgroundManager(this.graph);\n    }\n  }, {\n    key: \"createClipboard\",\n    value: function createClipboard() {\n      return new Clipboard();\n    }\n  }, {\n    key: \"createClipboardManager\",\n    value: function createClipboardManager() {\n      return new ClipboardManager(this.graph);\n    }\n  }, {\n    key: \"createSnapline\",\n    value: function createSnapline() {\n      return new Snapline(Object.assign({\n        graph: this.graph\n      }, this.options.snapline));\n    }\n  }, {\n    key: \"createSnaplineManager\",\n    value: function createSnaplineManager() {\n      return new SnaplineManager(this.graph);\n    }\n  }, {\n    key: \"createSelection\",\n    value: function createSelection() {\n      return new Selection(Object.assign({\n        graph: this.graph\n      }, this.options.selecting));\n    }\n  }, {\n    key: \"createSelectionManager\",\n    value: function createSelectionManager() {\n      return new SelectionManager(this.graph);\n    } // eslint-disable-next-line\n\n  }, {\n    key: \"allowRubberband\",\n    value: function allowRubberband(e) {\n      return true;\n    }\n  }, {\n    key: \"createHistoryManager\",\n    value: function createHistoryManager() {\n      return new HistoryManager(Object.assign({\n        graph: this.graph\n      }, this.options.history));\n    }\n  }, {\n    key: \"createScroller\",\n    value: function createScroller() {\n      if (this.options.scroller.enabled) {\n        return new Scroller(Object.assign({\n          graph: this.graph\n        }, this.options.scroller));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createScrollerManager\",\n    value: function createScrollerManager() {\n      return new ScrollerManager(this.graph);\n    } // eslint-disable-next-line\n\n  }, {\n    key: \"allowPanning\",\n    value: function allowPanning(e) {\n      return true;\n    }\n  }, {\n    key: \"createMiniMap\",\n    value: function createMiniMap() {\n      var _a = this.options.minimap,\n          enabled = _a.enabled,\n          options = __rest(_a, [\"enabled\"]);\n\n      if (enabled) {\n        return new MiniMap(Object.assign({\n          graph: this.graph\n        }, options));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createMiniMapManager\",\n    value: function createMiniMapManager() {\n      return new MiniMapManager(this.graph);\n    }\n  }, {\n    key: \"createKeyboard\",\n    value: function createKeyboard() {\n      return new Keyboard(Object.assign({\n        graph: this.graph\n      }, this.options.keyboard));\n    }\n  }, {\n    key: \"createMouseWheel\",\n    value: function createMouseWheel() {\n      return new MouseWheel(Object.assign({\n        graph: this.graph\n      }, this.options.mousewheel));\n    }\n  }, {\n    key: \"createPrintManager\",\n    value: function createPrintManager() {\n      return new PrintManager(this.graph);\n    }\n  }, {\n    key: \"createFormatManager\",\n    value: function createFormatManager() {\n      return new FormatManager(this.graph);\n    }\n  }, {\n    key: \"createPanningManager\",\n    value: function createPanningManager() {\n      return new PanningManager(this.graph);\n    }\n  }, {\n    key: \"createSizeManager\",\n    value: function createSizeManager() {\n      return new SizeManager(this.graph);\n    }\n  }, {\n    key: \"allowConnectToBlank\",\n    value: function allowConnectToBlank(edge) {\n      var options = this.options.connecting;\n      var allowBlank = options.allowBlank != null ? options.allowBlank : options.dangling;\n\n      if (typeof allowBlank !== 'function') {\n        return !!allowBlank;\n      }\n\n      var edgeView = this.graph.findViewByCell(edge);\n      var sourceCell = edge.getSourceCell();\n      var targetCell = edge.getTargetCell();\n      var sourceView = this.graph.findViewByCell(sourceCell);\n      var targetView = this.graph.findViewByCell(targetCell);\n      return FunctionExt.call(allowBlank, this.graph, {\n        edge: edge,\n        edgeView: edgeView,\n        sourceCell: sourceCell,\n        targetCell: targetCell,\n        sourceView: sourceView,\n        targetView: targetView,\n        sourcePort: edge.getSourcePortId(),\n        targetPort: edge.getTargetPortId(),\n        sourceMagnet: edgeView.sourceMagnet,\n        targetMagnet: edgeView.targetMagnet\n      });\n    }\n  }, {\n    key: \"validateEdge\",\n    value: function validateEdge(edge, type, initialTerminal) {\n      if (!this.allowConnectToBlank(edge)) {\n        var sourceId = edge.getSourceCellId();\n        var targetId = edge.getTargetCellId();\n\n        if (!(sourceId && targetId)) {\n          return false;\n        }\n      }\n\n      var validate = this.options.connecting.validateEdge;\n\n      if (validate) {\n        return FunctionExt.call(validate, this.graph, {\n          edge: edge,\n          type: type,\n          previous: initialTerminal\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"validateMagnet\",\n    value: function validateMagnet(cellView, magnet, e) {\n      if (magnet.getAttribute('magnet') !== 'passive') {\n        var validate = this.options.connecting.validateMagnet;\n\n        if (validate) {\n          return FunctionExt.call(validate, this.graph, {\n            e: e,\n            magnet: magnet,\n            view: cellView,\n            cell: cellView.cell\n          });\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getDefaultEdge\",\n    value: function getDefaultEdge(sourceView, sourceMagnet) {\n      var edge;\n      var create = this.options.connecting.createEdge;\n\n      if (create) {\n        edge = FunctionExt.call(create, this.graph, {\n          sourceMagnet: sourceMagnet,\n          sourceView: sourceView,\n          sourceCell: sourceView.cell\n        });\n      }\n\n      if (edge == null) {\n        edge = new StandardEdge();\n      }\n\n      return edge;\n    }\n  }, {\n    key: \"validateConnection\",\n    value: function validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {\n      var _this2 = this;\n\n      var options = this.options.connecting;\n      var allowLoop = options.allowLoop;\n      var allowNode = options.allowNode;\n      var allowEdge = options.allowEdge;\n      var allowPort = options.allowPort;\n      var allowMulti = options.allowMulti != null ? options.allowMulti : options.multi;\n      var validate = options.validateConnection;\n      var edge = edgeView ? edgeView.cell : null;\n      var terminalView = terminalType === 'target' ? targetView : sourceView;\n      var terminalMagnet = terminalType === 'target' ? targetMagnet : sourceMagnet;\n      var valid = true;\n\n      var doValidate = function doValidate(validate) {\n        var sourcePort = terminalType === 'source' ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getSourcePortId() : null;\n        var targetPort = terminalType === 'target' ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getTargetPortId() : null;\n        return FunctionExt.call(validate, _this2.graph, {\n          edge: edge,\n          edgeView: edgeView,\n          sourceView: sourceView,\n          targetView: targetView,\n          sourcePort: sourcePort,\n          targetPort: targetPort,\n          sourceMagnet: sourceMagnet,\n          targetMagnet: targetMagnet,\n          sourceCell: sourceView ? sourceView.cell : null,\n          targetCell: targetView ? targetView.cell : null,\n          type: terminalType\n        });\n      };\n\n      if (allowLoop != null) {\n        if (typeof allowLoop === 'boolean') {\n          if (!allowLoop && sourceView === targetView) {\n            valid = false;\n          }\n        } else {\n          valid = doValidate(allowLoop);\n        }\n      }\n\n      if (valid && allowPort != null) {\n        if (typeof allowPort === 'boolean') {\n          if (!allowPort && terminalMagnet) {\n            valid = false;\n          }\n        } else {\n          valid = doValidate(allowPort);\n        }\n      }\n\n      if (valid && allowEdge != null) {\n        if (typeof allowEdge === 'boolean') {\n          if (!allowEdge && EdgeView.isEdgeView(terminalView)) {\n            valid = false;\n          }\n        } else {\n          valid = doValidate(allowEdge);\n        }\n      }\n\n      if (valid && allowNode != null) {\n        if (typeof allowNode === 'boolean') {\n          if (!allowNode && terminalView != null) {\n            if (NodeView.isNodeView(terminalView) && terminalMagnet == null) {\n              valid = false;\n            }\n          }\n        } else {\n          valid = doValidate(allowNode);\n        }\n      }\n\n      if (valid && allowMulti != null && edgeView) {\n        var _edge = edgeView.cell;\n        var source = terminalType === 'source' ? candidateTerminal : _edge.getSource();\n        var target = terminalType === 'target' ? candidateTerminal : _edge.getTarget();\n        var terminalCell = candidateTerminal ? this.graph.getCellById(candidateTerminal.cell) : null;\n\n        if (source && target && source.cell && target.cell && terminalCell) {\n          if (typeof allowMulti === 'function') {\n            valid = doValidate(allowMulti);\n          } else {\n            var connectedEdges = this.model.getConnectedEdges(terminalCell, {\n              outgoing: terminalType === 'source',\n              incoming: terminalType === 'target'\n            });\n\n            if (connectedEdges.length) {\n              if (allowMulti === 'withPort') {\n                var exist = connectedEdges.some(function (link) {\n                  var s = link.getSource();\n                  var t = link.getTarget();\n                  return s && t && s.cell === source.cell && t.cell === target.cell && s.port != null && s.port === source.port && t.port != null && t.port === target.port;\n                });\n\n                if (exist) {\n                  valid = false;\n                }\n              } else if (!allowMulti) {\n                var _exist = connectedEdges.some(function (link) {\n                  var s = link.getSource();\n                  var t = link.getTarget();\n                  return s && t && s.cell === source.cell && t.cell === target.cell;\n                });\n\n                if (_exist) {\n                  valid = false;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (valid && validate != null) {\n        valid = doValidate(validate);\n      }\n\n      return valid;\n    }\n  }, {\n    key: \"getRestrictArea\",\n    value: function getRestrictArea(view) {\n      var restrict = this.options.translating.restrict;\n      var area = typeof restrict === 'function' ? FunctionExt.call(restrict, this.graph, view) : restrict;\n\n      if (typeof area === 'number') {\n        return this.graph.transform.getGraphArea().inflate(area);\n      }\n\n      if (area === true) {\n        return this.graph.transform.getGraphArea();\n      }\n\n      return area || null;\n    }\n  }, {\n    key: \"onViewUpdated\",\n    value: function onViewUpdated(view, flag, options) {\n      if (flag & Renderer.FLAG_INSERT || options.mounting) {\n        return;\n      }\n\n      this.graph.renderer.requestConnectedEdgesUpdate(view, options);\n    }\n  }, {\n    key: \"onViewPostponed\",\n    value: function onViewPostponed(view, flag, options) {\n      return this.graph.renderer.forcePostponedViewUpdate(view, flag);\n    }\n  }, {\n    key: \"getCellView\",\n    value: function getCellView(cell) {\n      return null;\n    }\n  }, {\n    key: \"createCellView\",\n    value: function createCellView(cell) {\n      var options = {\n        graph: this.graph\n      };\n      var ctor = this.getCellView(cell);\n\n      if (ctor) {\n        return new ctor(cell, options); // eslint-disable-line new-cap\n      }\n\n      var view = cell.view;\n\n      if (view != null && typeof view === 'string') {\n        var def = CellView.registry.get(view);\n\n        if (def) {\n          return new def(cell, options); // eslint-disable-line new-cap\n        }\n\n        return CellView.registry.onNotFound(view);\n      }\n\n      if (cell.isNode()) {\n        return new NodeView(cell, options);\n      }\n\n      if (cell.isEdge()) {\n        return new EdgeView(cell, options);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getHTMLComponent\",\n    value: function getHTMLComponent(node) {\n      var ret = node.getHTML();\n\n      if (typeof ret === 'string') {\n        ret = HTML.componentRegistry.get(ret) || ret;\n      }\n\n      if (ObjectExt.isPlainObject(ret)) {\n        ret = ret.render;\n      }\n\n      if (typeof ret === 'function') {\n        return FunctionExt.call(ret, this.graph, node);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"shouldUpdateHTMLComponent\",\n    value: function shouldUpdateHTMLComponent(node) {\n      var html = node.getHTML();\n\n      if (typeof html === 'string') {\n        html = HTML.componentRegistry.get(html) || html;\n      }\n\n      if (ObjectExt.isPlainObject(html)) {\n        var shouldUpdate = html.shouldComponentUpdate;\n\n        if (typeof shouldUpdate === 'function') {\n          return FunctionExt.call(shouldUpdate, this.graph, node);\n        }\n\n        return !!shouldUpdate;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onEdgeLabelRendered\",\n    value: function onEdgeLabelRendered(args) {} // eslint-disable-line\n\n  }, {\n    key: \"onPortRendered\",\n    value: function onPortRendered(args) {} // eslint-disable-line\n\n  }, {\n    key: \"onToolItemCreated\",\n    value: function onToolItemCreated(args) {} // eslint-disable-line\n\n  }]);\n\n  return Hook;\n}(Base);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createModel\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createView\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createRenderer\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createDefsManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createGridManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createCoordManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createKnobManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createTransform\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createKnob\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createTransformManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createHighlightManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createBackgroundManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createClipboard\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createClipboardManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSnapline\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSnaplineManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSelection\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSelectionManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"allowRubberband\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createHistoryManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createScroller\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createScrollerManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"allowPanning\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createMiniMap\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createMiniMapManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createKeyboard\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createMouseWheel\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createPrintManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createFormatManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createPanningManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSizeManager\", null);\n\n__decorate([Decorator.after()], Hook.prototype, \"onViewUpdated\", null);\n\n__decorate([Decorator.after()], Hook.prototype, \"onViewPostponed\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"getCellView\", null);\n\n__decorate([Decorator.hook(true)], Hook.prototype, \"createCellView\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"getHTMLComponent\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"shouldUpdateHTMLComponent\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"onEdgeLabelRendered\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"onPortRendered\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"onToolItemCreated\", null);","map":null,"metadata":{},"sourceType":"module"}