{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { isNumber } from '../../../util';\nimport graphlib from './graphlib';\nvar Graph = graphlib.Graph;\n/*\n * Adds a dummy node to the graph and return v.\n */\n\nvar addDummyNode = function addDummyNode(g, type, attrs, name) {\n  var v;\n\n  do {\n    v = \"\".concat(name).concat(Math.random());\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n};\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\n\n\nvar simplify = function simplify(g) {\n  var simplified = new Graph().setGraph(g.graph());\n  g.nodes().forEach(function (v) {\n    simplified.setNode(v, g.node(v));\n  });\n  g.edges().forEach(function (e) {\n    var simpleLabel = simplified.edge(e.v, e.w) || {\n      weight: 0,\n      minlen: 1\n    };\n    var label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n};\n\nvar asNonCompoundGraph = function asNonCompoundGraph(g) {\n  var simplified = new Graph({\n    multigraph: g.isMultigraph()\n  }).setGraph(g.graph());\n  g.nodes().forEach(function (v) {\n    var _a;\n\n    if (!((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length)) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  g.edges().forEach(function (e) {\n    return simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n};\n\nvar zipObject = function zipObject(keys, values) {\n  var result = {};\n  keys === null || keys === void 0 ? void 0 : keys.forEach(function (key, i) {\n    result[key] = values[i];\n  });\n  return result;\n};\n\nvar successorWeights = function successorWeights(g) {\n  var weightMap = g.nodes().map(function (v) {\n    var _a;\n\n    var sucs = {};\n    (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return zipObject(g.nodes(), weightMap);\n};\n\nvar predecessorWeights = function predecessorWeights(g) {\n  var weightMap = g.nodes().map(function (v) {\n    var _a;\n\n    var preds = {};\n    (_a = g.inEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return zipObject(g.nodes(), weightMap);\n};\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\n\n\nvar intersectRect = function intersectRect(rect, point) {\n  var x = rect.x;\n  var y = rect.y; // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = rect.width / 2;\n  var h = rect.height / 2;\n\n  if (!dx && !dy) {\n    // throw new Error(\"Not possible to find intersection inside of the rectangle\");\n    // completely overlapped\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var sx;\n  var sy;\n\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return {\n    x: x + sx,\n    y: y + sy\n  };\n};\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * const will produce a matrix with the ids of each node.\n */\n\n\nvar buildLayerMatrix = function buildLayerMatrix(g) {\n  var layering = [];\n  var layeringNodes = [];\n  var rankMax = maxRank(g) + 1;\n\n  for (var i = 0; i < rankMax; i++) {\n    layering.push([]);\n    layeringNodes.push([]);\n  } // const layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n\n\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n    var rank = node.rank;\n\n    if (rank !== undefined && layering[rank]) {\n      layeringNodes[rank].push(v);\n    }\n  });\n  layeringNodes === null || layeringNodes === void 0 ? void 0 : layeringNodes.forEach(function (layer, rank) {\n    layer === null || layer === void 0 ? void 0 : layer.sort(function (va, vb) {\n      var _a, _b;\n\n      return ((_a = g.node(va)) === null || _a === void 0 ? void 0 : _a.order) - ((_b = g.node(vb)) === null || _b === void 0 ? void 0 : _b.order);\n    });\n    layer.forEach(function (v) {\n      layering[rank].push(v);\n    });\n  });\n  return layering;\n};\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\n\n\nvar normalizeRanks = function normalizeRanks(g) {\n  var nodeRanks = g.nodes().filter(function (v) {\n    return g.node(v).rank !== undefined;\n  }).map(function (v) {\n    return g.node(v).rank;\n  });\n  var min = Math.min.apply(Math, _toConsumableArray(nodeRanks));\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n\n    if (node.hasOwnProperty(\"rank\")) {\n      if (!node.rank) node.rank = 0;\n      node.rank -= min;\n    }\n  });\n};\n\nvar removeEmptyRanks = function removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var nodeRanks = g.nodes().filter(function (v) {\n    return g.node(v).rank !== undefined;\n  }).map(function (v) {\n    return g.node(v).rank;\n  });\n  var offset = Math.min.apply(Math, _toConsumableArray(nodeRanks));\n  var layers = [];\n  g.nodes().forEach(function (v) {\n    var _a;\n\n    var rank = (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) || 0) - offset;\n\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n\n    layers[rank].push(v);\n  });\n  var delta = 0;\n  var nodeRankFactor = g.graph().nodeRankFactor || 0;\n\n  for (var i = 0; i < layers.length; i++) {\n    var vs = layers[i];\n\n    if (vs === undefined && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n        if (!g.node(v).rank) g.node(v).rank = 0;\n        g.node(v).rank += delta;\n      });\n    }\n  }\n};\n\nvar addBorderNode = function addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0\n  };\n\n  if (isNumber(rank) && isNumber(order)) {\n    node.rank = rank;\n    node.order = order;\n  }\n\n  return addDummyNode(g, \"border\", node, prefix);\n};\n\nvar maxRank = function maxRank(g) {\n  var nodeRanks = g.nodes().map(function (v) {\n    var rank = g.node(v).rank;\n\n    if (rank !== undefined) {\n      return rank;\n    }\n\n    return -Infinity;\n  });\n  return Math.max.apply(Math, _toConsumableArray(nodeRanks));\n};\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * const returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\n\n\nvar partition = function partition(collection, fn) {\n  var result = {\n    lhs: [],\n    rhs: []\n  };\n  collection === null || collection === void 0 ? void 0 : collection.forEach(function (value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n};\n/*\n * Returns a new const that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\n\n\nvar time = function time(name, fn) {\n  var start = Date.now();\n\n  try {\n    return fn();\n  } finally {\n    console.log(\"\".concat(name, \" time: \").concat(Date.now() - start, \"ms\"));\n  }\n};\n\nvar notime = function notime(name, fn) {\n  return fn();\n};\n\nvar minBy = function minBy(array, func) {\n  var min = Infinity;\n  var minObject;\n  array === null || array === void 0 ? void 0 : array.forEach(function (item) {\n    var value = func(item);\n\n    if (min > value) {\n      min = value;\n      minObject = item;\n    }\n  });\n  return minObject;\n};\n\nexport { addDummyNode, simplify, asNonCompoundGraph, successorWeights, predecessorWeights, intersectRect, buildLayerMatrix, normalizeRanks, removeEmptyRanks, addBorderNode, maxRank, partition, time, notime, zipObject, minBy };\nexport default {\n  addDummyNode: addDummyNode,\n  simplify: simplify,\n  asNonCompoundGraph: asNonCompoundGraph,\n  successorWeights: successorWeights,\n  predecessorWeights: predecessorWeights,\n  intersectRect: intersectRect,\n  buildLayerMatrix: buildLayerMatrix,\n  normalizeRanks: normalizeRanks,\n  removeEmptyRanks: removeEmptyRanks,\n  addBorderNode: addBorderNode,\n  maxRank: maxRank,\n  partition: partition,\n  time: time,\n  notime: notime,\n  zipObject: zipObject,\n  minBy: minBy\n};","map":null,"metadata":{},"sourceType":"module"}