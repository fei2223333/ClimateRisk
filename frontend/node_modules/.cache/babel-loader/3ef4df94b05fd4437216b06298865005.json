{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Curve, Path } from '../../geometry';\nexport var smooth = function smooth(sourcePoint, targetPoint, routePoints) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var path;\n  var direction = options.direction;\n\n  if (routePoints && routePoints.length !== 0) {\n    var points = [sourcePoint].concat(_toConsumableArray(routePoints), [targetPoint]);\n    var curves = Curve.throughPoints(points);\n    path = new Path(curves);\n  } else {\n    // If we have no route, use a default cubic bezier curve, cubic bezier\n    // requires two control points, the control points have `x` midway\n    // between source and target. This produces an S-like curve.\n    path = new Path();\n    path.appendSegment(Path.createSegment('M', sourcePoint));\n\n    if (!direction) {\n      direction = Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y) ? 'H' : 'V';\n    }\n\n    if (direction === 'H') {\n      var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n      path.appendSegment(Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));\n    } else {\n      var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n      path.appendSegment(Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));\n    }\n  }\n\n  return options.raw ? path : path.serialize();\n};","map":null,"metadata":{},"sourceType":"module"}