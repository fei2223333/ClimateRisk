{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Registry } from '../registry';\nimport { Point, Rectangle, Angle } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt } from '../util';\nimport { Markup } from '../view/markup';\nimport { Cell } from './cell';\nimport { ShareRegistry } from './registry';\nimport { PortManager } from './port';\nimport { Interp } from '../common';\nexport var Node = /*#__PURE__*/function (_Cell) {\n  _inherits(Node, _Cell);\n\n  function Node() {\n    var _this;\n\n    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Node);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this, metadata));\n\n    _this.initPorts();\n\n    return _this;\n  }\n\n  _createClass(Node, [{\n    key: \"preprocess\",\n    value: function preprocess(metadata, ignoreIdCheck) {\n      var x = metadata.x,\n          y = metadata.y,\n          width = metadata.width,\n          height = metadata.height,\n          others = __rest(metadata, [\"x\", \"y\", \"width\", \"height\"]);\n\n      if (x != null || y != null) {\n        var position = others.position;\n        others.position = Object.assign(Object.assign({}, position), {\n          x: x != null ? x : position ? position.x : 0,\n          y: y != null ? y : position ? position.y : 0\n        });\n      }\n\n      if (width != null || height != null) {\n        var size = others.size;\n        others.size = Object.assign(Object.assign({}, size), {\n          width: width != null ? width : size ? size.width : 0,\n          height: height != null ? height : size ? size.height : 0\n        });\n      }\n\n      return _get(_getPrototypeOf(Node.prototype), \"preprocess\", this).call(this, others, ignoreIdCheck);\n    }\n  }, {\n    key: \"isNode\",\n    value: function isNode() {\n      return true;\n    }\n  }, {\n    key: \"size\",\n    value: function size(width, height, options) {\n      if (width === undefined) {\n        return this.getSize();\n      }\n\n      if (typeof width === 'number') {\n        return this.setSize(width, height, options);\n      }\n\n      return this.setSize(width, height);\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      var size = this.store.get('size');\n      return size ? Object.assign({}, size) : {\n        width: 1,\n        height: 1\n      };\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height, options) {\n      if (typeof width === 'object') {\n        this.resize(width.width, width.height, height);\n      } else {\n        this.resize(width, height, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.startBatch('resize', options);\n      var direction = options.direction;\n\n      if (direction) {\n        var currentSize = this.getSize();\n\n        switch (direction) {\n          case 'left':\n          case 'right':\n            // Don't change height when resizing horizontally.\n            height = currentSize.height; // eslint-disable-line\n\n            break;\n\n          case 'top':\n          case 'bottom':\n            // Don't change width when resizing vertically.\n            width = currentSize.width; // eslint-disable-line\n\n            break;\n\n          default:\n            break;\n        }\n\n        var map = {\n          right: 0,\n          'top-right': 0,\n          top: 1,\n          'top-left': 1,\n          left: 2,\n          'bottom-left': 2,\n          bottom: 3,\n          'bottom-right': 3\n        };\n        var quadrant = map[direction];\n        var angle = Angle.normalize(this.getAngle() || 0);\n\n        if (options.absolute) {\n          // We are taking the node's rotation into account\n          quadrant += Math.floor((angle + 45) / 90);\n          quadrant %= 4;\n        } // This is a rectangle in size of the un-rotated node.\n\n\n        var bbox = this.getBBox(); // Pick the corner point on the node, which meant to stay on its\n        // place before and after the rotation.\n\n        var fixedPoint;\n\n        if (quadrant === 0) {\n          fixedPoint = bbox.getBottomLeft();\n        } else if (quadrant === 1) {\n          fixedPoint = bbox.getCorner();\n        } else if (quadrant === 2) {\n          fixedPoint = bbox.getTopRight();\n        } else {\n          fixedPoint = bbox.getOrigin();\n        } // Find an image of the previous indent point. This is the position,\n        // where is the point actually located on the screen.\n\n\n        var imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox.getCenter()); // Every point on the element rotates around a circle with the centre of\n        // rotation in the middle of the element while the whole element is being\n        // rotated. That means that the distance from a point in the corner of\n        // the element (supposed its always rect) to the center of the element\n        // doesn't change during the rotation and therefore it equals to a\n        // distance on un-rotated element.\n        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\n        var radius = Math.sqrt(width * width + height * height) / 2; // Now we are looking for an angle between x-axis and the line starting\n        // at image of fixed point and ending at the center of the element.\n        // We call this angle `alpha`.\n        // The image of a fixed point is located in n-th quadrant. For each\n        // quadrant passed going anti-clockwise we have to add 90 degrees.\n        // Note that the first quadrant has index 0.\n        //\n        // 3 | 2\n        // --c-- Quadrant positions around the element's center `c`\n        // 0 | 1\n        //\n\n        var alpha = quadrant * Math.PI / 2; // Add an angle between the beginning of the current quadrant (line\n        // parallel with x-axis or y-axis going through the center of the\n        // element) and line crossing the indent of the fixed point and the\n        // center of the element. This is the angle we need but on the\n        // un-rotated element.\n\n        alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height); // Lastly we have to deduct the original angle the element was rotated\n        // by and that's it.\n\n        alpha -= Angle.toRad(angle); // With this angle and distance we can easily calculate the centre of\n        // the un-rotated element.\n        // Note that fromPolar constructor accepts an angle in radians.\n\n        var center = Point.fromPolar(radius, alpha, imageFixedPoint); // The top left corner on the un-rotated element has to be half a width\n        // on the left and half a height to the top from the center. This will\n        // be the origin of rectangle we were looking for.\n\n        var origin = center.clone().translate(width / -2, height / -2);\n        this.store.set('size', {\n          width: width,\n          height: height\n        }, options);\n        this.setPosition(origin.x, origin.y, options);\n      } else {\n        this.store.set('size', {\n          width: width,\n          height: height\n        }, options);\n      }\n\n      this.stopBatch('resize', options);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);\n      this.startBatch('scale', options);\n      this.setPosition(scaledBBox.x, scaledBBox.y, options);\n      this.resize(scaledBBox.width, scaledBBox.height, options);\n      this.stopBatch('scale');\n      return this;\n    }\n  }, {\n    key: \"position\",\n    value: function position(arg0, arg1, arg2) {\n      if (typeof arg0 === 'number') {\n        return this.setPosition(arg0, arg1, arg2);\n      }\n\n      return this.getPosition(arg0);\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.relative) {\n        var parent = this.getParent();\n\n        if (parent != null && parent.isNode()) {\n          var currentPosition = this.getPosition();\n          var parentPosition = parent.getPosition();\n          return {\n            x: currentPosition.x - parentPosition.x,\n            y: currentPosition.y - parentPosition.y\n          };\n        }\n      }\n\n      var pos = this.store.get('position');\n      return pos ? Object.assign({}, pos) : {\n        x: 0,\n        y: 0\n      };\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(arg0, arg1) {\n      var arg2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var x;\n      var y;\n      var options;\n\n      if (typeof arg0 === 'object') {\n        x = arg0.x;\n        y = arg0.y;\n        options = arg1 || {};\n      } else {\n        x = arg0;\n        y = arg1;\n        options = arg2 || {};\n      }\n\n      if (options.relative) {\n        var parent = this.getParent();\n\n        if (parent != null && parent.isNode()) {\n          var parentPosition = parent.getPosition();\n          x += parentPosition.x;\n          y += parentPosition.y;\n        }\n      }\n\n      if (options.deep) {\n        var currentPosition = this.getPosition();\n        this.translate(x - currentPosition.x, y - currentPosition.y, options);\n      } else {\n        this.store.set('position', {\n          x: x,\n          y: y\n        }, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate() {\n      var tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (tx === 0 && ty === 0) {\n        return this;\n      } // Pass the initiator of the translation.\n\n\n      options.translateBy = options.translateBy || this.id;\n      var position = this.getPosition();\n\n      if (options.restrict != null && options.translateBy === this.id) {\n        // We are restricting the translation for the element itself only. We get\n        // the bounding box of the element including all its embeds.\n        // All embeds have to be translated the exact same way as the element.\n        var bbox = this.getBBox({\n          deep: true\n        });\n        var ra = options.restrict; // - - - - - - - - - - - - -> ra.x + ra.width\n        // - - - -> position.x      |\n        // -> bbox.x\n        //                ▓▓▓▓▓▓▓   |\n        //         ░░░░░░░▓▓▓▓▓▓▓\n        //         ░░░░░░░░░        |\n        //   ▓▓▓▓▓▓▓▓░░░░░░░\n        //   ▓▓▓▓▓▓▓▓               |\n        //   <-dx->                     | restricted area right border\n        //         <-width->        |   ░ translated element\n        //   <- - bbox.width - ->       ▓ embedded element\n\n        var dx = position.x - bbox.x;\n        var dy = position.y - bbox.y; // Find the maximal/minimal coordinates that the element can be translated\n        // while complies the restrictions.\n\n        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty)); // recalculate the translation taking the restrictions into account.\n\n        tx = x - position.x; // eslint-disable-line\n\n        ty = y - position.y; // eslint-disable-line\n      }\n\n      var translatedPosition = {\n        x: position.x + tx,\n        y: position.y + ty\n      }; // To find out by how much an element was translated in event\n      // 'change:position' handlers.\n\n      options.tx = tx;\n      options.ty = ty;\n\n      if (options.transition) {\n        if (typeof options.transition !== 'object') {\n          options.transition = {};\n        }\n\n        this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), {\n          interp: Interp.object\n        }));\n        this.eachChild(function (child) {\n          var _a;\n\n          var excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n\n          if (!excluded) {\n            child.translate(tx, ty, options);\n          }\n        });\n      } else {\n        this.startBatch('translate', options);\n        this.store.set('position', translatedPosition, options);\n        this.eachChild(function (child) {\n          var _a;\n\n          var excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n\n          if (!excluded) {\n            child.translate(tx, ty, options);\n          }\n        });\n        this.stopBatch('translate', options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"angle\",\n    value: function angle(val, options) {\n      if (val == null) {\n        return this.getAngle();\n      }\n\n      return this.rotate(val, options);\n    }\n  }, {\n    key: \"getAngle\",\n    value: function getAngle() {\n      return this.store.get('angle', 0);\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var currentAngle = this.getAngle();\n\n      if (options.center) {\n        var size = this.getSize();\n        var position = this.getPosition();\n        var center = this.getBBox().getCenter();\n        center.rotate(currentAngle - angle, options.center);\n        var dx = center.x - size.width / 2 - position.x;\n        var dy = center.y - size.height / 2 - position.y;\n        this.startBatch('rotate', {\n          angle: angle,\n          options: options\n        });\n        this.setPosition(position.x + dx, position.y + dy, options);\n        this.rotate(angle, Object.assign(Object.assign({}, options), {\n          center: null\n        }));\n        this.stopBatch('rotate');\n      } else {\n        this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);\n      }\n\n      return this;\n    } // #endregion\n    // #region common\n\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.deep) {\n        var cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.push(this);\n        return Cell.getCellsBBox(cells);\n      }\n\n      return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());\n    }\n  }, {\n    key: \"getConnectionPoint\",\n    value: function getConnectionPoint(edge, type) {\n      var bbox = this.getBBox();\n      var center = bbox.getCenter();\n      var terminal = edge.getTerminal(type);\n\n      if (terminal == null) {\n        return center;\n      }\n\n      var portId = terminal.port;\n\n      if (!portId || !this.hasPort(portId)) {\n        return center;\n      }\n\n      var port = this.getPort(portId);\n\n      if (!port || !port.group) {\n        return center;\n      }\n\n      var layouts = this.getPortsPosition(port.group);\n      var position = layouts[portId].position;\n      var portCenter = Point.create(position).translate(bbox.getOrigin());\n      var angle = this.getAngle();\n\n      if (angle) {\n        portCenter.rotate(-angle, center);\n      }\n\n      return portCenter;\n    }\n    /**\n     * Sets cell's size and position based on the children bbox and given padding.\n     */\n\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var children = this.getChildren() || [];\n      var embeds = children.filter(function (cell) {\n        return cell.isNode();\n      });\n\n      if (embeds.length === 0) {\n        return this;\n      }\n\n      this.startBatch('fit-embeds', options);\n\n      if (options.deep) {\n        embeds.forEach(function (cell) {\n          return cell.fit(options);\n        });\n      }\n\n      var _Cell$getCellsBBox = Cell.getCellsBBox(embeds),\n          x = _Cell$getCellsBBox.x,\n          y = _Cell$getCellsBBox.y,\n          width = _Cell$getCellsBBox.width,\n          height = _Cell$getCellsBBox.height;\n\n      var padding = NumberExt.normalizeSides(options.padding);\n      x -= padding.left;\n      y -= padding.top;\n      width += padding.left + padding.right;\n      height += padding.bottom + padding.top;\n      this.store.set({\n        position: {\n          x: x,\n          y: y\n        },\n        size: {\n          width: width,\n          height: height\n        }\n      }, options);\n      this.stopBatch('fit-embeds');\n      return this;\n    } // #endregion\n    // #region ports\n\n  }, {\n    key: \"getDefaultPortContainerMarkup\",\n    value: function getDefaultPortContainerMarkup() {\n      return this.store.get('defaultPortContainerMarkup') || Markup.getPortContainerMarkup();\n    }\n  }, {\n    key: \"getPortContainerMarkup\",\n    value: function getPortContainerMarkup() {\n      return this.store.get('portContainerMarkup') || this.getDefaultPortContainerMarkup();\n    }\n  }, {\n    key: \"setPortContainerMarkup\",\n    value: function setPortContainerMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('portContainerMarkup', Markup.clone(markup), options);\n      return this;\n    }\n  }, {\n    key: \"getDefaultPortMarkup\",\n    value: function getDefaultPortMarkup() {\n      return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();\n    }\n  }, {\n    key: \"getPortMarkup\",\n    value: function getPortMarkup() {\n      return this.store.get('portMarkup') || this.getDefaultPortMarkup();\n    }\n  }, {\n    key: \"setPortMarkup\",\n    value: function setPortMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('portMarkup', Markup.clone(markup), options);\n      return this;\n    }\n  }, {\n    key: \"getDefaultPortLabelMarkup\",\n    value: function getDefaultPortLabelMarkup() {\n      return this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup();\n    }\n  }, {\n    key: \"getPortLabelMarkup\",\n    value: function getPortLabelMarkup() {\n      return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();\n    }\n  }, {\n    key: \"setPortLabelMarkup\",\n    value: function setPortLabelMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('portLabelMarkup', Markup.clone(markup), options);\n      return this;\n    }\n  }, {\n    key: \"getPorts\",\n    value: function getPorts() {\n      return ObjectExt.cloneDeep(this.ports.items);\n    }\n  }, {\n    key: \"getPortsByGroup\",\n    value: function getPortsByGroup(groupName) {\n      return this.getPorts().filter(function (port) {\n        return port.group === groupName;\n      });\n    }\n  }, {\n    key: \"getPort\",\n    value: function getPort(portId) {\n      return ObjectExt.cloneDeep(this.ports.items.find(function (port) {\n        return port.id && port.id === portId;\n      }));\n    }\n  }, {\n    key: \"getPortAt\",\n    value: function getPortAt(index) {\n      return this.ports.items[index] || null;\n    }\n  }, {\n    key: \"hasPorts\",\n    value: function hasPorts() {\n      return this.ports.items.length > 0;\n    }\n  }, {\n    key: \"hasPort\",\n    value: function hasPort(portId) {\n      return this.getPortIndex(portId) !== -1;\n    }\n  }, {\n    key: \"getPortIndex\",\n    value: function getPortIndex(port) {\n      var portId = typeof port === 'string' ? port : port.id;\n      return portId != null ? this.ports.items.findIndex(function (item) {\n        return item.id === portId;\n      }) : -1;\n    }\n  }, {\n    key: \"getPortsPosition\",\n    value: function getPortsPosition(groupName) {\n      var size = this.getSize();\n      var layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));\n      return layouts.reduce(function (memo, item) {\n        var layout = item.portLayout;\n        memo[item.portId] = {\n          position: Object.assign({}, layout.position),\n          angle: layout.angle || 0\n        };\n        return memo;\n      }, {});\n    }\n  }, {\n    key: \"getPortProp\",\n    value: function getPortProp(portId, path) {\n      return this.getPropByPath(this.prefixPortPath(portId, path));\n    }\n  }, {\n    key: \"setPortProp\",\n    value: function setPortProp(portId, arg1, arg2, arg3) {\n      if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n        var _path = this.prefixPortPath(portId, arg1);\n\n        var _value = arg2;\n        return this.setPropByPath(_path, _value, arg3);\n      }\n\n      var path = this.prefixPortPath(portId);\n      var value = arg1;\n      return this.setPropByPath(path, value, arg2);\n    }\n  }, {\n    key: \"removePortProp\",\n    value: function removePortProp(portId, path, options) {\n      if (typeof path === 'string' || Array.isArray(path)) {\n        return this.removePropByPath(this.prefixPortPath(portId, path), options);\n      }\n\n      return this.removePropByPath(this.prefixPortPath(portId), path);\n    }\n  }, {\n    key: \"portProp\",\n    value: function portProp(portId, path, value, options) {\n      if (path == null) {\n        return this.getPortProp(portId);\n      }\n\n      if (typeof path === 'string' || Array.isArray(path)) {\n        if (arguments.length === 2) {\n          return this.getPortProp(portId, path);\n        }\n\n        if (value == null) {\n          return this.removePortProp(portId, path, options);\n        }\n\n        return this.setPortProp(portId, path, value, options);\n      }\n\n      return this.setPortProp(portId, path, value);\n    }\n  }, {\n    key: \"prefixPortPath\",\n    value: function prefixPortPath(portId, path) {\n      var index = this.getPortIndex(portId);\n\n      if (index === -1) {\n        throw new Error(\"Unable to find port with id: \\\"\".concat(portId, \"\\\"\"));\n      }\n\n      if (path == null || path === '') {\n        return ['ports', 'items', \"\".concat(index)];\n      }\n\n      if (Array.isArray(path)) {\n        return ['ports', 'items', \"\".concat(index)].concat(_toConsumableArray(path));\n      }\n\n      return \"ports/items/\".concat(index, \"/\").concat(path);\n    }\n  }, {\n    key: \"addPort\",\n    value: function addPort(port, options) {\n      var ports = _toConsumableArray(this.ports.items);\n\n      ports.push(port);\n      this.setPropByPath('ports/items', ports, options);\n      return this;\n    }\n  }, {\n    key: \"addPorts\",\n    value: function addPorts(ports, options) {\n      this.setPropByPath('ports/items', [].concat(_toConsumableArray(this.ports.items), _toConsumableArray(ports)), options);\n      return this;\n    }\n  }, {\n    key: \"insertPort\",\n    value: function insertPort(index, port, options) {\n      var ports = _toConsumableArray(this.ports.items);\n\n      ports.splice(index, 0, port);\n      this.setPropByPath('ports/items', ports, options);\n      return this;\n    }\n  }, {\n    key: \"removePort\",\n    value: function removePort(port) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.removePortAt(this.getPortIndex(port), options);\n    }\n  }, {\n    key: \"removePortAt\",\n    value: function removePortAt(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (index >= 0) {\n        var ports = _toConsumableArray(this.ports.items);\n\n        ports.splice(index, 1);\n        options.rewrite = true;\n        this.setPropByPath('ports/items', ports, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removePorts\",\n    value: function removePorts(portsForRemoval, opt) {\n      var options;\n\n      if (Array.isArray(portsForRemoval)) {\n        options = opt || {};\n\n        if (portsForRemoval.length) {\n          options.rewrite = true;\n\n          var currentPorts = _toConsumableArray(this.ports.items);\n\n          var remainingPorts = currentPorts.filter(function (cp) {\n            return !portsForRemoval.some(function (p) {\n              var id = typeof p === 'string' ? p : p.id;\n              return cp.id === id;\n            });\n          });\n          this.setPropByPath('ports/items', remainingPorts, options);\n        }\n      } else {\n        options = portsForRemoval || {};\n        options.rewrite = true;\n        this.setPropByPath('ports/items', [], options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getParsedPorts\",\n    value: function getParsedPorts() {\n      return this.port.getPorts();\n    }\n  }, {\n    key: \"getParsedGroups\",\n    value: function getParsedGroups() {\n      return this.port.groups;\n    }\n  }, {\n    key: \"getPortsLayoutByGroup\",\n    value: function getPortsLayoutByGroup(groupName, bbox) {\n      return this.port.getPortsLayoutByGroup(groupName, bbox);\n    }\n  }, {\n    key: \"initPorts\",\n    value: function initPorts() {\n      var _this2 = this;\n\n      this.updatePortData();\n      this.on('change:ports', function () {\n        _this2.processRemovedPort();\n\n        _this2.updatePortData();\n      });\n    }\n  }, {\n    key: \"processRemovedPort\",\n    value: function processRemovedPort() {\n      var current = this.ports;\n      var currentItemsMap = {};\n      current.items.forEach(function (item) {\n        if (item.id) {\n          currentItemsMap[item.id] = true;\n        }\n      });\n      var removed = {};\n      var previous = this.store.getPrevious('ports') || {\n        items: []\n      };\n      previous.items.forEach(function (item) {\n        if (item.id && !currentItemsMap[item.id]) {\n          removed[item.id] = true;\n        }\n      });\n      var model = this.model;\n\n      if (model && !ObjectExt.isEmpty(removed)) {\n        var incomings = model.getConnectedEdges(this, {\n          incoming: true\n        });\n        incomings.forEach(function (edge) {\n          var portId = edge.getTargetPortId();\n\n          if (portId && removed[portId]) {\n            edge.remove();\n          }\n        });\n        var outgoings = model.getConnectedEdges(this, {\n          outgoing: true\n        });\n        outgoings.forEach(function (edge) {\n          var portId = edge.getSourcePortId();\n\n          if (portId && removed[portId]) {\n            edge.remove();\n          }\n        });\n      }\n    }\n  }, {\n    key: \"validatePorts\",\n    value: function validatePorts() {\n      var _this3 = this;\n\n      var ids = {};\n      var errors = [];\n      this.ports.items.forEach(function (p) {\n        if (typeof p !== 'object') {\n          errors.push(\"Invalid port \".concat(p, \".\"));\n        }\n\n        if (p.id == null) {\n          p.id = _this3.generatePortId();\n        }\n\n        if (ids[p.id]) {\n          errors.push('Duplicitied port id.');\n        }\n\n        ids[p.id] = true;\n      });\n      return errors;\n    }\n  }, {\n    key: \"generatePortId\",\n    value: function generatePortId() {\n      return StringExt.uuid();\n    }\n  }, {\n    key: \"updatePortData\",\n    value: function updatePortData() {\n      var err = this.validatePorts();\n\n      if (err.length > 0) {\n        this.store.set('ports', this.store.getPrevious('ports'));\n        throw new Error(err.join(' '));\n      }\n\n      var prev = this.port ? this.port.getPorts() : null;\n      this.port = new PortManager(this.ports);\n      var curr = this.port.getPorts();\n      var added = prev ? curr.filter(function (item) {\n        if (!prev.find(function (prevPort) {\n          return prevPort.id === item.id;\n        })) {\n          return item;\n        }\n\n        return null;\n      }) : _toConsumableArray(curr);\n      var removed = prev ? prev.filter(function (item) {\n        if (!curr.find(function (curPort) {\n          return curPort.id === item.id;\n        })) {\n          return item;\n        }\n\n        return null;\n      }) : [];\n\n      if (added.length > 0) {\n        this.notify('ports:added', {\n          added: added,\n          cell: this,\n          node: this\n        });\n      }\n\n      if (removed.length > 0) {\n        this.notify('ports:removed', {\n          removed: removed,\n          cell: this,\n          node: this\n        });\n      }\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Node.toStringTag;\n    }\n  }, {\n    key: \"portContainerMarkup\",\n    get: function get() {\n      return this.getPortContainerMarkup();\n    },\n    set: function set(markup) {\n      this.setPortContainerMarkup(markup);\n    }\n  }, {\n    key: \"portMarkup\",\n    get: function get() {\n      return this.getPortMarkup();\n    },\n    set: function set(markup) {\n      this.setPortMarkup(markup);\n    }\n  }, {\n    key: \"portLabelMarkup\",\n    get: function get() {\n      return this.getPortLabelMarkup();\n    },\n    set: function set(markup) {\n      this.setPortLabelMarkup(markup);\n    }\n  }, {\n    key: \"ports\",\n    get: function get() {\n      var res = this.store.get('ports', {\n        items: []\n      });\n\n      if (res.items == null) {\n        res.items = [];\n      }\n\n      return res;\n    }\n  }]);\n\n  return Node;\n}(Cell);\nNode.defaults = {\n  angle: 0,\n  position: {\n    x: 0,\n    y: 0\n  },\n  size: {\n    width: 1,\n    height: 1\n  }\n};\n\n(function (Node) {\n  Node.toStringTag = \"X6.\".concat(Node.name);\n\n  function isNode(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Node) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var node = instance;\n\n    if ((tag == null || tag === Node.toStringTag) && typeof node.isNode === 'function' && typeof node.isEdge === 'function' && typeof node.prop === 'function' && typeof node.attr === 'function' && typeof node.size === 'function' && typeof node.position === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Node.isNode = isNode;\n})(Node || (Node = {}));\n\n(function (Node) {\n  Node.config({\n    propHooks: function propHooks(_a) {\n      var ports = _a.ports,\n          metadata = __rest(_a, [\"ports\"]);\n\n      if (ports) {\n        metadata.ports = Array.isArray(ports) ? {\n          items: ports\n        } : ports;\n      }\n\n      return metadata;\n    }\n  });\n})(Node || (Node = {}));\n\n(function (Node) {\n  Node.registry = Registry.create({\n    type: 'node',\n    process: function process(shape, options) {\n      if (ShareRegistry.exist(shape, true)) {\n        throw new Error(\"Node with name '\".concat(shape, \"' was registered by anthor Edge\"));\n      }\n\n      if (typeof options === 'function') {\n        options.config({\n          shape: shape\n        });\n        return options;\n      }\n\n      var parent = Node;\n\n      var inherit = options.inherit,\n          config = __rest(options, [\"inherit\"]);\n\n      if (inherit) {\n        if (typeof inherit === 'string') {\n          var base = this.get(inherit);\n\n          if (base == null) {\n            this.onNotFound(inherit, 'inherited');\n          } else {\n            parent = base;\n          }\n        } else {\n          parent = inherit;\n        }\n      }\n\n      if (config.constructorName == null) {\n        config.constructorName = shape;\n      }\n\n      var ctor = parent.define.call(parent, config);\n      ctor.config({\n        shape: shape\n      });\n      return ctor;\n    }\n  });\n  ShareRegistry.setNodeRegistry(Node.registry);\n})(Node || (Node = {}));\n\n(function (Node) {\n  var counter = 0;\n\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n\n    counter += 1;\n    return \"CustomNode\".concat(counter);\n  }\n\n  function define(config) {\n    var constructorName = config.constructorName,\n        overwrite = config.overwrite,\n        others = __rest(config, [\"constructorName\", \"overwrite\"]);\n\n    var ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n\n    if (others.shape) {\n      Node.registry.register(others.shape, ctor, overwrite);\n    }\n\n    return ctor;\n  }\n\n  Node.define = define;\n\n  function create(options) {\n    var shape = options.shape || 'rect';\n    var Ctor = Node.registry.get(shape);\n\n    if (Ctor) {\n      return new Ctor(options);\n    }\n\n    return Node.registry.onNotFound(shape);\n  }\n\n  Node.create = create;\n})(Node || (Node = {}));","map":null,"metadata":{},"sourceType":"module"}