{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport var Ellipse = /*#__PURE__*/function (_Geometry) {\n  _inherits(Ellipse, _Geometry);\n\n  function Ellipse(x, y, a, b) {\n    var _this;\n\n    _classCallCheck(this, Ellipse);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Ellipse).call(this));\n    _this.x = x == null ? 0 : x;\n    _this.y = y == null ? 0 : y;\n    _this.a = a == null ? 0 : a;\n    _this.b = b == null ? 0 : b;\n    return _this;\n  }\n\n  _createClass(Ellipse, [{\n    key: \"bbox\",\n\n    /**\n     * Returns a rectangle that is the bounding box of the ellipse.\n     */\n    value: function bbox() {\n      return Rectangle.fromEllipse(this);\n    }\n    /**\n     * Returns a point that is the center of the ellipse.\n     */\n\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n  }, {\n    key: \"inflate\",\n    value: function inflate(dx, dy) {\n      var w = dx;\n      var h = dy != null ? dy : dx;\n      this.a += 2 * w;\n      this.b += 2 * h;\n      return this;\n    }\n  }, {\n    key: \"normalizedDistance\",\n    value: function normalizedDistance(x, y) {\n      var ref = Point.create(x, y);\n      var dx = ref.x - this.x;\n      var dy = ref.y - this.y;\n      var a = this.a;\n      var b = this.b;\n      return dx * dx / (a * a) + dy * dy / (b * b);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(x, y) {\n      return this.normalizedDistance(x, y) <= 1;\n    }\n    /**\n     * Returns an array of the intersection points of the ellipse and the line.\n     * Returns `null` if no intersection exists.\n     */\n\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var intersections = [];\n      var rx = this.a;\n      var ry = this.b;\n      var a1 = line.start;\n      var a2 = line.end;\n      var dir = line.vector();\n      var diff = a1.diff(new Point(this.x, this.y));\n      var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n      var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n      var a = dir.dot(mDir);\n      var b = dir.dot(mDiff);\n      var c = diff.dot(mDiff) - 1.0;\n      var d = b * b - a * c;\n\n      if (d < 0) {\n        return null;\n      }\n\n      if (d > 0) {\n        var root = Math.sqrt(d);\n        var ta = (-b - root) / a;\n        var tb = (-b + root) / a;\n\n        if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n          // outside\n          return null;\n        }\n\n        if (ta >= 0 && ta <= 1) {\n          intersections.push(a1.lerp(a2, ta));\n        }\n\n        if (tb >= 0 && tb <= 1) {\n          intersections.push(a1.lerp(a2, tb));\n        }\n      } else {\n        var t = -b / a;\n\n        if (t >= 0 && t <= 1) {\n          intersections.push(a1.lerp(a2, t));\n        } else {\n          // outside\n          return null;\n        }\n      }\n\n      return intersections;\n    }\n    /**\n     * Returns the point on the boundary of the ellipse that is the\n     * intersection of the ellipse with a line starting in the center\n     * of the ellipse ending in the point `p`.\n     *\n     * If angle is specified, the intersection will take into account\n     * the rotation of the ellipse by angle degrees around its center.\n     */\n\n  }, {\n    key: \"intersectsWithLineFromCenterToPoint\",\n    value: function intersectsWithLineFromCenterToPoint(p) {\n      var angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var ref = Point.clone(p);\n\n      if (angle) {\n        ref.rotate(angle, this.getCenter());\n      }\n\n      var dx = ref.x - this.x;\n      var dy = ref.y - this.y;\n      var result;\n\n      if (dx === 0) {\n        result = this.bbox().getNearestPointToPoint(ref);\n\n        if (angle) {\n          return result.rotate(-angle, this.getCenter());\n        }\n\n        return result;\n      }\n\n      var m = dy / dx;\n      var mSquared = m * m;\n      var aSquared = this.a * this.a;\n      var bSquared = this.b * this.b;\n      var x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));\n      x = dx < 0 ? -x : x;\n      var y = m * x;\n      result = new Point(this.x + x, this.y + y);\n\n      if (angle) {\n        return result.rotate(-angle, this.getCenter());\n      }\n\n      return result;\n    }\n    /**\n     * Returns the angle between the x-axis and the tangent from a point. It is\n     * valid for points lying on the ellipse boundary only.\n     */\n\n  }, {\n    key: \"tangentTheta\",\n    value: function tangentTheta(p) {\n      var ref = Point.clone(p);\n      var x0 = ref.x;\n      var y0 = ref.y;\n      var a = this.a;\n      var b = this.b;\n      var center = this.bbox().center;\n      var cx = center.x;\n      var cy = center.y;\n      var refPointDelta = 30;\n      var q1 = x0 > center.x + a / 2;\n      var q3 = x0 < center.x - a / 2;\n      var x;\n      var y;\n\n      if (q1 || q3) {\n        y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n        x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;\n      } else {\n        x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n        y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;\n      }\n\n      return new Point(x, y).theta(ref);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      this.a *= sx;\n      this.b *= sy;\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      var rect = Rectangle.fromEllipse(this);\n      rect.rotate(angle, origin);\n      var ellipse = Ellipse.fromRect(rect);\n      this.a = ellipse.a;\n      this.b = ellipse.b;\n      this.x = ellipse.x;\n      this.y = ellipse.y;\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(dx, dy) {\n      var p = Point.create(dx, dy);\n      this.x += p.x;\n      this.y += p.y;\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(ellipse) {\n      return ellipse != null && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Ellipse(this.x, this.y, this.a, this.b);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        x: this.x,\n        y: this.y,\n        a: this.a,\n        b: this.b\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.x, \" \").concat(this.y, \" \").concat(this.a, \" \").concat(this.b);\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Ellipse.toStringTag;\n    }\n  }, {\n    key: \"center\",\n    get: function get() {\n      return new Point(this.x, this.y);\n    }\n  }]);\n\n  return Ellipse;\n}(Geometry);\n\n(function (Ellipse) {\n  Ellipse.toStringTag = \"X6.Geometry.\".concat(Ellipse.name);\n\n  function isEllipse(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Ellipse) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var ellipse = instance;\n\n    if ((tag == null || tag === Ellipse.toStringTag) && typeof ellipse.x === 'number' && typeof ellipse.y === 'number' && typeof ellipse.a === 'number' && typeof ellipse.b === 'number' && typeof ellipse.inflate === 'function' && typeof ellipse.normalizedDistance === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Ellipse.isEllipse = isEllipse;\n})(Ellipse || (Ellipse = {}));\n\n(function (Ellipse) {\n  function create(x, y, a, b) {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b);\n    }\n\n    return parse(x);\n  }\n\n  Ellipse.create = create;\n\n  function parse(e) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone();\n    }\n\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3]);\n    }\n\n    return new Ellipse(e.x, e.y, e.a, e.b);\n  }\n\n  Ellipse.parse = parse;\n\n  function fromRect(rect) {\n    var center = rect.center;\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);\n  }\n\n  Ellipse.fromRect = fromRect;\n})(Ellipse || (Ellipse = {}));","map":null,"metadata":{},"sourceType":"module"}