{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Matrix as MLMatrix, SingularValueDecomposition } from \"ml-matrix\";\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * mds 布局\n */\n\nexport var MDSLayout = /*#__PURE__*/function (_Base) {\n  _inherits(MDSLayout, _Base);\n\n  function MDSLayout(options) {\n    var _this;\n\n    _classCallCheck(this, MDSLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDSLayout).call(this));\n    /** 布局中心 */\n\n    _this.center = [0, 0];\n    /** 边长度 */\n\n    _this.linkDistance = 50;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(MDSLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        center: [0, 0],\n        linkDistance: 50\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes,\n          _self$edges = self.edges,\n          edges = _self$edges === void 0 ? [] : _self$edges;\n      var center = self.center;\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      var linkDistance = self.linkDistance; // the graph-theoretic distance (shortest path distance) matrix\n\n      var adjMatrix = getAdjMatrix({\n        nodes: nodes,\n        edges: edges\n      }, false);\n      var distances = floydWarshall(adjMatrix);\n      self.handleInfinity(distances); // scale the ideal edge length acoording to linkDistance\n\n      var scaledD = scaleMatrix(distances, linkDistance);\n      self.scaledDistances = scaledD; // get positions by MDS\n\n      var positions = self.runMDS();\n      self.positions = positions;\n      positions.forEach(function (p, i) {\n        nodes[i].x = p[0] + center[0];\n        nodes[i].y = p[1] + center[1];\n      });\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n    /**\n     * mds 算法\n     * @return {array} positions 计算后的节点位置数组\n     */\n\n  }, {\n    key: \"runMDS\",\n    value: function runMDS() {\n      var self = this;\n      var dimension = 2;\n      var distances = self.scaledDistances; // square distances\n\n      var M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n      var rowMeans = M.mean(\"row\");\n      var colMeans = M.mean(\"column\");\n      var totalMean = M.mean();\n      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n      // points from it\n\n      var ret = new SingularValueDecomposition(M);\n      var eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n      return ret.leftSingularVectors.toJSON().map(function (row) {\n        return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n      });\n    }\n  }, {\n    key: \"handleInfinity\",\n    value: function handleInfinity(distances) {\n      var maxDistance = -999999;\n      distances.forEach(function (row) {\n        row.forEach(function (value) {\n          if (value === Infinity) {\n            return;\n          }\n\n          if (maxDistance < value) {\n            maxDistance = value;\n          }\n        });\n      });\n      distances.forEach(function (row, i) {\n        row.forEach(function (value, j) {\n          if (value === Infinity) {\n            distances[i][j] = maxDistance;\n          }\n        });\n      });\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"mds\";\n    }\n  }]);\n\n  return MDSLayout;\n}(Base);","map":null,"metadata":{},"sourceType":"module"}