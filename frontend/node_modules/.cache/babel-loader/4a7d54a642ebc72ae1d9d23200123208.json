{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { isNaN, isArray, isFunction, isNumber, isString, floydWarshall, getAdjMatrix, isObject } from \"../../util\";\nimport { Base } from \"../base\";\nimport MDS from \"./mds\";\nimport RadialNonoverlapForce from \"./radialNonoverlapForce\";\n\nfunction getWeightMatrix(M) {\n  var rows = M.length;\n  var cols = M[0].length;\n  var result = [];\n\n  for (var i = 0; i < rows; i++) {\n    var row = [];\n\n    for (var j = 0; j < cols; j++) {\n      if (M[i][j] !== 0) {\n        row.push(1 / (M[i][j] * M[i][j]));\n      } else {\n        row.push(0);\n      }\n    }\n\n    result.push(row);\n  }\n\n  return result;\n}\n\nfunction getIndexById(array, id) {\n  var index = -1;\n  array.forEach(function (a, i) {\n    if (a.id === id) {\n      index = i;\n    }\n  });\n  return index;\n}\n\nfunction getEDistance(p1, p2) {\n  return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\n}\n/**\n * 辐射状布局\n */\n\n\nexport var RadialLayout = /*#__PURE__*/function (_Base) {\n  _inherits(RadialLayout, _Base);\n\n  function RadialLayout(options) {\n    var _this;\n\n    _classCallCheck(this, RadialLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RadialLayout).call(this));\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 1000;\n    /** 中心点，默认为数据中第一个点 */\n\n    _this.focusNode = null;\n    /** 每一圈半径 */\n\n    _this.unitRadius = null;\n    /** 默认边长度 */\n\n    _this.linkDistance = 50;\n    /** 是否防止重叠 */\n\n    _this.preventOverlap = false;\n    /** 是否必须是严格的 radial 布局，即每一层的节点严格布局在一个环上。preventOverlap 为 true 时生效 */\n\n    _this.strictRadial = true;\n    /** 防止重叠步骤的最大迭代次数 */\n\n    _this.maxPreventOverlapIteration = 200;\n    _this.sortStrength = 10;\n    _this.nodes = [];\n    _this.edges = [];\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(RadialLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        maxIteration: 1000,\n        focusNode: null,\n        unitRadius: null,\n        linkDistance: 50,\n        preventOverlap: false,\n        nodeSize: undefined,\n        nodeSpacing: undefined,\n        strictRadial: true,\n        maxPreventOverlapIteration: 200,\n        sortBy: undefined,\n        sortStrength: 10\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges || [];\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      var center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      var linkDistance = self.linkDistance; // layout\n\n      var focusNode = null;\n\n      if (isString(self.focusNode)) {\n        var found = false;\n\n        for (var i = 0; i < nodes.length; i++) {\n          if (nodes[i].id === self.focusNode) {\n            focusNode = nodes[i];\n            self.focusNode = focusNode;\n            found = true;\n            i = nodes.length;\n          }\n        }\n\n        if (!found) {\n          focusNode = null;\n        }\n      } else {\n        focusNode = self.focusNode;\n      } // default focus node\n\n\n      if (!focusNode) {\n        focusNode = nodes[0];\n        self.focusNode = focusNode;\n      } // the index of the focusNode in data\n\n\n      var focusIndex = getIndexById(nodes, focusNode.id);\n      self.focusIndex = focusIndex; // the graph-theoretic distance (shortest path distance) matrix\n\n      var adjMatrix = getAdjMatrix({\n        nodes: nodes,\n        edges: edges\n      }, false);\n      var D = floydWarshall(adjMatrix);\n      var maxDistance = self.maxToFocus(D, focusIndex); // replace first node in unconnected component to the circle at (maxDistance + 1)\n\n      self.handleInfinity(D, focusIndex, maxDistance + 1);\n      self.distances = D; // the shortest path distance from each node to focusNode\n\n      var focusNodeD = D[focusIndex];\n      var width = self.width || 500;\n      var height = self.height || 500;\n      var semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];\n      var semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];\n\n      if (semiWidth === 0) {\n        semiWidth = width / 2;\n      }\n\n      if (semiHeight === 0) {\n        semiHeight = height / 2;\n      } // the maxRadius of the graph\n\n\n      var maxRadius = semiHeight > semiWidth ? semiWidth : semiHeight;\n      var maxD = Math.max.apply(Math, _toConsumableArray(focusNodeD)); // the radius for each nodes away from focusNode\n\n      var radii = [];\n      focusNodeD.forEach(function (value, i) {\n        if (!self.unitRadius) {\n          self.unitRadius = maxRadius / maxD;\n        }\n\n        radii[i] = value * self.unitRadius;\n      });\n      self.radii = radii;\n      var eIdealD = self.eIdealDisMatrix(); // const eIdealD = scaleMatrix(D, linkDistance);\n\n      self.eIdealDistances = eIdealD; // the weight matrix, Wij = 1 / dij^(-2)\n\n      var W = getWeightMatrix(eIdealD);\n      self.weights = W; // the initial positions from mds\n\n      var mds = new MDS({\n        linkDistance: linkDistance,\n        distances: eIdealD\n      });\n      var positions = mds.layout();\n      positions.forEach(function (p) {\n        if (isNaN(p[0])) {\n          p[0] = Math.random() * linkDistance;\n        }\n\n        if (isNaN(p[1])) {\n          p[1] = Math.random() * linkDistance;\n        }\n      });\n      self.positions = positions;\n      positions.forEach(function (p, i) {\n        nodes[i].x = p[0] + center[0];\n        nodes[i].y = p[1] + center[1];\n      }); // move the graph to origin, centered at focusNode\n\n      positions.forEach(function (p) {\n        p[0] -= positions[focusIndex][0];\n        p[1] -= positions[focusIndex][1];\n      });\n      self.run();\n      var preventOverlap = self.preventOverlap;\n      var nodeSize = self.nodeSize;\n      var nodeSizeFunc;\n      var strictRadial = self.strictRadial; // stagger the overlapped nodes\n\n      if (preventOverlap) {\n        var nodeSpacing = self.nodeSpacing;\n        var nodeSpacingFunc;\n\n        if (isNumber(nodeSpacing)) {\n          nodeSpacingFunc = function nodeSpacingFunc() {\n            return nodeSpacing;\n          };\n        } else if (isFunction(nodeSpacing)) {\n          nodeSpacingFunc = nodeSpacing;\n        } else {\n          nodeSpacingFunc = function nodeSpacingFunc() {\n            return 0;\n          };\n        }\n\n        if (!nodeSize) {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            if (d.size) {\n              if (isArray(d.size)) {\n                var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                return res + nodeSpacingFunc(d);\n              }\n\n              if (isObject(d.size)) {\n                var _res = d.size.width > d.size.height ? d.size.width : d.size.height;\n\n                return _res + nodeSpacingFunc(d);\n              }\n\n              return d.size + nodeSpacingFunc(d);\n            }\n\n            return 10 + nodeSpacingFunc(d);\n          };\n        } else if (isArray(nodeSize)) {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            return res + nodeSpacingFunc(d);\n          };\n        } else {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            return nodeSize + nodeSpacingFunc(d);\n          };\n        }\n\n        var nonoverlapForceParams = {\n          nodes: nodes,\n          nodeSizeFunc: nodeSizeFunc,\n          adjMatrix: adjMatrix,\n          positions: positions,\n          radii: radii,\n          height: height,\n          width: width,\n          strictRadial: strictRadial,\n          focusID: focusIndex,\n          iterations: self.maxPreventOverlapIteration || 200,\n          k: positions.length / 4.5\n        };\n        var nonoverlapForce = new RadialNonoverlapForce(nonoverlapForceParams);\n        positions = nonoverlapForce.layout();\n      } // move the graph to center\n\n\n      positions.forEach(function (p, i) {\n        nodes[i].x = p[0] + center[0];\n        nodes[i].y = p[1] + center[1];\n      });\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var self = this;\n      var maxIteration = self.maxIteration;\n      var positions = self.positions || [];\n      var W = self.weights || [];\n      var eIdealDis = self.eIdealDistances || [];\n      var radii = self.radii || [];\n\n      for (var i = 0; i <= maxIteration; i++) {\n        var param = i / maxIteration;\n        self.oneIteration(param, positions, radii, eIdealDis, W);\n      }\n    }\n  }, {\n    key: \"oneIteration\",\n    value: function oneIteration(param, positions, radii, D, W) {\n      var self = this;\n      var vparam = 1 - param;\n      var focusIndex = self.focusIndex;\n      positions.forEach(function (v, i) {\n        // v\n        var originDis = getEDistance(v, [0, 0]);\n        var reciODis = originDis === 0 ? 0 : 1 / originDis;\n\n        if (i === focusIndex) {\n          return;\n        }\n\n        var xMolecule = 0;\n        var yMolecule = 0;\n        var denominator = 0;\n        positions.forEach(function (u, j) {\n          // u\n          if (i === j) {\n            return;\n          } // the euclidean distance between v and u\n\n\n          var edis = getEDistance(v, u);\n          var reciEdis = edis === 0 ? 0 : 1 / edis;\n          var idealDis = D[j][i]; // same for x and y\n\n          denominator += W[i][j]; // x\n\n          xMolecule += W[i][j] * (u[0] + idealDis * (v[0] - u[0]) * reciEdis); // y\n\n          yMolecule += W[i][j] * (u[1] + idealDis * (v[1] - u[1]) * reciEdis);\n        });\n        var reciR = radii[i] === 0 ? 0 : 1 / radii[i];\n        denominator *= vparam;\n        denominator += param * reciR * reciR; // x\n\n        xMolecule *= vparam;\n        xMolecule += param * reciR * v[0] * reciODis;\n        v[0] = xMolecule / denominator; // y\n\n        yMolecule *= vparam;\n        yMolecule += param * reciR * v[1] * reciODis;\n        v[1] = yMolecule / denominator;\n      });\n    }\n  }, {\n    key: \"eIdealDisMatrix\",\n    value: function eIdealDisMatrix() {\n      var self = this;\n      var nodes = self.nodes;\n      if (!nodes) return [];\n      var D = self.distances;\n      var linkDis = self.linkDistance;\n      var radii = self.radii || [];\n      var unitRadius = self.unitRadius || 50;\n      var result = [];\n\n      if (D) {\n        D.forEach(function (row, i) {\n          var newRow = [];\n          row.forEach(function (v, j) {\n            if (i === j) {\n              newRow.push(0);\n            } else if (radii[i] === radii[j]) {\n              // i and j are on the same circle\n              if (self.sortBy === \"data\") {\n                // sort the nodes on the same circle according to the ordering of the data\n                newRow.push(v * (Math.abs(i - j) * self.sortStrength) / (radii[i] / unitRadius));\n              } else if (self.sortBy) {\n                // sort the nodes on the same circle according to the attributes\n                var iValue = nodes[i][self.sortBy] || 0;\n                var jValue = nodes[j][self.sortBy] || 0;\n\n                if (isString(iValue)) {\n                  iValue = iValue.charCodeAt(0);\n                }\n\n                if (isString(jValue)) {\n                  jValue = jValue.charCodeAt(0);\n                }\n\n                newRow.push(v * (Math.abs(iValue - jValue) * self.sortStrength) / (radii[i] / unitRadius));\n              } else {\n                newRow.push(v * linkDis / (radii[i] / unitRadius));\n              }\n            } else {\n              // i and j are on different circle\n              // i and j are on different circle\n              var link = (linkDis + unitRadius) / 2;\n              newRow.push(v * link);\n            }\n          });\n          result.push(newRow);\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"handleInfinity\",\n    value: function handleInfinity(matrix, focusIndex, step) {\n      var length = matrix.length; // 遍历 matrix 中遍历 focus 对应行\n\n      for (var i = 0; i < length; i++) {\n        // matrix 关注点对应行的 Inf 项\n        if (matrix[focusIndex][i] === Infinity) {\n          matrix[focusIndex][i] = step;\n          matrix[i][focusIndex] = step; // 遍历 matrix 中的 i 行，i 行中非 Inf 项若在 focus 行为 Inf，则替换 focus 行的那个 Inf\n\n          for (var j = 0; j < length; j++) {\n            if (matrix[i][j] !== Infinity && matrix[focusIndex][j] === Infinity) {\n              matrix[focusIndex][j] = step + matrix[i][j];\n              matrix[j][focusIndex] = step + matrix[i][j];\n            }\n          }\n        }\n      } // 处理其他行的 Inf。根据该行对应点与 focus 距离以及 Inf 项点 与 focus 距离，决定替换值\n\n\n      for (var _i = 0; _i < length; _i++) {\n        if (_i === focusIndex) {\n          continue;\n        }\n\n        for (var _j = 0; _j < length; _j++) {\n          if (matrix[_i][_j] === Infinity) {\n            var minus = Math.abs(matrix[focusIndex][_i] - matrix[focusIndex][_j]);\n            minus = minus === 0 ? 1 : minus;\n            matrix[_i][_j] = minus;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"maxToFocus\",\n    value: function maxToFocus(matrix, focusIndex) {\n      var max = 0;\n\n      for (var i = 0; i < matrix[focusIndex].length; i++) {\n        if (matrix[focusIndex][i] === Infinity) {\n          continue;\n        }\n\n        max = matrix[focusIndex][i] > max ? matrix[focusIndex][i] : max;\n      }\n\n      return max;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"radial\";\n    }\n  }]);\n\n  return RadialLayout;\n}(Base);","map":null,"metadata":{},"sourceType":"module"}