{"ast":null,"code":"import _defineProperty from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Util } from '../../global/util';\nimport { Point } from '../../geometry';\nimport { View } from '../../view/view';\nimport { ToolsView } from '../../view/tool';\nexport var Vertices = /*#__PURE__*/function (_ToolsView$ToolItem) {\n  _inherits(Vertices, _ToolsView$ToolItem);\n\n  function Vertices() {\n    var _this;\n\n    _classCallCheck(this, Vertices);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Vertices).apply(this, arguments));\n    _this.handles = [];\n    return _this;\n  }\n\n  _createClass(Vertices, [{\n    key: \"onRender\",\n    value: function onRender() {\n      this.addClass(this.prefixClassName('edge-tool-vertices'));\n\n      if (this.options.addable) {\n        this.updatePath();\n      }\n\n      this.resetHandles();\n      this.renderHandles();\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var vertices = this.vertices;\n\n      if (vertices.length === this.handles.length) {\n        this.updateHandles();\n      } else {\n        this.resetHandles();\n        this.renderHandles();\n      }\n\n      if (this.options.addable) {\n        this.updatePath();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"resetHandles\",\n    value: function resetHandles() {\n      var _this2 = this;\n\n      var handles = this.handles;\n      this.handles = [];\n\n      if (handles) {\n        handles.forEach(function (handle) {\n          _this2.stopHandleListening(handle);\n\n          handle.remove();\n        });\n      }\n    }\n  }, {\n    key: \"renderHandles\",\n    value: function renderHandles() {\n      var _this3 = this;\n\n      var vertices = this.vertices;\n\n      for (var i = 0, l = vertices.length; i < l; i += 1) {\n        var vertex = vertices[i];\n        var createHandle = this.options.createHandle;\n        var processHandle = this.options.processHandle;\n        var handle = createHandle({\n          index: i,\n          graph: this.graph,\n          guard: function guard(evt) {\n            return _this3.guard(evt);\n          },\n          attrs: this.options.attrs || {}\n        });\n\n        if (processHandle) {\n          processHandle(handle);\n        }\n\n        this.graph.hook.onToolItemCreated({\n          name: 'vertices',\n          cell: this.cell,\n          view: this.cellView,\n          tool: handle\n        });\n        handle.updatePosition(vertex.x, vertex.y);\n        this.stamp(handle.container);\n        this.container.appendChild(handle.container);\n        this.handles.push(handle);\n        this.startHandleListening(handle);\n      }\n    }\n  }, {\n    key: \"updateHandles\",\n    value: function updateHandles() {\n      var vertices = this.vertices;\n\n      for (var i = 0, l = vertices.length; i < l; i += 1) {\n        var vertex = vertices[i];\n        var handle = this.handles[i];\n\n        if (handle) {\n          handle.updatePosition(vertex.x, vertex.y);\n        }\n      }\n    }\n  }, {\n    key: \"updatePath\",\n    value: function updatePath() {\n      var connection = this.childNodes.connection;\n\n      if (connection) {\n        connection.setAttribute('d', this.cellView.getConnectionPathData());\n      }\n    }\n  }, {\n    key: \"startHandleListening\",\n    value: function startHandleListening(handle) {\n      var edgeView = this.cellView;\n\n      if (edgeView.can('vertexMovable')) {\n        handle.on('change', this.onHandleChange, this);\n        handle.on('changing', this.onHandleChanging, this);\n        handle.on('changed', this.onHandleChanged, this);\n      }\n\n      if (edgeView.can('vertexDeletable')) {\n        handle.on('remove', this.onHandleRemove, this);\n      }\n    }\n  }, {\n    key: \"stopHandleListening\",\n    value: function stopHandleListening(handle) {\n      var edgeView = this.cellView;\n\n      if (edgeView.can('vertexMovable')) {\n        handle.off('change', this.onHandleChange, this);\n        handle.off('changing', this.onHandleChanging, this);\n        handle.off('changed', this.onHandleChanged, this);\n      }\n\n      if (edgeView.can('vertexDeletable')) {\n        handle.off('remove', this.onHandleRemove, this);\n      }\n    }\n  }, {\n    key: \"getNeighborPoints\",\n    value: function getNeighborPoints(index) {\n      var edgeView = this.cellView;\n      var vertices = this.vertices;\n      var prev = index > 0 ? vertices[index - 1] : edgeView.sourceAnchor;\n      var next = index < vertices.length - 1 ? vertices[index + 1] : edgeView.targetAnchor;\n      return {\n        prev: Point.create(prev),\n        next: Point.create(next)\n      };\n    }\n  }, {\n    key: \"getMouseEventArgs\",\n    value: function getMouseEventArgs(evt) {\n      var e = this.normalizeEvent(evt);\n\n      var _this$graph$snapToGri = this.graph.snapToGrid(e.clientX, e.clientY),\n          x = _this$graph$snapToGri.x,\n          y = _this$graph$snapToGri.y;\n\n      return {\n        e: e,\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"onHandleChange\",\n    value: function onHandleChange(_ref) {\n      var e = _ref.e;\n      this.focus();\n      var edgeView = this.cellView;\n      edgeView.cell.startBatch('move-vertex', {\n        ui: true,\n        toolId: this.cid\n      });\n\n      if (!this.options.stopPropagation) {\n        var _this$getMouseEventAr = this.getMouseEventArgs(e),\n            evt = _this$getMouseEventAr.e,\n            x = _this$getMouseEventAr.x,\n            y = _this$getMouseEventAr.y;\n\n        edgeView.notifyMouseDown(evt, x, y);\n      }\n    }\n  }, {\n    key: \"onHandleChanging\",\n    value: function onHandleChanging(_ref2) {\n      var handle = _ref2.handle,\n          e = _ref2.e;\n      var edgeView = this.cellView;\n      var index = handle.options.index;\n\n      var _this$getMouseEventAr2 = this.getMouseEventArgs(e),\n          evt = _this$getMouseEventAr2.e,\n          x = _this$getMouseEventAr2.x,\n          y = _this$getMouseEventAr2.y;\n\n      var vertex = {\n        x: x,\n        y: y\n      };\n      this.snapVertex(vertex, index);\n      edgeView.cell.setVertexAt(index, vertex, {\n        ui: true,\n        toolId: this.cid\n      });\n      handle.updatePosition(vertex.x, vertex.y);\n\n      if (!this.options.stopPropagation) {\n        edgeView.notifyMouseMove(evt, x, y);\n      }\n    }\n  }, {\n    key: \"onHandleChanged\",\n    value: function onHandleChanged(_ref3) {\n      var e = _ref3.e;\n      var options = this.options;\n      var edgeView = this.cellView;\n\n      if (options.addable) {\n        this.updatePath();\n      }\n\n      if (!options.removeRedundancies) {\n        return;\n      }\n\n      var verticesRemoved = edgeView.removeRedundantLinearVertices({\n        ui: true,\n        toolId: this.cid\n      });\n\n      if (verticesRemoved) {\n        this.render();\n      }\n\n      this.blur();\n      edgeView.cell.stopBatch('move-vertex', {\n        ui: true,\n        toolId: this.cid\n      });\n\n      if (this.eventData(e).vertexAdded) {\n        edgeView.cell.stopBatch('add-vertex', {\n          ui: true,\n          toolId: this.cid\n        });\n      }\n\n      var _this$getMouseEventAr3 = this.getMouseEventArgs(e),\n          evt = _this$getMouseEventAr3.e,\n          x = _this$getMouseEventAr3.x,\n          y = _this$getMouseEventAr3.y;\n\n      if (!this.options.stopPropagation) {\n        edgeView.notifyMouseUp(evt, x, y);\n      }\n\n      edgeView.checkMouseleave(evt);\n      options.onChanged && options.onChanged({\n        edge: edgeView.cell,\n        edgeView: edgeView\n      });\n    }\n  }, {\n    key: \"snapVertex\",\n    value: function snapVertex(vertex, index) {\n      var snapRadius = this.options.snapRadius || 0;\n\n      if (snapRadius > 0) {\n        var neighbors = this.getNeighborPoints(index);\n        var prev = neighbors.prev;\n        var next = neighbors.next;\n\n        if (Math.abs(vertex.x - prev.x) < snapRadius) {\n          vertex.x = prev.x;\n        } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n          vertex.x = next.x;\n        }\n\n        if (Math.abs(vertex.y - prev.y) < snapRadius) {\n          vertex.y = neighbors.prev.y;\n        } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n          vertex.y = next.y;\n        }\n      }\n    }\n  }, {\n    key: \"onHandleRemove\",\n    value: function onHandleRemove(_ref4) {\n      var handle = _ref4.handle,\n          e = _ref4.e;\n\n      if (this.options.removable) {\n        var index = handle.options.index;\n        var edgeView = this.cellView;\n        edgeView.cell.removeVertexAt(index, {\n          ui: true\n        });\n\n        if (this.options.addable) {\n          this.updatePath();\n        }\n\n        edgeView.checkMouseleave(this.normalizeEvent(e));\n      }\n    }\n  }, {\n    key: \"onPathMouseDown\",\n    value: function onPathMouseDown(evt) {\n      var edgeView = this.cellView;\n\n      if (this.guard(evt) || !this.options.addable || !edgeView.can('vertexAddable')) {\n        return;\n      }\n\n      evt.stopPropagation();\n      evt.preventDefault();\n      var e = this.normalizeEvent(evt);\n      var vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();\n      edgeView.cell.startBatch('add-vertex', {\n        ui: true,\n        toolId: this.cid\n      });\n      var index = edgeView.getVertexIndex(vertex.x, vertex.y);\n      this.snapVertex(vertex, index);\n      edgeView.cell.insertVertex(vertex, index, {\n        ui: true,\n        toolId: this.cid\n      });\n      this.render();\n      var handle = this.handles[index];\n      this.eventData(e, {\n        vertexAdded: true\n      });\n      handle.onMouseDown(e);\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.resetHandles();\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      return this.cellView.cell.getVertices();\n    }\n  }]);\n\n  return Vertices;\n}(ToolsView.ToolItem);\n\n(function (Vertices) {\n  var Handle = /*#__PURE__*/function (_View) {\n    _inherits(Handle, _View);\n\n    function Handle(options) {\n      var _this4;\n\n      _classCallCheck(this, Handle);\n\n      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Handle).call(this));\n      _this4.options = options;\n\n      _this4.render();\n\n      _this4.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown',\n        dblclick: 'onDoubleClick'\n      });\n\n      return _this4;\n    }\n\n    _createClass(Handle, [{\n      key: \"render\",\n      value: function render() {\n        this.container = View.createElement('circle', true);\n        var attrs = this.options.attrs;\n\n        if (typeof attrs === 'function') {\n          var defaults = Vertices.getDefaults();\n          this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));\n        } else {\n          this.setAttrs(attrs);\n        }\n\n        this.addClass(this.prefixClassName('edge-tool-vertex'));\n      }\n    }, {\n      key: \"updatePosition\",\n      value: function updatePosition(x, y) {\n        this.setAttrs({\n          cx: x,\n          cy: y\n        });\n      }\n    }, {\n      key: \"onMouseDown\",\n      value: function onMouseDown(evt) {\n        if (this.options.guard(evt)) {\n          return;\n        }\n\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.graph.view.undelegateEvents();\n        this.delegateDocumentEvents({\n          mousemove: 'onMouseMove',\n          touchmove: 'onMouseMove',\n          mouseup: 'onMouseUp',\n          touchend: 'onMouseUp',\n          touchcancel: 'onMouseUp'\n        }, evt.data);\n        this.emit('change', {\n          e: evt,\n          handle: this\n        });\n      }\n    }, {\n      key: \"onMouseMove\",\n      value: function onMouseMove(evt) {\n        this.emit('changing', {\n          e: evt,\n          handle: this\n        });\n      }\n    }, {\n      key: \"onMouseUp\",\n      value: function onMouseUp(evt) {\n        this.emit('changed', {\n          e: evt,\n          handle: this\n        });\n        this.undelegateDocumentEvents();\n        this.graph.view.delegateEvents();\n      }\n    }, {\n      key: \"onDoubleClick\",\n      value: function onDoubleClick(evt) {\n        this.emit('remove', {\n          e: evt,\n          handle: this\n        });\n      }\n    }, {\n      key: \"graph\",\n      get: function get() {\n        return this.options.graph;\n      }\n    }]);\n\n    return Handle;\n  }(View);\n\n  Vertices.Handle = Handle;\n})(Vertices || (Vertices = {}));\n\n(function (Vertices) {\n  var _events;\n\n  var pathClassName = Util.prefix('edge-tool-vertex-path');\n  Vertices.config({\n    name: 'vertices',\n    snapRadius: 20,\n    addable: true,\n    removable: true,\n    removeRedundancies: true,\n    stopPropagation: true,\n    attrs: {\n      r: 6,\n      fill: '#333',\n      stroke: '#fff',\n      cursor: 'move',\n      'stroke-width': 2\n    },\n    createHandle: function createHandle(options) {\n      return new Vertices.Handle(options);\n    },\n    markup: [{\n      tagName: 'path',\n      selector: 'connection',\n      className: pathClassName,\n      attrs: {\n        fill: 'none',\n        stroke: 'transparent',\n        'stroke-width': 10,\n        cursor: 'pointer'\n      }\n    }],\n    events: (_events = {}, _defineProperty(_events, \"mousedown .\".concat(pathClassName), 'onPathMouseDown'), _defineProperty(_events, \"touchstart .\".concat(pathClassName), 'onPathMouseDown'), _events)\n  });\n})(Vertices || (Vertices = {}));","map":null,"metadata":{},"sourceType":"module"}