{"ast":null,"code":"import _defineProperty from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Util } from '../../global';\nimport { NumberExt } from '../../util';\nimport { Angle, Point } from '../../geometry';\nimport { Widget } from '../common';\nimport { notify } from './util';\nexport var Transform = /*#__PURE__*/function (_Widget) {\n  _inherits(Transform, _Widget);\n\n  function Transform() {\n    _classCallCheck(this, Transform);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Transform).apply(this, arguments));\n  }\n\n  _createClass(Transform, [{\n    key: \"init\",\n    value: function init(options) {\n      this.options = Object.assign(Object.assign({}, Private.defaultOptions), options);\n      this.render();\n      this.startListening();\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      var _this$delegateEvents;\n\n      this.delegateEvents((_this$delegateEvents = {}, _defineProperty(_this$delegateEvents, \"mousedown .\".concat(this.resizeClassName), 'startResizing'), _defineProperty(_this$delegateEvents, \"touchstart .\".concat(this.resizeClassName), 'startResizing'), _defineProperty(_this$delegateEvents, \"mousedown .\".concat(this.rotateClassName), 'startRotating'), _defineProperty(_this$delegateEvents, \"touchstart .\".concat(this.rotateClassName), 'startRotating'), _this$delegateEvents));\n      this.model.on('*', this.update, this);\n      this.graph.on('scale', this.update, this);\n      this.graph.on('translate', this.update, this);\n      this.node.on('removed', this.remove, this);\n      this.model.on('reseted', this.remove, this);\n      this.view.on('cell:knob:mousedown', this.onKnobMouseDown, this);\n      this.view.on('cell:knob:mouseup', this.onKnobMouseUp, this);\n\n      _get(_getPrototypeOf(Transform.prototype), \"startListening\", this).call(this);\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      this.undelegateEvents();\n      this.model.off('*', this.update, this);\n      this.graph.off('scale', this.update, this);\n      this.graph.off('translate', this.update, this);\n      this.node.off('removed', this.remove, this);\n      this.model.off('reseted', this.remove, this);\n      this.view.off('cell:knob:mousedown', this.onKnobMouseDown, this);\n      this.view.off('cell:knob:mouseup', this.onKnobMouseUp, this);\n\n      _get(_getPrototypeOf(Transform.prototype), \"stopListening\", this).call(this);\n    }\n  }, {\n    key: \"renderHandles\",\n    value: function renderHandles() {\n      var _this = this;\n\n      this.container = document.createElement('div');\n      this.$container = this.$(this.container);\n      var $knob = this.$('<div/>').prop('draggable', false);\n      var $rotate = $knob.clone().addClass(this.rotateClassName);\n      var $resizes = Private.POSITIONS.map(function (pos) {\n        return $knob.clone().addClass(_this.resizeClassName).attr('data-position', pos);\n      });\n      this.empty();\n      this.$container.append($resizes, $rotate);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.renderHandles();\n      this.view.addClass(Private.NODE_CLS);\n      this.$container.addClass(this.containerClassName).toggleClass('no-orth-resize', this.options.preserveAspectRatio || !this.options.orthogonalResizing).toggleClass('no-resize', !this.options.resizable).toggleClass('no-rotate', !this.options.rotatable);\n\n      if (this.options.className) {\n        this.$container.addClass(this.options.className);\n      }\n\n      this.graph.container.appendChild(this.container);\n      return this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var ctm = this.graph.matrix();\n      var bbox = this.node.getBBox();\n      bbox.x *= ctm.a;\n      bbox.x += ctm.e;\n      bbox.y *= ctm.d;\n      bbox.y += ctm.f;\n      bbox.width *= ctm.a;\n      bbox.height *= ctm.d;\n      var angle = Angle.normalize(this.node.getAngle());\n      var transform = angle !== 0 ? \"rotate(\".concat(angle, \"deg)\") : '';\n      this.$container.css({\n        transform: transform,\n        width: bbox.width,\n        height: bbox.height,\n        left: bbox.x,\n        top: bbox.y\n      });\n      this.updateResizerDirections();\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.view.removeClass(Private.NODE_CLS);\n      return _get(_getPrototypeOf(Transform.prototype), \"remove\", this).call(this);\n    }\n  }, {\n    key: \"onKnobMouseDown\",\n    value: function onKnobMouseDown() {\n      this.startHandle();\n    }\n  }, {\n    key: \"onKnobMouseUp\",\n    value: function onKnobMouseUp() {\n      this.stopHandle();\n    }\n  }, {\n    key: \"updateResizerDirections\",\n    value: function updateResizerDirections() {\n      var _this2 = this;\n\n      // Update the directions on the resizer divs while the node being rotated.\n      // The directions are represented by cardinal points (N,S,E,W). For example\n      // the div originally pointed to north needs to be changed to point to south\n      // if the node was rotated by 180 degrees.\n      var angle = Angle.normalize(this.node.getAngle());\n      var shift = Math.floor(angle * (Private.DIRECTIONS.length / 360));\n\n      if (shift !== this.prevShift) {\n        // Create the current directions array based on the calculated shift.\n        var directions = Private.DIRECTIONS.slice(shift).concat(Private.DIRECTIONS.slice(0, shift));\n\n        var className = function className(dir) {\n          return \"\".concat(_this2.containerClassName, \"-cursor-\").concat(dir);\n        };\n\n        this.$container.find(\".\".concat(this.resizeClassName)).removeClass(Private.DIRECTIONS.map(function (dir) {\n          return className(dir);\n        }).join(' ')).each(function (index, elem) {\n          _this2.$(elem).addClass(className(directions[index]));\n        });\n        this.prevShift = shift;\n      }\n    }\n  }, {\n    key: \"getTrueDirection\",\n    value: function getTrueDirection(dir) {\n      var angle = Angle.normalize(this.node.getAngle());\n      var index = Private.POSITIONS.indexOf(dir);\n      index += Math.floor(angle * (Private.POSITIONS.length / 360));\n      index %= Private.POSITIONS.length;\n      return Private.POSITIONS[index];\n    }\n  }, {\n    key: \"toValidResizeDirection\",\n    value: function toValidResizeDirection(dir) {\n      return {\n        top: 'top-left',\n        bottom: 'bottom-right',\n        left: 'bottom-left',\n        right: 'top-right'\n      }[dir] || dir;\n    }\n  }, {\n    key: \"startResizing\",\n    value: function startResizing(evt) {\n      evt.stopPropagation();\n      this.model.startBatch('resize', {\n        cid: this.cid\n      });\n      var dir = this.$(evt.target).attr('data-position');\n      var view = this.graph.findViewByCell(this.node);\n      this.prepareResizing(evt, dir);\n      this.startAction(evt);\n      notify('node:resize:mousedown', evt, view);\n    }\n  }, {\n    key: \"prepareResizing\",\n    value: function prepareResizing(evt, relativeDirection) {\n      var trueDirection = this.getTrueDirection(relativeDirection);\n      var rx = 0;\n      var ry = 0;\n      relativeDirection.split('-').forEach(function (direction) {\n        rx = {\n          left: -1,\n          right: 1\n        }[direction] || rx;\n        ry = {\n          top: -1,\n          bottom: 1\n        }[direction] || ry;\n      });\n      var direction = this.toValidResizeDirection(relativeDirection);\n      var selector = {\n        'top-right': 'bottomLeft',\n        'top-left': 'bottomRight',\n        'bottom-left': 'topRight',\n        'bottom-right': 'topLeft'\n      }[direction];\n      var angle = Angle.normalize(this.node.getAngle());\n      this.setEventData(evt, {\n        selector: selector,\n        direction: direction,\n        trueDirection: trueDirection,\n        relativeDirection: relativeDirection,\n        angle: angle,\n        resizeX: rx,\n        resizeY: ry,\n        action: 'resizing'\n      });\n    }\n  }, {\n    key: \"startRotating\",\n    value: function startRotating(evt) {\n      evt.stopPropagation();\n      this.model.startBatch('rotate', {\n        cid: this.cid\n      });\n      var view = this.graph.findViewByCell(this.node);\n      var center = this.node.getBBox().getCenter();\n      var e = this.normalizeEvent(evt);\n      var client = this.graph.snapToGrid(e.clientX, e.clientY);\n      this.setEventData(evt, {\n        center: center,\n        action: 'rotating',\n        angle: Angle.normalize(this.node.getAngle()),\n        start: Point.create(client).theta(center)\n      });\n      this.startAction(evt);\n      notify('node:rotate:mousedown', evt, view);\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(evt) {\n      var view = this.graph.findViewByCell(this.node);\n      var data = this.getEventData(evt);\n\n      if (data.action) {\n        var e = this.normalizeEvent(evt);\n        var clientX = e.clientX;\n        var clientY = e.clientY;\n        var scroller = this.graph.scroller.widget;\n        var restrict = this.options.restrictedResizing;\n\n        if (restrict === true || typeof restrict === 'number') {\n          var factor = restrict === true ? 0 : restrict;\n          var fix = scroller ? Math.max(factor, 8) : factor;\n          var rect = this.graph.container.getBoundingClientRect();\n          clientX = NumberExt.clamp(clientX, rect.left + fix, rect.right - fix);\n          clientY = NumberExt.clamp(clientY, rect.top + fix, rect.bottom - fix);\n        } else if (this.options.autoScrollOnResizing && scroller) {\n          scroller.autoScroll(clientX, clientY);\n        }\n\n        var pos = this.graph.snapToGrid(clientX, clientY);\n        var gridSize = this.graph.getGridSize();\n        var node = this.node;\n        var options = this.options;\n\n        if (data.action === 'resizing') {\n          data = data;\n\n          if (!data.resized) {\n            if (view) {\n              view.addClass('node-resizing');\n              notify('node:resize', evt, view);\n            }\n\n            data.resized = true;\n          }\n\n          var currentBBox = node.getBBox();\n          var requestedSize = Point.create(pos).rotate(data.angle, currentBBox.getCenter()).diff(currentBBox[data.selector]);\n          var width = data.resizeX ? requestedSize.x * data.resizeX : currentBBox.width;\n          var height = data.resizeY ? requestedSize.y * data.resizeY : currentBBox.height;\n          var rawWidth = width;\n          var rawHeight = height;\n          width = Util.snapToGrid(width, gridSize);\n          height = Util.snapToGrid(height, gridSize);\n          width = Math.max(width, options.minWidth || gridSize);\n          height = Math.max(height, options.minHeight || gridSize);\n          width = Math.min(width, options.maxWidth || Infinity);\n          height = Math.min(height, options.maxHeight || Infinity);\n\n          if (options.preserveAspectRatio) {\n            var candidateWidth = currentBBox.width * height / currentBBox.height;\n            var candidateHeight = currentBBox.height * width / currentBBox.width;\n\n            if (width < candidateWidth) {\n              height = candidateHeight;\n            } else {\n              width = candidateWidth;\n            }\n          }\n\n          var relativeDirection = data.relativeDirection;\n\n          if (options.allowReverse && (rawWidth <= -width || rawHeight <= -height)) {\n            var reverted;\n\n            if (relativeDirection === 'left') {\n              if (rawWidth <= -width) {\n                reverted = 'right';\n              }\n            } else if (relativeDirection === 'right') {\n              if (rawWidth <= -width) {\n                reverted = 'left';\n              }\n            } else if (relativeDirection === 'top') {\n              if (rawHeight <= -height) {\n                reverted = 'bottom';\n              }\n            } else if (relativeDirection === 'bottom') {\n              if (rawHeight <= -height) {\n                reverted = 'top';\n              }\n            } else if (relativeDirection === 'top-left') {\n              if (rawWidth <= -width && rawHeight <= -height) {\n                reverted = 'bottom-right';\n              } else if (rawWidth <= -width) {\n                reverted = 'top-right';\n              } else if (rawHeight <= -height) {\n                reverted = 'bottom-left';\n              }\n            } else if (relativeDirection === 'top-right') {\n              if (rawWidth <= -width && rawHeight <= -height) {\n                reverted = 'bottom-left';\n              } else if (rawWidth <= -width) {\n                reverted = 'top-left';\n              } else if (rawHeight <= -height) {\n                reverted = 'bottom-right';\n              }\n            } else if (relativeDirection === 'bottom-left') {\n              if (rawWidth <= -width && rawHeight <= -height) {\n                reverted = 'top-right';\n              } else if (rawWidth <= -width) {\n                reverted = 'bottom-right';\n              } else if (rawHeight <= -height) {\n                reverted = 'top-left';\n              }\n            } else if (relativeDirection === 'bottom-right') {\n              if (rawWidth <= -width && rawHeight <= -height) {\n                reverted = 'top-left';\n              } else if (rawWidth <= -width) {\n                reverted = 'bottom-left';\n              } else if (rawHeight <= -height) {\n                reverted = 'top-right';\n              }\n            }\n\n            var revertedDir = reverted;\n            this.stopHandle();\n            var $handle = this.$container.find(\".\".concat(this.resizeClassName, \"[data-position=\\\"\").concat(revertedDir, \"\\\"]\"));\n            this.startHandle($handle[0]);\n            this.prepareResizing(evt, revertedDir);\n            this.onMouseMove(evt);\n          }\n\n          if (currentBBox.width !== width || currentBBox.height !== height) {\n            var resizeOptions = {\n              ui: true,\n              direction: data.direction,\n              relativeDirection: data.relativeDirection,\n              trueDirection: data.trueDirection,\n              minWidth: options.minWidth,\n              minHeight: options.minHeight,\n              maxWidth: options.maxWidth,\n              maxHeight: options.maxHeight,\n              preserveAspectRatio: options.preserveAspectRatio === true\n            };\n            node.resize(width, height, resizeOptions);\n            notify('node:resizing', evt, view);\n          }\n\n          notify('node:resize:mousemove', evt, view);\n        } else if (data.action === 'rotating') {\n          data = data;\n\n          if (!data.rotated) {\n            if (view) {\n              view.addClass('node-rotating');\n              notify('node:rotate', evt, view);\n            }\n\n            data.rotated = true;\n          }\n\n          var currentAngle = node.getAngle();\n          var theta = data.start - Point.create(pos).theta(data.center);\n          var target = data.angle + theta;\n\n          if (options.rotateGrid) {\n            target = Util.snapToGrid(target, options.rotateGrid);\n          }\n\n          if (currentAngle !== target) {\n            node.rotate(target, {\n              absolute: true\n            });\n            notify('node:rotating', evt, view);\n          }\n\n          notify('node:rotate:mousemove', evt, view);\n        }\n      }\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(evt) {\n      var view = this.graph.findViewByCell(this.node);\n      var data = this.getEventData(evt);\n\n      if (data.action) {\n        this.stopAction(evt);\n        this.model.stopBatch(data.action === 'resizing' ? 'resize' : 'rotate', {\n          cid: this.cid\n        });\n\n        if (data.action === 'resizing') {\n          notify('node:resize:mouseup', evt, view);\n        } else if (data.action === 'rotating') {\n          notify('node:rotate:mouseup', evt, view);\n        }\n      }\n    }\n  }, {\n    key: \"startHandle\",\n    value: function startHandle(handle) {\n      this.handle = handle || null;\n      this.$container.addClass(\"\".concat(this.containerClassName, \"-active\"));\n\n      if (handle) {\n        this.$(handle).addClass(\"\".concat(this.containerClassName, \"-active-handle\"));\n        var pos = handle.getAttribute('data-position');\n\n        if (pos) {\n          var dir = Private.DIRECTIONS[Private.POSITIONS.indexOf(pos)];\n          this.$container.addClass(\"\".concat(this.containerClassName, \"-cursor-\").concat(dir));\n        }\n      }\n    }\n  }, {\n    key: \"stopHandle\",\n    value: function stopHandle() {\n      this.$container.removeClass(\"\".concat(this.containerClassName, \"-active\"));\n\n      if (this.handle) {\n        this.$(this.handle).removeClass(\"\".concat(this.containerClassName, \"-active-handle\"));\n        var pos = this.handle.getAttribute('data-position');\n\n        if (pos) {\n          var dir = Private.DIRECTIONS[Private.POSITIONS.indexOf(pos)];\n          this.$container.removeClass(\"\".concat(this.containerClassName, \"-cursor-\").concat(dir));\n        }\n\n        this.handle = null;\n      }\n    }\n  }, {\n    key: \"startAction\",\n    value: function startAction(evt) {\n      this.startHandle(evt.target);\n      this.graph.view.undelegateEvents();\n      this.delegateDocumentEvents(Private.documentEvents, evt.data);\n    }\n  }, {\n    key: \"stopAction\",\n    value: function stopAction(evt) {\n      this.stopHandle();\n      this.undelegateDocumentEvents();\n      this.graph.view.delegateEvents();\n      var view = this.graph.findViewByCell(this.node);\n      var data = this.getEventData(evt);\n\n      if (view) {\n        view.removeClass(\"node-\".concat(data.action));\n\n        if (data.action === 'resizing' && data.resized) {\n          notify('node:resized', evt, view);\n        } else if (data.action === 'rotating' && data.rotated) {\n          notify('node:rotated', evt, view);\n        }\n      }\n    }\n  }, {\n    key: \"node\",\n    get: function get() {\n      return this.cell;\n    }\n  }, {\n    key: \"containerClassName\",\n    get: function get() {\n      return this.prefixClassName('widget-transform');\n    }\n  }, {\n    key: \"resizeClassName\",\n    get: function get() {\n      return \"\".concat(this.containerClassName, \"-resize\");\n    }\n  }, {\n    key: \"rotateClassName\",\n    get: function get() {\n      return \"\".concat(this.containerClassName, \"-rotate\");\n    }\n  }]);\n\n  return Transform;\n}(Widget);\nvar Private;\n\n(function (Private) {\n  Private.NODE_CLS = 'has-widget-transform';\n  Private.DIRECTIONS = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];\n  Private.POSITIONS = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];\n  Private.documentEvents = {\n    mousemove: 'onMouseMove',\n    touchmove: 'onMouseMove',\n    mouseup: 'onMouseUp',\n    touchend: 'onMouseUp'\n  };\n  Private.defaultOptions = {\n    minWidth: 0,\n    minHeight: 0,\n    maxWidth: Infinity,\n    maxHeight: Infinity,\n    rotateGrid: 15,\n    rotatable: true,\n    preserveAspectRatio: false,\n    orthogonalResizing: true,\n    restrictedResizing: false,\n    autoScrollOnResizing: true,\n    allowReverse: true\n  };\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}