{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport { edgeArgsToId, isFunction } from '../util';\nimport { GraphEnum } from '../enum';\nimport { decrementOrRemoveEntry, edgeArgsToObj, edgeObjToId, incrementOrInitEntry } from '../util';\nimport { read, write } from './toJSON';\nvar defaultOption = {\n  compound: false,\n  multigraph: false,\n  directed: true\n};\n\nvar Graph = /*#__PURE__*/_createClass( // Graph option or basic props\n\n/**\n * @description Label for this graph itself\n * @description.zh-CN 图本身的标签（label）\n * @default undefined\n */\n\n/**\n * @description Number of nodes in the graph\n * @description.zh-CN 节点的数量\n * @default 0\n */\n\n/**\n * @description Number of edges in the graph\n * @description.zh-CN 节点的数量\n * @default 0\n */\nfunction Graph() {\n  var _this = this;\n\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  _classCallCheck(this, Graph);\n\n  this.directed = true;\n  this.multigraph = false;\n  this.compound = false;\n  this.GRAPH_NODE = GraphEnum.GRAPH_NODE;\n  this.label = void 0;\n  this.nodeCountNum = 0;\n  this.edgeCountNum = 0;\n\n  this.defaultNodeLabelFn = function () {\n    return undefined;\n  };\n\n  this.defaultEdgeLabelFn = function () {\n    return undefined;\n  };\n\n  this.parentMap = void 0;\n  this.childrenMap = void 0;\n  this.nodesLabelMap = new Map();\n  this.inEdgesMap = new Map();\n  this.outEdgesMap = new Map();\n  this.predecessorsMap = new Map();\n  this.successorsMap = new Map();\n  this.edgesMap = new Map();\n  this.edgesLabelsMap = new Map();\n\n  this.isDirected = function () {\n    return _this.directed;\n  };\n\n  this.isMultigraph = function () {\n    return _this.multigraph;\n  };\n\n  this.isCompound = function () {\n    return _this.compound;\n  };\n\n  this.setGraph = function (label) {\n    _this.label = label;\n    return _this;\n  };\n\n  this.graph = function () {\n    return _this.label;\n  };\n\n  this.setDefaultNodeLabel = function (newDefault) {\n    if (isFunction(newDefault)) {\n      _this.defaultNodeLabelFn = newDefault;\n    } else {\n      _this.defaultNodeLabelFn = function () {\n        return newDefault;\n      };\n    }\n\n    return _this;\n  };\n\n  this.nodeCount = function () {\n    return _this.nodeCountNum;\n  };\n\n  this.node = function (n) {\n    return _this.nodesLabelMap.get(n);\n  };\n\n  this.nodes = function () {\n    return Array.from(_this.nodesLabelMap.keys());\n  };\n\n  this.sources = function () {\n    return _this.nodes().filter(function (n) {\n      var _this$inEdgesMap$get;\n\n      return !((_this$inEdgesMap$get = _this.inEdgesMap.get(n)) === null || _this$inEdgesMap$get === void 0 ? void 0 : _this$inEdgesMap$get.size);\n    });\n  };\n\n  this.sinks = function () {\n    return _this.nodes().filter(function (n) {\n      var _this$outEdgesMap$get;\n\n      return !((_this$outEdgesMap$get = _this.outEdgesMap.get(n)) === null || _this$outEdgesMap$get === void 0 ? void 0 : _this$outEdgesMap$get.size);\n    });\n  };\n\n  this.setNode = function (node, value) {\n    var nodesLabelMap = _this.nodesLabelMap,\n        defaultNodeLabelFn = _this.defaultNodeLabelFn,\n        isCompound = _this.isCompound,\n        parentMap = _this.parentMap,\n        childrenMap = _this.childrenMap,\n        inEdgesMap = _this.inEdgesMap,\n        outEdgesMap = _this.outEdgesMap,\n        predecessorsMap = _this.predecessorsMap,\n        successorsMap = _this.successorsMap;\n\n    if (nodesLabelMap.has(node)) {\n      if (value !== undefined) {\n        nodesLabelMap.set(node, value);\n      }\n\n      return _this;\n    }\n\n    nodesLabelMap.set(node, value || defaultNodeLabelFn(node));\n\n    if (isCompound()) {\n      var _childrenMap$get;\n\n      parentMap === null || parentMap === void 0 ? void 0 : parentMap.set(node, _this.GRAPH_NODE);\n      childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(node, new Map());\n\n      if (!(childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.has(_this.GRAPH_NODE))) {\n        childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(_this.GRAPH_NODE, new Map());\n      }\n\n      childrenMap === null || childrenMap === void 0 ? void 0 : (_childrenMap$get = childrenMap.get(_this.GRAPH_NODE)) === null || _childrenMap$get === void 0 ? void 0 : _childrenMap$get.set(node, true);\n    }\n\n    [inEdgesMap, outEdgesMap, predecessorsMap, successorsMap].forEach(function (map) {\n      return map.set(node, new Map());\n    });\n    _this.nodeCountNum += 1;\n    return _this;\n  };\n\n  this.setNodes = function (nodes, value) {\n    nodes.map(function (node) {\n      return _this.setNode(node, value);\n    });\n    return _this;\n  };\n\n  this.hasNode = function (node) {\n    return _this.nodesLabelMap.has(node);\n  };\n\n  this.checkCompound = function () {\n    if (!_this.isCompound()) {\n      throw new Error('Cannot construct parent-children relations in a non-compound graph');\n    }\n  };\n\n  this.parent = function (node) {\n    if (_this.isCompound()) {\n      var _this$parentMap;\n\n      var parent = (_this$parentMap = _this.parentMap) === null || _this$parentMap === void 0 ? void 0 : _this$parentMap.get(node);\n\n      if (parent !== _this.GRAPH_NODE) {\n        return parent;\n      }\n    }\n  };\n\n  this.removeFromParentsChildList = function (node) {\n    var targetParent = _this.parentMap.get(node);\n\n    _this.childrenMap.get(targetParent).delete(node);\n  };\n\n  this.setParent = function (node, parent) {\n    var _this$parentMap2, _this$childrenMap;\n\n    _this.checkCompound();\n\n    var realParent = parent === undefined ? _this.GRAPH_NODE : parent;\n\n    var checkNode = _this.parent(realParent);\n\n    while (checkNode) {\n      if (node === checkNode) {\n        throw new Error('Setting ' + parent + ' as parent of ' + node + ' would create a cycle');\n      }\n\n      checkNode = _this.parent(checkNode);\n    }\n\n    if (parent) {\n      _this.setNode(parent);\n    }\n\n    _this.setNode(node);\n\n    _this.removeFromParentsChildList(node);\n\n    (_this$parentMap2 = _this.parentMap) === null || _this$parentMap2 === void 0 ? void 0 : _this$parentMap2.set(node, realParent);\n\n    var realParentChilren = _this.childrenMap.get(realParent);\n\n    realParentChilren.set(node, true);\n    (_this$childrenMap = _this.childrenMap) === null || _this$childrenMap === void 0 ? void 0 : _this$childrenMap.set(realParent, realParentChilren);\n    return _this;\n  };\n\n  this.children = function (node) {\n    var targetNode = node === undefined ? _this.GRAPH_NODE : node;\n\n    if (_this.isCompound()) {\n      var _this$childrenMap2;\n\n      var target = (_this$childrenMap2 = _this.childrenMap) === null || _this$childrenMap2 === void 0 ? void 0 : _this$childrenMap2.get(targetNode);\n\n      if (target) {\n        return Array.from(target.keys());\n      }\n\n      return undefined;\n    }\n\n    if (targetNode === _this.GRAPH_NODE) {\n      return _this.nodes();\n    }\n\n    if (node && _this.hasNode(node)) {\n      return [];\n    }\n  };\n\n  this.predecessors = function (node) {\n    var preds = _this.predecessorsMap.get(node);\n\n    return preds ? Array.from(preds.keys()) : undefined;\n  };\n\n  this.successors = function (node) {\n    var succs = _this.successorsMap.get(node);\n\n    return succs ? Array.from(succs.keys()) : undefined;\n  };\n\n  this.neighbors = function (node) {\n    var _this$predecessors;\n\n    if (!_this.hasNode(node)) {\n      return undefined;\n    }\n\n    return Array.from(new Set((_this$predecessors = _this.predecessors(node)) === null || _this$predecessors === void 0 ? void 0 : _this$predecessors.concat(_this.successors(node))));\n  };\n\n  this.isLeaf = function (node) {\n    var _this$neighbors;\n\n    if (_this.isDirected()) {\n      var _this$successors;\n\n      return !((_this$successors = _this.successors(node)) === null || _this$successors === void 0 ? void 0 : _this$successors.length);\n    }\n\n    return !((_this$neighbors = _this.neighbors(node)) === null || _this$neighbors === void 0 ? void 0 : _this$neighbors.length);\n  };\n\n  this.filterNodes = function (filter) {\n    var directed = _this.directed,\n        multigraph = _this.multigraph,\n        compound = _this.compound;\n    var copyGraph = new Graph({\n      directed: directed,\n      multigraph: multigraph,\n      compound: compound\n    });\n    copyGraph.setGraph(_this.graph());\n\n    _this.nodes().forEach(function (n) {\n      if (filter(n)) {\n        copyGraph.setNode(n, _this.node(n));\n      }\n    });\n\n    _this.edges().forEach(function (edgeObj) {\n      if (copyGraph.hasNode(edgeObj.v) && copyGraph.hasNode(edgeObj.w)) {\n        copyGraph.setEdgeObj(edgeObj, _this.edge(edgeObj));\n      }\n    });\n\n    if (compound) {\n      var findParent = function findParent(node) {\n        var parent = _this.parent(node);\n\n        while (parent !== undefined && !copyGraph.hasNode(parent)) {\n          parent = _this.parent(parent);\n        }\n\n        return parent;\n      };\n\n      copyGraph.nodes().forEach(function (node) {\n        copyGraph.setParent(node, findParent(node));\n      });\n    }\n\n    return copyGraph;\n  };\n\n  this.removeNode = function (node) {\n    if (_this.hasNode(node)) {\n      var cleanEdge = function cleanEdge(edgeObj) {\n        _this.removeEdge(edgeObj.v, edgeObj.w, edgeObj.name);\n      };\n\n      var inEdgesMap = _this.inEdgesMap,\n          outEdgesMap = _this.outEdgesMap,\n          predecessorsMap = _this.predecessorsMap,\n          successorsMap = _this.successorsMap,\n          nodesLabelMap = _this.nodesLabelMap;\n\n      if (_this.isCompound()) {\n        var _this$parentMap3, _this$children, _this$childrenMap3;\n\n        _this.removeFromParentsChildList(node);\n\n        (_this$parentMap3 = _this.parentMap) === null || _this$parentMap3 === void 0 ? void 0 : _this$parentMap3.delete(node);\n        (_this$children = _this.children(node)) === null || _this$children === void 0 ? void 0 : _this$children.forEach(function (n) {\n          return _this.setParent(n);\n        });\n        (_this$childrenMap3 = _this.childrenMap) === null || _this$childrenMap3 === void 0 ? void 0 : _this$childrenMap3.delete(node);\n      }\n\n      var inE = inEdgesMap.get(node);\n      var outE = outEdgesMap.get(node);\n      Array.from(inE.values()).forEach(function (edge) {\n        return cleanEdge(edge);\n      });\n      Array.from(outE.values()).forEach(function (edge) {\n        return cleanEdge(edge);\n      });\n      nodesLabelMap.delete(node);\n      inEdgesMap.delete(node);\n      outEdgesMap.delete(node);\n      predecessorsMap.delete(node);\n      successorsMap.delete(node);\n      _this.nodeCountNum -= 1;\n    }\n\n    return _this;\n  };\n\n  this.setDefaultEdgeLabel = function (newDefault) {\n    if (isFunction(newDefault)) {\n      _this.defaultEdgeLabelFn = newDefault;\n    } else {\n      _this.defaultEdgeLabelFn = function () {\n        return newDefault;\n      };\n    }\n\n    return _this;\n  };\n\n  this.edgeCount = function () {\n    return _this.edgeCountNum;\n  };\n\n  this.setEdge = function (v_, w_, value, name) {\n    var _this$inEdgesMap$get2, _this$outEdgesMap$get2;\n\n    var edgeObj = edgeArgsToObj(_this.isDirected(), v_, w_, name);\n    var edgeId = edgeObjToId(_this.isDirected(), edgeObj);\n    var v = edgeObj.v,\n        w = edgeObj.w;\n\n    if (_this.edgesLabelsMap.has(edgeId)) {\n      _this.edgesLabelsMap.set(edgeId, value);\n\n      return _this;\n    }\n\n    if (name !== undefined && !_this.isMultigraph()) {\n      throw new Error('Cannot set a named edge when isMultigraph = false');\n    }\n\n    _this.setNode(v);\n\n    _this.setNode(w);\n\n    _this.edgesLabelsMap.set(edgeId, value || _this.defaultEdgeLabelFn(v, w, name));\n\n    Object.freeze(edgeObj);\n\n    _this.edgesMap.set(edgeId, edgeObj);\n\n    var preds = _this.predecessorsMap.get(w);\n\n    var succs = _this.successorsMap.get(v);\n\n    incrementOrInitEntry(preds, v);\n    incrementOrInitEntry(succs, w);\n    (_this$inEdgesMap$get2 = _this.inEdgesMap.get(w)) === null || _this$inEdgesMap$get2 === void 0 ? void 0 : _this$inEdgesMap$get2.set(edgeId, edgeObj);\n    (_this$outEdgesMap$get2 = _this.outEdgesMap.get(v)) === null || _this$outEdgesMap$get2 === void 0 ? void 0 : _this$outEdgesMap$get2.set(edgeId, edgeObj);\n    _this.edgeCountNum += 1;\n    return _this;\n  };\n\n  this.setEdgeObj = function (edgeObj, value) {\n    return _this.setEdge(edgeObj.v, edgeObj.w, value, edgeObj.name);\n  };\n\n  this.setPath = function (edges, value) {\n    edges.reduce(function (v, w) {\n      _this.setEdge(v, w, value);\n\n      return w;\n    });\n    return _this;\n  };\n\n  this.edgeFromArgs = function (v, w, name) {\n    return _this.edge({\n      v: v,\n      w: w,\n      name: name\n    });\n  };\n\n  this.edge = function (edgeObj) {\n    return _this.edgesLabelsMap.get(edgeObjToId(_this.isDirected(), edgeObj));\n  };\n\n  this.hasEdge = function (v, w, name) {\n    return _this.edgesLabelsMap.has(edgeObjToId(_this.isDirected(), {\n      v: v,\n      w: w,\n      name: name\n    }));\n  };\n\n  this.removeEdge = function (v_, w_, name) {\n    var edgeId = edgeArgsToId(_this.isDirected(), v_, w_, name);\n\n    var edgeObj = _this.edgesMap.get(edgeId);\n\n    if (edgeObj) {\n      var _edgeArgsToObj = edgeArgsToObj(_this.isDirected(), v_, w_, name),\n          v = _edgeArgsToObj.v,\n          w = _edgeArgsToObj.w;\n\n      _this.edgesLabelsMap.delete(edgeId);\n\n      _this.edgesMap.delete(edgeId);\n\n      var preds = _this.predecessorsMap.get(w);\n\n      var succs = _this.successorsMap.get(v);\n\n      decrementOrRemoveEntry(preds, v);\n      decrementOrRemoveEntry(succs, w);\n\n      _this.inEdgesMap.get(w).delete(edgeId);\n\n      _this.outEdgesMap.get(v).delete(edgeId);\n\n      _this.edgeCountNum -= 1;\n    }\n\n    return _this;\n  };\n\n  this.removeEdgeObj = function (_ref) {\n    var v = _ref.v,\n        w = _ref.w,\n        name = _ref.name;\n    return _this.removeEdge(v, w, name);\n  };\n\n  this.edges = function () {\n    return Array.from(_this.edgesMap.values());\n  };\n\n  this.inEdges = function (v, u) {\n    var inV = _this.inEdgesMap.get(v);\n\n    if (inV) {\n      return Array.from(inV.values()).filter(function (e) {\n        return !u || e.v === u;\n      });\n    }\n\n    return undefined;\n  };\n\n  this.outEdges = function (w, u) {\n    var outW = _this.outEdgesMap.get(w);\n\n    if (outW) {\n      return Array.from(outW.values()).filter(function (e) {\n        return !u || e.w === u;\n      });\n    }\n\n    return undefined;\n  };\n\n  this.nodeEdges = function (v, w) {\n    var _this$inEdges;\n\n    if (!_this.hasNode(v)) {\n      return undefined;\n    }\n\n    return (_this$inEdges = _this.inEdges(v, w)) === null || _this$inEdges === void 0 ? void 0 : _this$inEdges.concat(_this.outEdges(v, w));\n  };\n\n  this.toJSON = function () {\n    return write(_this);\n  };\n\n  var resultOptions = _objectSpread(_objectSpread({}, defaultOption), options);\n\n  this.compound = resultOptions.compound;\n  this.directed = resultOptions.directed;\n  this.multigraph = resultOptions.multigraph;\n\n  if (this.compound) {\n    this.parentMap = new Map();\n    this.childrenMap = new Map();\n  }\n} // Map for graph\n);\n\nGraph.fromJSON = read;\nexport { Graph as default };","map":null,"metadata":{},"sourceType":"module"}