{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nvar LuDecomposition = /*#__PURE__*/function () {\n  function LuDecomposition(matrix) {\n    _classCallCheck(this, LuDecomposition);\n\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\n    var lu = matrix.clone();\n    var rows = lu.rows;\n    var columns = lu.columns;\n    var pivotVector = new Float64Array(rows);\n    var pivotSign = 1;\n    var i, j, k, p, s, t, v;\n    var LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n      pivotVector[i] = i;\n    }\n\n    LUcolj = new Float64Array(rows);\n\n    for (j = 0; j < columns; j++) {\n      for (i = 0; i < rows; i++) {\n        LUcolj[i] = lu.get(i, j);\n      }\n\n      for (i = 0; i < rows; i++) {\n        kmax = Math.min(i, j);\n        s = 0;\n\n        for (k = 0; k < kmax; k++) {\n          s += lu.get(i, k) * LUcolj[k];\n        }\n\n        LUcolj[i] -= s;\n        lu.set(i, j, LUcolj[i]);\n      }\n\n      p = j;\n\n      for (i = j + 1; i < rows; i++) {\n        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n          p = i;\n        }\n      }\n\n      if (p !== j) {\n        for (k = 0; k < columns; k++) {\n          t = lu.get(p, k);\n          lu.set(p, k, lu.get(j, k));\n          lu.set(j, k, t);\n        }\n\n        v = pivotVector[p];\n        pivotVector[p] = pivotVector[j];\n        pivotVector[j] = v;\n        pivotSign = -pivotSign;\n      }\n\n      if (j < rows && lu.get(j, j) !== 0) {\n        for (i = j + 1; i < rows; i++) {\n          lu.set(i, j, lu.get(i, j) / lu.get(j, j));\n        }\n      }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n  }\n\n  _createClass(LuDecomposition, [{\n    key: \"isSingular\",\n    value: function isSingular() {\n      var data = this.LU;\n      var col = data.columns;\n\n      for (var j = 0; j < col; j++) {\n        if (data.get(j, j) === 0) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"solve\",\n    value: function solve(value) {\n      value = Matrix.checkMatrix(value);\n      var lu = this.LU;\n      var rows = lu.rows;\n\n      if (rows !== value.rows) {\n        throw new Error('Invalid matrix dimensions');\n      }\n\n      if (this.isSingular()) {\n        throw new Error('LU matrix is singular');\n      }\n\n      var count = value.columns;\n      var X = value.subMatrixRow(this.pivotVector, 0, count - 1);\n      var columns = lu.columns;\n      var i, j, k;\n\n      for (k = 0; k < columns; k++) {\n        for (i = k + 1; i < columns; i++) {\n          for (j = 0; j < count; j++) {\n            X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n          }\n        }\n      }\n\n      for (k = columns - 1; k >= 0; k--) {\n        for (j = 0; j < count; j++) {\n          X.set(k, j, X.get(k, j) / lu.get(k, k));\n        }\n\n        for (i = 0; i < k; i++) {\n          for (j = 0; j < count; j++) {\n            X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n          }\n        }\n      }\n\n      return X;\n    }\n  }, {\n    key: \"determinant\",\n    get: function get() {\n      var data = this.LU;\n\n      if (!data.isSquare()) {\n        throw new Error('Matrix must be square');\n      }\n\n      var determinant = this.pivotSign;\n      var col = data.columns;\n\n      for (var j = 0; j < col; j++) {\n        determinant *= data.get(j, j);\n      }\n\n      return determinant;\n    }\n  }, {\n    key: \"lowerTriangularMatrix\",\n    get: function get() {\n      var data = this.LU;\n      var rows = data.rows;\n      var columns = data.columns;\n      var X = new Matrix(rows, columns);\n\n      for (var i = 0; i < rows; i++) {\n        for (var j = 0; j < columns; j++) {\n          if (i > j) {\n            X.set(i, j, data.get(i, j));\n          } else if (i === j) {\n            X.set(i, j, 1);\n          } else {\n            X.set(i, j, 0);\n          }\n        }\n      }\n\n      return X;\n    }\n  }, {\n    key: \"upperTriangularMatrix\",\n    get: function get() {\n      var data = this.LU;\n      var rows = data.rows;\n      var columns = data.columns;\n      var X = new Matrix(rows, columns);\n\n      for (var i = 0; i < rows; i++) {\n        for (var j = 0; j < columns; j++) {\n          if (i <= j) {\n            X.set(i, j, data.get(i, j));\n          } else {\n            X.set(i, j, 0);\n          }\n        }\n      }\n\n      return X;\n    }\n  }, {\n    key: \"pivotPermutationVector\",\n    get: function get() {\n      return Array.from(this.pivotVector);\n    }\n  }]);\n\n  return LuDecomposition;\n}();\n\nexport { LuDecomposition as default };","map":null,"metadata":{},"sourceType":"module"}