{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nvar SPEED_DIVISOR = 800;\n\nvar RadialNonoverlapForce = /*#__PURE__*/function () {\n  function RadialNonoverlapForce(params) {\n    _classCallCheck(this, RadialNonoverlapForce);\n\n    this.disp = [];\n    this.positions = params.positions;\n    this.adjMatrix = params.adjMatrix;\n    this.focusID = params.focusID;\n    this.radii = params.radii;\n    this.iterations = params.iterations || 10;\n    this.height = params.height || 10;\n    this.width = params.width || 10;\n    this.speed = params.speed || 100;\n    this.gravity = params.gravity || 10;\n    this.nodeSizeFunc = params.nodeSizeFunc;\n    this.k = params.k || 5;\n    this.strictRadial = params.strictRadial;\n    this.nodes = params.nodes;\n  }\n\n  _createClass(RadialNonoverlapForce, [{\n    key: \"layout\",\n    value: function layout() {\n      var self = this;\n      var positions = self.positions;\n      var disp = [];\n      var iterations = self.iterations;\n      var maxDisplace = self.width / 10;\n      self.maxDisplace = maxDisplace;\n      self.disp = disp;\n\n      for (var i = 0; i < iterations; i++) {\n        positions.forEach(function (_, k) {\n          disp[k] = {\n            x: 0,\n            y: 0\n          };\n        }); // 给重叠的节点增加斥力\n\n        self.getRepulsion();\n        self.updatePositions();\n      }\n\n      return positions;\n    }\n  }, {\n    key: \"getRepulsion\",\n    value: function getRepulsion() {\n      var self = this;\n      var positions = self.positions;\n      var nodes = self.nodes;\n      var disp = self.disp;\n      var k = self.k;\n      var radii = self.radii || [];\n      positions.forEach(function (v, i) {\n        disp[i] = {\n          x: 0,\n          y: 0\n        };\n        positions.forEach(function (u, j) {\n          if (i === j) {\n            return;\n          } // v and u are not on the same circle, return\n\n\n          if (radii[i] !== radii[j]) {\n            return;\n          }\n\n          var vecx = v[0] - u[0];\n          var vecy = v[1] - u[1];\n          var vecLength = Math.sqrt(vecx * vecx + vecy * vecy);\n\n          if (vecLength === 0) {\n            vecLength = 1;\n            var sign = i > j ? 1 : -1;\n            vecx = 0.01 * sign;\n            vecy = 0.01 * sign;\n          } // these two nodes overlap\n\n\n          if (vecLength < self.nodeSizeFunc(nodes[i]) / 2 + self.nodeSizeFunc(nodes[j]) / 2) {\n            var common = k * k / vecLength;\n            disp[i].x += vecx / vecLength * common;\n            disp[i].y += vecy / vecLength * common;\n          }\n        });\n      });\n    }\n  }, {\n    key: \"updatePositions\",\n    value: function updatePositions() {\n      var self = this;\n      var positions = self.positions;\n      var disp = self.disp;\n      var speed = self.speed;\n      var strictRadial = self.strictRadial;\n      var f = self.focusID;\n      var maxDisplace = self.maxDisplace || self.width / 10;\n\n      if (strictRadial) {\n        disp.forEach(function (di, i) {\n          var vx = positions[i][0] - positions[f][0];\n          var vy = positions[i][1] - positions[f][1];\n          var vLength = Math.sqrt(vx * vx + vy * vy);\n          var vpx = vy / vLength;\n          var vpy = -vx / vLength;\n          var diLength = Math.sqrt(di.x * di.x + di.y * di.y);\n          var alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);\n\n          if (alpha > Math.PI / 2) {\n            alpha -= Math.PI / 2;\n            vpx *= -1;\n            vpy *= -1;\n          }\n\n          var tdispLength = Math.cos(alpha) * diLength;\n          di.x = vpx * tdispLength;\n          di.y = vpy * tdispLength;\n        });\n      } // move\n\n\n      var radii = self.radii;\n      positions.forEach(function (n, i) {\n        if (i === f) {\n          return;\n        }\n\n        var distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);\n\n        if (distLength > 0 && i !== f) {\n          var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n          n[0] += disp[i].x / distLength * limitedDist;\n          n[1] += disp[i].y / distLength * limitedDist;\n\n          if (strictRadial) {\n            var vx = n[0] - positions[f][0];\n            var vy = n[1] - positions[f][1];\n            var nfDis = Math.sqrt(vx * vx + vy * vy);\n            vx = vx / nfDis * radii[i];\n            vy = vy / nfDis * radii[i];\n            n[0] = positions[f][0] + vx;\n            n[1] = positions[f][1] + vy;\n          }\n        }\n      });\n    }\n  }]);\n\n  return RadialNonoverlapForce;\n}();\n\nexport { RadialNonoverlapForce as default };","map":null,"metadata":{},"sourceType":"module"}