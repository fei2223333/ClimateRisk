{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @fileOverview grid layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { isString, isArray, isNumber, getDegree, isNaN, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 网格布局\n */\n\nexport var GridLayout = /*#__PURE__*/function (_Base) {\n  _inherits(GridLayout, _Base);\n\n  function GridLayout(options) {\n    var _this;\n\n    _classCallCheck(this, GridLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GridLayout).call(this));\n    /** 布局起始点 */\n\n    _this.begin = [0, 0];\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = true;\n    /** extra spacing around nodes when preventOverlap: true */\n\n    _this.preventOverlapPadding = 10;\n    /** uses all available space on false, uses minimal space on true */\n\n    _this.condense = false;\n    /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */\n\n    _this.sortBy = \"degree\";\n    _this.nodeSize = 30;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.row = 0;\n    _this.col = 0;\n    _this.cellWidth = 0;\n    _this.cellHeight = 0;\n    _this.cellUsed = {};\n    _this.id2manPos = {};\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(GridLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        begin: [0, 0],\n        preventOverlap: true,\n        preventOverlapPadding: 10,\n        condense: false,\n        rows: undefined,\n        cols: undefined,\n        position: undefined,\n        sortBy: \"degree\",\n        nodeSize: 30\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges;\n      var n = nodes.length;\n      var begin = self.begin;\n\n      if (n === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return {\n          nodes: nodes,\n          edges: edges\n        };\n      }\n\n      if (n === 1) {\n        nodes[0].x = begin[0];\n        nodes[0].y = begin[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return {\n          nodes: nodes,\n          edges: edges\n        };\n      }\n\n      var layoutNodes = [];\n      nodes.forEach(function (node) {\n        layoutNodes.push(node);\n      });\n      var nodeIdxMap = {};\n      layoutNodes.forEach(function (node, i) {\n        nodeIdxMap[node.id] = i;\n      });\n\n      if (self.sortBy === \"degree\" || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n        self.sortBy = \"degree\";\n\n        if (isNaN(nodes[0].degree)) {\n          var values = getDegree(layoutNodes.length, nodeIdxMap, edges);\n          layoutNodes.forEach(function (node, i) {\n            node.degree = values[i];\n          });\n        }\n      } // sort nodes by value\n\n\n      layoutNodes.sort(function (n1, n2) {\n        return n2[self.sortBy] - n1[self.sortBy];\n      });\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      var oRows = self.rows;\n      var oCols = self.cols != null ? self.cols : self.columns;\n      self.cells = n; // if rows or columns were set in self, use those values\n\n      if (oRows != null && oCols != null) {\n        self.rows = oRows;\n        self.cols = oCols;\n      } else if (oRows != null && oCols == null) {\n        self.rows = oRows;\n        self.cols = Math.ceil(self.cells / self.rows);\n      } else if (oRows == null && oCols != null) {\n        self.cols = oCols;\n        self.rows = Math.ceil(self.cells / self.cols);\n      } else {\n        // otherwise use the automatic values and adjust accordingly\t      // otherwise use the automatic values and adjust accordingly\n        // width/height * splits^2 = cells where splits is number of times to split width\n        self.splits = Math.sqrt(self.cells * self.height / self.width);\n        self.rows = Math.round(self.splits);\n        self.cols = Math.round(self.width / self.height * self.splits);\n      }\n\n      if (self.cols * self.rows > self.cells) {\n        // otherwise use the automatic values and adjust accordingly\n        // if rounding was up, see if we can reduce rows or columns\n        var sm = self.small();\n        var lg = self.large(); // reducing the small side takes away the most cells, so try it first\n\n        if ((sm - 1) * lg >= self.cells) {\n          self.small(sm - 1);\n        } else if ((lg - 1) * sm >= self.cells) {\n          self.large(lg - 1);\n        }\n      } else {\n        // if rounding was too low, add rows or columns\n        while (self.cols * self.rows < self.cells) {\n          var _sm = self.small();\n\n          var _lg = self.large(); // try to add to larger side first (adds less in multiplication)\n\n\n          if ((_lg + 1) * _sm >= self.cells) {\n            self.large(_lg + 1);\n          } else {\n            self.small(_sm + 1);\n          }\n        }\n      }\n\n      self.cellWidth = self.width / self.cols;\n      self.cellHeight = self.height / self.rows;\n\n      if (self.condense) {\n        self.cellWidth = 0;\n        self.cellHeight = 0;\n      }\n\n      if (self.preventOverlap) {\n        layoutNodes.forEach(function (node) {\n          if (!node.x || !node.y) {\n            // for bb\n            node.x = 0;\n            node.y = 0;\n          }\n\n          var nodew;\n          var nodeh;\n\n          if (isArray(node.size)) {\n            nodew = node.size[0];\n            nodeh = node.size[1];\n          } else if (isNumber(node.size)) {\n            nodew = node.size;\n            nodeh = node.size;\n          } else if (isObject(node.size)) {\n            nodew = node.size.width;\n            nodeh = node.size.height;\n          }\n\n          if (nodew === undefined || nodeh === undefined) {\n            if (isArray(self.nodeSize)) {\n              nodew = self.nodeSize[0];\n              nodeh = self.nodeSize[1];\n            } else if (isNumber(self.nodeSize)) {\n              nodew = self.nodeSize;\n              nodeh = self.nodeSize;\n            } else {\n              nodew = 30;\n              nodeh = 30;\n            }\n          }\n\n          var p = self.preventOverlapPadding;\n          var w = nodew + p;\n          var h = nodeh + p;\n          self.cellWidth = Math.max(self.cellWidth, w);\n          self.cellHeight = Math.max(self.cellHeight, h);\n        });\n      }\n\n      self.cellUsed = {}; // e.g. 'c-0-2' => true\n      // to keep track of current cell position\n\n      self.row = 0;\n      self.col = 0; // get a cache of all the manual positions\n\n      self.id2manPos = {};\n\n      for (var i = 0; i < layoutNodes.length; i++) {\n        var node = layoutNodes[i];\n        var rcPos = void 0;\n\n        if (self.position) {\n          rcPos = self.position(node);\n        }\n\n        if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n          // must have at least row or col def'd\n          var pos = {\n            row: rcPos.row,\n            col: rcPos.col\n          };\n\n          if (pos.col === undefined) {\n            // find unused col\n            pos.col = 0;\n\n            while (self.used(pos.row, pos.col)) {\n              pos.col++;\n            }\n          } else if (pos.row === undefined) {\n            // find unused row\n            pos.row = 0;\n\n            while (self.used(pos.row, pos.col)) {\n              pos.row++;\n            }\n          }\n\n          self.id2manPos[node.id] = pos;\n          self.use(pos.row, pos.col);\n        }\n\n        self.getPos(node);\n      }\n\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        edges: edges,\n        nodes: layoutNodes\n      };\n    }\n  }, {\n    key: \"small\",\n    value: function small(val) {\n      var self = this;\n      var res;\n      var rows = self.rows || 5;\n      var cols = self.cols || 5;\n\n      if (val == null) {\n        res = Math.min(rows, cols);\n      } else {\n        var min = Math.min(rows, cols);\n\n        if (min === self.rows) {\n          self.rows = val;\n        } else {\n          self.cols = val;\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"large\",\n    value: function large(val) {\n      var self = this;\n      var res;\n      var rows = self.rows || 5;\n      var cols = self.cols || 5;\n\n      if (val == null) {\n        res = Math.max(rows, cols);\n      } else {\n        var max = Math.max(rows, cols);\n\n        if (max === self.rows) {\n          self.rows = val;\n        } else {\n          self.cols = val;\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"used\",\n    value: function used(row, col) {\n      var self = this;\n      return self.cellUsed[\"c-\".concat(row, \"-\").concat(col)] || false;\n    }\n  }, {\n    key: \"use\",\n    value: function use(row, col) {\n      var self = this;\n      self.cellUsed[\"c-\".concat(row, \"-\").concat(col)] = true;\n    }\n  }, {\n    key: \"moveToNextCell\",\n    value: function moveToNextCell() {\n      var self = this;\n      var cols = self.cols || 5;\n      self.col++;\n\n      if (self.col >= cols) {\n        self.col = 0;\n        self.row++;\n      }\n    }\n  }, {\n    key: \"getPos\",\n    value: function getPos(node) {\n      var self = this;\n      var begin = self.begin;\n      var cellWidth = self.cellWidth;\n      var cellHeight = self.cellHeight;\n      var x;\n      var y; // see if we have a manual position set\n\n      var rcPos = self.id2manPos[node.id];\n\n      if (rcPos) {\n        x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];\n        y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];\n      } else {\n        // otherwise set automatically\n        while (self.used(self.row, self.col)) {\n          self.moveToNextCell();\n        }\n\n        x = self.col * cellWidth + cellWidth / 2 + begin[0];\n        y = self.row * cellHeight + cellHeight / 2 + begin[1];\n        self.use(self.row, self.col);\n        self.moveToNextCell();\n      }\n\n      node.x = x;\n      node.y = y;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"grid\";\n    }\n  }]);\n\n  return GridLayout;\n}(Base);","map":null,"metadata":{},"sourceType":"module"}