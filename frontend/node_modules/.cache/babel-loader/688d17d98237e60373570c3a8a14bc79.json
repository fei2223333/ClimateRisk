{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Dom, ObjectExt, FunctionExt } from '../../util';\nimport { Point, Line } from '../../geometry';\nimport { View } from '../../view/view';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\nexport var Segments = /*#__PURE__*/function (_ToolsView$ToolItem) {\n  _inherits(Segments, _ToolsView$ToolItem);\n\n  function Segments() {\n    var _this;\n\n    _classCallCheck(this, Segments);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Segments).apply(this, arguments));\n    _this.handles = [];\n    return _this;\n  }\n\n  _createClass(Segments, [{\n    key: \"update\",\n    value: function update() {\n      this.render();\n      return this;\n    }\n  }, {\n    key: \"onRender\",\n    value: function onRender() {\n      Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'));\n      this.resetHandles();\n      var edgeView = this.cellView;\n\n      var vertices = _toConsumableArray(this.vertices);\n\n      vertices.unshift(edgeView.sourcePoint);\n      vertices.push(edgeView.targetPoint);\n\n      for (var i = 0, l = vertices.length; i < l - 1; i += 1) {\n        var vertex = vertices[i];\n        var nextVertex = vertices[i + 1];\n        var handle = this.renderHandle(vertex, nextVertex, i);\n        this.stamp(handle.container);\n        this.handles.push(handle);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"renderHandle\",\n    value: function renderHandle(vertex, nextVertex, index) {\n      var _this2 = this;\n\n      var handle = this.options.createHandle({\n        index: index,\n        graph: this.graph,\n        guard: function guard(evt) {\n          return _this2.guard(evt);\n        },\n        attrs: this.options.attrs || {}\n      });\n\n      if (this.options.processHandle) {\n        this.options.processHandle(handle);\n      }\n\n      this.graph.hook.onToolItemCreated({\n        name: 'segments',\n        cell: this.cell,\n        view: this.cellView,\n        tool: handle\n      });\n      this.updateHandle(handle, vertex, nextVertex);\n      this.container.appendChild(handle.container);\n      this.startHandleListening(handle);\n      return handle;\n    }\n  }, {\n    key: \"startHandleListening\",\n    value: function startHandleListening(handle) {\n      handle.on('change', this.onHandleChange, this);\n      handle.on('changing', this.onHandleChanging, this);\n      handle.on('changed', this.onHandleChanged, this);\n    }\n  }, {\n    key: \"stopHandleListening\",\n    value: function stopHandleListening(handle) {\n      handle.off('change', this.onHandleChange, this);\n      handle.off('changing', this.onHandleChanging, this);\n      handle.off('changed', this.onHandleChanged, this);\n    }\n  }, {\n    key: \"resetHandles\",\n    value: function resetHandles() {\n      var _this3 = this;\n\n      var handles = this.handles;\n      this.handles = [];\n\n      if (handles) {\n        handles.forEach(function (handle) {\n          _this3.stopHandleListening(handle);\n\n          handle.remove();\n        });\n      }\n    }\n  }, {\n    key: \"shiftHandleIndexes\",\n    value: function shiftHandleIndexes(delta) {\n      var handles = this.handles;\n\n      for (var i = 0, n = handles.length; i < n; i += 1) {\n        handles[i].options.index += delta;\n      }\n    }\n  }, {\n    key: \"resetAnchor\",\n    value: function resetAnchor(type, anchor) {\n      var edge = this.cellView.cell;\n      var options = {\n        ui: true,\n        toolId: this.cid\n      };\n\n      if (anchor) {\n        edge.prop([type, 'anchor'], anchor, options);\n      } else {\n        edge.removeProp([type, 'anchor'], options);\n      }\n    }\n  }, {\n    key: \"snapHandle\",\n    value: function snapHandle(handle, position, data) {\n      var axis = handle.options.axis;\n      var index = handle.options.index;\n      var edgeView = this.cellView;\n      var edge = edgeView.cell;\n      var vertices = edge.getVertices();\n      var prev = vertices[index - 2] || data.sourceAnchor;\n      var next = vertices[index + 1] || data.targetAnchor;\n      var snapRadius = this.options.snapRadius;\n\n      if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n        position[axis] = prev[axis];\n      } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n        position[axis] = next[axis];\n      }\n\n      return position;\n    }\n  }, {\n    key: \"onHandleChanging\",\n    value: function onHandleChanging(_ref) {\n      var handle = _ref.handle,\n          e = _ref.e;\n      var graph = this.graph;\n      var options = this.options;\n      var edgeView = this.cellView;\n      var anchorFn = options.anchor;\n      var axis = handle.options.axis;\n      var index = handle.options.index - 1;\n      var data = this.getEventData(e);\n      var evt = this.normalizeEvent(e);\n      var coords = graph.snapToGrid(evt.clientX, evt.clientY);\n      var position = this.snapHandle(handle, coords.clone(), data);\n      var vertices = ObjectExt.cloneDeep(this.vertices);\n      var vertex = vertices[index];\n      var nextVertex = vertices[index + 1]; // First Segment\n\n      var sourceView = edgeView.sourceView;\n      var sourceBBox = edgeView.sourceBBox;\n      var changeSourceAnchor = false;\n      var deleteSourceAnchor = false;\n\n      if (!vertex) {\n        vertex = edgeView.sourceAnchor.toJSON();\n        vertex[axis] = position[axis];\n\n        if (sourceBBox.containsPoint(vertex)) {\n          changeSourceAnchor = true;\n        } else {\n          vertices.unshift(vertex);\n          this.shiftHandleIndexes(1);\n          deleteSourceAnchor = true;\n        }\n      } else if (index === 0) {\n        if (sourceBBox.containsPoint(vertex)) {\n          vertices.shift();\n          this.shiftHandleIndexes(-1);\n          changeSourceAnchor = true;\n        } else {\n          vertex[axis] = position[axis];\n          deleteSourceAnchor = true;\n        }\n      } else {\n        vertex[axis] = position[axis];\n      }\n\n      if (typeof anchorFn === 'function' && sourceView) {\n        if (changeSourceAnchor) {\n          var sourceAnchorPosition = data.sourceAnchor.clone();\n          sourceAnchorPosition[axis] = position[axis];\n          var sourceAnchor = FunctionExt.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);\n          this.resetAnchor('source', sourceAnchor);\n        }\n\n        if (deleteSourceAnchor) {\n          this.resetAnchor('source', data.sourceAnchorDef);\n        }\n      } // Last segment\n\n\n      var targetView = edgeView.targetView;\n      var targetBBox = edgeView.targetBBox;\n      var changeTargetAnchor = false;\n      var deleteTargetAnchor = false;\n\n      if (!nextVertex) {\n        nextVertex = edgeView.targetAnchor.toJSON();\n        nextVertex[axis] = position[axis];\n\n        if (targetBBox.containsPoint(nextVertex)) {\n          changeTargetAnchor = true;\n        } else {\n          vertices.push(nextVertex);\n          deleteTargetAnchor = true;\n        }\n      } else if (index === vertices.length - 2) {\n        if (targetBBox.containsPoint(nextVertex)) {\n          vertices.pop();\n          changeTargetAnchor = true;\n        } else {\n          nextVertex[axis] = position[axis];\n          deleteTargetAnchor = true;\n        }\n      } else {\n        nextVertex[axis] = position[axis];\n      }\n\n      if (typeof anchorFn === 'function' && targetView) {\n        if (changeTargetAnchor) {\n          var targetAnchorPosition = data.targetAnchor.clone();\n          targetAnchorPosition[axis] = position[axis];\n          var targetAnchor = FunctionExt.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);\n          this.resetAnchor('target', targetAnchor);\n        }\n\n        if (deleteTargetAnchor) {\n          this.resetAnchor('target', data.targetAnchorDef);\n        }\n      }\n\n      if (!Point.equalPoints(vertices, this.vertices)) {\n        this.cellView.cell.setVertices(vertices, {\n          ui: true,\n          toolId: this.cid\n        });\n      }\n\n      this.updateHandle(handle, vertex, nextVertex, 0);\n\n      if (!options.stopPropagation) {\n        edgeView.notifyMouseMove(evt, coords.x, coords.y);\n      }\n    }\n  }, {\n    key: \"onHandleChange\",\n    value: function onHandleChange(_ref2) {\n      var handle = _ref2.handle,\n          e = _ref2.e;\n      var options = this.options;\n      var handles = this.handles;\n      var edgeView = this.cellView;\n      var index = handle.options.index;\n\n      if (!Array.isArray(handles)) {\n        return;\n      }\n\n      for (var i = 0, n = handles.length; i < n; i += 1) {\n        if (i !== index) {\n          handles[i].hide();\n        }\n      }\n\n      this.focus();\n      this.setEventData(e, {\n        sourceAnchor: edgeView.sourceAnchor.clone(),\n        targetAnchor: edgeView.targetAnchor.clone(),\n        sourceAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['source', 'anchor'])),\n        targetAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['target', 'anchor']))\n      });\n      this.cell.startBatch('move-segment', {\n        ui: true,\n        toolId: this.cid\n      });\n\n      if (!options.stopPropagation) {\n        var normalizedEvent = this.normalizeEvent(e);\n        var coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);\n      }\n    }\n  }, {\n    key: \"onHandleChanged\",\n    value: function onHandleChanged(_ref3) {\n      var e = _ref3.e;\n      var options = this.options;\n      var edgeView = this.cellView;\n\n      if (options.removeRedundancies) {\n        edgeView.removeRedundantLinearVertices({\n          ui: true,\n          toolId: this.cid\n        });\n      }\n\n      var normalizedEvent = this.normalizeEvent(e);\n      var coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n      this.render();\n      this.blur();\n      this.cell.stopBatch('move-segment', {\n        ui: true,\n        toolId: this.cid\n      });\n\n      if (!options.stopPropagation) {\n        edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);\n      }\n\n      edgeView.checkMouseleave(normalizedEvent);\n      options.onChanged && options.onChanged({\n        edge: edgeView.cell,\n        edgeView: edgeView\n      });\n    }\n  }, {\n    key: \"updateHandle\",\n    value: function updateHandle(handle, vertex, nextVertex) {\n      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var precision = this.options.precision || 0;\n      var vertical = Math.abs(vertex.x - nextVertex.x) < precision;\n      var horizontal = Math.abs(vertex.y - nextVertex.y) < precision;\n\n      if (vertical || horizontal) {\n        var segmentLine = new Line(vertex, nextVertex);\n        var length = segmentLine.length();\n\n        if (length < this.options.threshold) {\n          handle.hide();\n        } else {\n          var position = segmentLine.getCenter();\n          var axis = vertical ? 'x' : 'y';\n          position[axis] += offset || 0;\n          var angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n          handle.updatePosition(position.x, position.y, angle, this.cellView);\n          handle.show();\n          handle.options.axis = axis;\n        }\n      } else {\n        handle.hide();\n      }\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.resetHandles();\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      return this.cellView.cell.getVertices();\n    }\n  }]);\n\n  return Segments;\n}(ToolsView.ToolItem);\n\n(function (Segments) {\n  var Handle = /*#__PURE__*/function (_View) {\n    _inherits(Handle, _View);\n\n    function Handle(options) {\n      var _this4;\n\n      _classCallCheck(this, Handle);\n\n      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Handle).call(this));\n      _this4.options = options;\n\n      _this4.render();\n\n      _this4.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown'\n      });\n\n      return _this4;\n    }\n\n    _createClass(Handle, [{\n      key: \"render\",\n      value: function render() {\n        this.container = View.createElement('rect', true);\n        var attrs = this.options.attrs;\n\n        if (typeof attrs === 'function') {\n          var defaults = Segments.getDefaults();\n          this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));\n        } else {\n          this.setAttrs(attrs);\n        }\n\n        this.addClass(this.prefixClassName('edge-tool-segment'));\n      }\n    }, {\n      key: \"updatePosition\",\n      value: function updatePosition(x, y, angle, view) {\n        var p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);\n        var matrix = Dom.createSVGMatrix().translate(p.x, p.y);\n\n        if (!p.equals({\n          x: x,\n          y: y\n        })) {\n          var line = new Line(x, y, p.x, p.y);\n          var deg = line.vector().vectorAngle(new Point(1, 0));\n\n          if (deg !== 0) {\n            deg += 90;\n          }\n\n          matrix = matrix.rotate(deg);\n        } else {\n          matrix = matrix.rotate(angle);\n        }\n\n        this.setAttrs({\n          transform: Dom.matrixToTransformString(matrix),\n          cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize'\n        });\n      }\n    }, {\n      key: \"onMouseDown\",\n      value: function onMouseDown(evt) {\n        if (this.options.guard(evt)) {\n          return;\n        }\n\n        this.trigger('change', {\n          e: evt,\n          handle: this\n        });\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.graph.view.undelegateEvents();\n        this.delegateDocumentEvents({\n          mousemove: 'onMouseMove',\n          touchmove: 'onMouseMove',\n          mouseup: 'onMouseUp',\n          touchend: 'onMouseUp',\n          touchcancel: 'onMouseUp'\n        }, evt.data);\n      }\n    }, {\n      key: \"onMouseMove\",\n      value: function onMouseMove(evt) {\n        this.emit('changing', {\n          e: evt,\n          handle: this\n        });\n      }\n    }, {\n      key: \"onMouseUp\",\n      value: function onMouseUp(evt) {\n        this.emit('changed', {\n          e: evt,\n          handle: this\n        });\n        this.undelegateDocumentEvents();\n        this.options.graph.view.delegateEvents();\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        this.container.style.display = '';\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.container.style.display = 'none';\n      }\n    }]);\n\n    return Handle;\n  }(View);\n\n  Segments.Handle = Handle;\n})(Segments || (Segments = {}));\n\n(function (Segments) {\n  Segments.config({\n    name: 'segments',\n    precision: 0.5,\n    threshold: 40,\n    snapRadius: 10,\n    stopPropagation: true,\n    removeRedundancies: true,\n    attrs: {\n      width: 20,\n      height: 8,\n      x: -10,\n      y: -4,\n      rx: 4,\n      ry: 4,\n      fill: '#333',\n      stroke: '#fff',\n      'stroke-width': 2\n    },\n    createHandle: function createHandle(options) {\n      return new Segments.Handle(options);\n    },\n    anchor: Util.getAnchor\n  });\n})(Segments || (Segments = {}));","map":null,"metadata":{},"sourceType":"module"}