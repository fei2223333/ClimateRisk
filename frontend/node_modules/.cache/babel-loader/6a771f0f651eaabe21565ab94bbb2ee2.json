{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ArrayExt, FunctionExt } from '../../util';\nimport { Rectangle, Angle } from '../../geometry';\nimport { View } from '../../view/view';\nexport var Snapline = /*#__PURE__*/function (_View) {\n  _inherits(Snapline, _View);\n\n  function Snapline(options) {\n    var _this;\n\n    _classCallCheck(this, Snapline);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Snapline).call(this));\n\n    var graph = options.graph,\n        others = __rest(options, [\"graph\"]);\n\n    _this.graph = graph;\n    _this.options = Object.assign({\n      tolerance: 10\n    }, others);\n\n    _this.render();\n\n    _this.parseFilter();\n\n    if (!_this.disabled) {\n      _this.startListening();\n    }\n\n    return _this;\n  }\n\n  _createClass(Snapline, [{\n    key: \"enable\",\n    value: function enable() {\n      if (this.disabled) {\n        this.options.enabled = true;\n        this.graph.options.snapline.enabled = true;\n        this.startListening();\n      }\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      if (!this.disabled) {\n        this.options.enabled = false;\n        this.graph.options.snapline.enabled = false;\n        this.stopListening();\n      }\n    }\n  }, {\n    key: \"setFilter\",\n    value: function setFilter(filter) {\n      this.options.filter = filter;\n      this.parseFilter();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.container = document.createElement('div');\n      this.$container = this.$(this.container);\n      this.$horizontal = this.$(document.createElement('div')).addClass(this.horizontalClassName);\n      this.$vertical = this.$(document.createElement('div')).addClass(this.verticalClassName);\n      this.$container.hide().addClass(this.containerClassName).append([this.$horizontal, this.$vertical]);\n\n      if (this.options.className) {\n        this.$container.addClass(this.options.className);\n      }\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      this.stopListening();\n      this.graph.on('node:mousedown', this.captureCursorOffset, this);\n      this.graph.on('node:mousemove', this.snapOnMoving, this);\n      this.model.on('batch:stop', this.onBatchStop, this);\n      this.delegateDocumentEvents({\n        mouseup: 'hide',\n        touchend: 'hide'\n      });\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      this.graph.off('node:mousedown', this.captureCursorOffset, this);\n      this.graph.off('node:mousemove', this.snapOnMoving, this);\n      this.model.off('batch:stop', this.onBatchStop, this);\n      this.undelegateDocumentEvents();\n    }\n  }, {\n    key: \"parseFilter\",\n    value: function parseFilter() {\n      var _this2 = this;\n\n      this.filterShapes = {};\n      this.filterCells = {};\n      this.filterFunction = null;\n      var filter = this.options.filter;\n\n      if (Array.isArray(filter)) {\n        filter.forEach(function (item) {\n          if (typeof item === 'string') {\n            _this2.filterShapes[item] = true;\n          } else {\n            _this2.filterCells[item.id] = true;\n          }\n        });\n      } else if (typeof filter === 'function') {\n        this.filterFunction = filter;\n      }\n    }\n  }, {\n    key: \"onBatchStop\",\n    value: function onBatchStop(_ref) {\n      var name = _ref.name,\n          data = _ref.data;\n\n      if (name === 'resize') {\n        this.snapOnResizing(data.cell, data);\n      }\n    }\n  }, {\n    key: \"captureCursorOffset\",\n    value: function captureCursorOffset(_ref2) {\n      var view = _ref2.view,\n          x = _ref2.x,\n          y = _ref2.y;\n      var targetView = view.getDelegatedView();\n\n      if (targetView && this.isNodeMovable(targetView)) {\n        var pos = view.cell.getPosition();\n        this.offset = {\n          x: x - pos.x,\n          y: y - pos.y\n        };\n      }\n    }\n  }, {\n    key: \"isNodeMovable\",\n    value: function isNodeMovable(view) {\n      return view && view.cell.isNode() && view.can('nodeMovable');\n    }\n  }, {\n    key: \"snapOnResizing\",\n    value: function snapOnResizing(node, options) {\n      var _this3 = this;\n\n      if (this.options.resizing && !options.snapped && options.ui && options.direction && options.trueDirection) {\n        var view = this.graph.renderer.findViewByCell(node);\n\n        if (view && view.cell.isNode()) {\n          var nodeBbox = node.getBBox();\n          var nodeBBoxRotated = nodeBbox.bbox(node.getAngle());\n          var nodeTopLeft = nodeBBoxRotated.getTopLeft();\n          var nodeBottomRight = nodeBBoxRotated.getBottomRight();\n          var angle = Angle.normalize(node.getAngle());\n          var tolerance = this.options.tolerance || 0;\n          var verticalLeft;\n          var verticalTop;\n          var verticalHeight;\n          var horizontalTop;\n          var horizontalLeft;\n          var horizontalWidth;\n          var snapOrigin = {\n            vertical: 0,\n            horizontal: 0\n          };\n          var direction = options.direction;\n          var trueDirection = options.trueDirection;\n          var relativeDirection = options.relativeDirection;\n\n          if (trueDirection.indexOf('right') !== -1) {\n            snapOrigin.vertical = nodeBottomRight.x;\n          } else {\n            snapOrigin.vertical = nodeTopLeft.x;\n          }\n\n          if (trueDirection.indexOf('bottom') !== -1) {\n            snapOrigin.horizontal = nodeBottomRight.y;\n          } else {\n            snapOrigin.horizontal = nodeTopLeft.y;\n          }\n\n          this.model.getNodes().some(function (cell) {\n            if (_this3.isIgnored(node, cell)) {\n              return false;\n            }\n\n            var snapBBox = cell.getBBox().bbox(cell.getAngle());\n            var snapTopLeft = snapBBox.getTopLeft();\n            var snapBottomRight = snapBBox.getBottomRight();\n            var groups = {\n              vertical: [snapTopLeft.x, snapBottomRight.x],\n              horizontal: [snapTopLeft.y, snapBottomRight.y]\n            };\n            var distances = {};\n            Object.keys(groups).forEach(function (k) {\n              var key = k;\n              var list = groups[key].map(function (value) {\n                return {\n                  position: value,\n                  distance: Math.abs(value - snapOrigin[key])\n                };\n              }).filter(function (item) {\n                return item.distance <= tolerance;\n              });\n              distances[key] = ArrayExt.sortBy(list, function (item) {\n                return item.distance;\n              });\n            });\n\n            if (verticalLeft == null && distances.vertical.length > 0) {\n              verticalLeft = distances.vertical[0].position;\n              verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n              verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n            }\n\n            if (horizontalTop == null && distances.horizontal.length > 0) {\n              horizontalTop = distances.horizontal[0].position;\n              horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n              horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n            }\n\n            return verticalLeft != null && horizontalTop != null;\n          });\n          this.hide();\n          var dx = 0;\n          var dy = 0;\n\n          if (horizontalTop != null || verticalLeft != null) {\n            if (verticalLeft != null) {\n              dx = trueDirection.indexOf('right') !== -1 ? verticalLeft - nodeBottomRight.x : nodeTopLeft.x - verticalLeft;\n            }\n\n            if (horizontalTop != null) {\n              dy = trueDirection.indexOf('bottom') !== -1 ? horizontalTop - nodeBottomRight.y : nodeTopLeft.y - horizontalTop;\n            }\n          }\n\n          var dWidth = 0;\n          var dHeight = 0;\n\n          if (angle % 90 === 0) {\n            if (angle === 90 || angle === 270) {\n              dWidth = dy;\n              dHeight = dx;\n            } else {\n              dWidth = dx;\n              dHeight = dy;\n            }\n          } else {\n            var quadrant = angle >= 0 && angle < 90 ? 1 : angle >= 90 && angle < 180 ? 4 : angle >= 180 && angle < 270 ? 3 : 2;\n\n            if (horizontalTop != null && verticalLeft != null) {\n              if (dx < dy) {\n                dy = 0;\n                horizontalTop = undefined;\n              } else {\n                dx = 0;\n                verticalLeft = undefined;\n              }\n            }\n\n            var rad = Angle.toRad(angle % 90);\n\n            if (dx) {\n              dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);\n            }\n\n            if (dy) {\n              dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);\n            }\n\n            var quadrant13 = quadrant === 1 || quadrant === 3;\n\n            switch (relativeDirection) {\n              case 'top':\n              case 'bottom':\n                dHeight = dy ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n                break;\n\n              case 'left':\n              case 'right':\n                dWidth = dx ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n                break;\n\n              default:\n                break;\n            }\n          }\n\n          switch (relativeDirection) {\n            case 'top':\n            case 'bottom':\n              dWidth = 0;\n              break;\n\n            case 'left':\n            case 'right':\n              dHeight = 0;\n              break;\n\n            default:\n              break;\n          }\n\n          var gridSize = this.graph.getGridSize();\n          var newWidth = Math.max(nodeBbox.width + dWidth, gridSize);\n          var newHeight = Math.max(nodeBbox.height + dHeight, gridSize);\n\n          if (options.minWidth && options.minWidth > gridSize) {\n            newWidth = Math.max(newWidth, options.minWidth);\n          }\n\n          if (options.minHeight && options.minHeight > gridSize) {\n            newHeight = Math.max(newHeight, options.minHeight);\n          }\n\n          if (options.maxWidth) {\n            newWidth = Math.min(newWidth, options.maxWidth);\n          }\n\n          if (options.maxHeight) {\n            newHeight = Math.min(newHeight, options.maxHeight);\n          }\n\n          if (options.preserveAspectRatio) {\n            if (dHeight < dWidth) {\n              newHeight = newWidth * (nodeBbox.height / nodeBbox.width);\n            } else {\n              newWidth = newHeight * (nodeBbox.width / nodeBbox.height);\n            }\n          }\n\n          if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {\n            node.resize(newWidth, newHeight, {\n              direction: direction,\n              relativeDirection: relativeDirection,\n              trueDirection: trueDirection,\n              snapped: true,\n              snaplines: this.cid,\n              restrict: this.graph.hook.getRestrictArea(view)\n            });\n\n            if (verticalHeight) {\n              verticalHeight += newHeight - nodeBbox.height;\n            }\n\n            if (horizontalWidth) {\n              horizontalWidth += newWidth - nodeBbox.width;\n            }\n          }\n\n          var newRotatedBBox = node.getBBox().bbox(angle);\n\n          if (verticalLeft && Math.abs(newRotatedBBox.x - verticalLeft) > 1 && Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {\n            verticalLeft = undefined;\n          }\n\n          if (horizontalTop && Math.abs(newRotatedBBox.y - horizontalTop) > 1 && Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {\n            horizontalTop = undefined;\n          }\n\n          this.update({\n            verticalLeft: verticalLeft,\n            verticalTop: verticalTop,\n            verticalHeight: verticalHeight,\n            horizontalTop: horizontalTop,\n            horizontalLeft: horizontalLeft,\n            horizontalWidth: horizontalWidth\n          });\n        }\n      }\n    }\n  }, {\n    key: \"snapOnMoving\",\n    value: function snapOnMoving(_ref3) {\n      var _this4 = this;\n\n      var view = _ref3.view,\n          e = _ref3.e,\n          x = _ref3.x,\n          y = _ref3.y;\n      var targetView = view.getEventData(e).delegatedView || view;\n\n      if (!this.isNodeMovable(targetView)) {\n        return;\n      }\n\n      var node = targetView.cell;\n      var size = node.getSize();\n      var position = node.getPosition();\n      var cellBBox = new Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);\n      var angle = node.getAngle();\n      var nodeCenter = cellBBox.getCenter();\n      var nodeBBoxRotated = cellBBox.bbox(angle);\n      var nodeTopLeft = nodeBBoxRotated.getTopLeft();\n      var nodeBottomRight = nodeBBoxRotated.getBottomRight();\n      var distance = this.options.tolerance || 0;\n      var verticalLeft;\n      var verticalTop;\n      var verticalHeight;\n      var horizontalTop;\n      var horizontalLeft;\n      var horizontalWidth;\n      var verticalFix = 0;\n      var horizontalFix = 0;\n      this.model.getNodes().some(function (targetNode) {\n        if (_this4.isIgnored(node, targetNode)) {\n          return false;\n        }\n\n        var snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());\n        var snapCenter = snapBBox.getCenter();\n        var snapTopLeft = snapBBox.getTopLeft();\n        var snapBottomRight = snapBBox.getBottomRight();\n\n        if (verticalLeft == null) {\n          if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {\n            verticalLeft = snapCenter.x;\n            verticalFix = 0.5;\n          } else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {\n            verticalLeft = snapTopLeft.x;\n            verticalFix = 0;\n          } else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {\n            verticalLeft = snapTopLeft.x;\n            verticalFix = 1;\n          } else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {\n            verticalLeft = snapBottomRight.x;\n            verticalFix = 1;\n          } else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {\n            verticalLeft = snapBottomRight.x;\n          }\n\n          if (verticalLeft != null) {\n            verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n            verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n          }\n        }\n\n        if (horizontalTop == null) {\n          if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {\n            horizontalTop = snapCenter.y;\n            horizontalFix = 0.5;\n          } else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {\n            horizontalTop = snapTopLeft.y;\n          } else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {\n            horizontalTop = snapTopLeft.y;\n            horizontalFix = 1;\n          } else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {\n            horizontalTop = snapBottomRight.y;\n            horizontalFix = 1;\n          } else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {\n            horizontalTop = snapBottomRight.y;\n          }\n\n          if (horizontalTop != null) {\n            horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n            horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n          }\n        }\n\n        return verticalLeft != null && horizontalTop != null;\n      });\n      this.hide();\n\n      if (horizontalTop != null || verticalLeft != null) {\n        if (horizontalTop != null) {\n          nodeBBoxRotated.y = horizontalTop - horizontalFix * nodeBBoxRotated.height;\n        }\n\n        if (verticalLeft != null) {\n          nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;\n        }\n\n        var newCenter = nodeBBoxRotated.getCenter();\n        var newX = newCenter.x - cellBBox.width / 2;\n        var newY = newCenter.y - cellBBox.height / 2;\n        var dx = newX - position.x;\n        var dy = newY - position.y;\n\n        if (dx !== 0 || dy !== 0) {\n          node.translate(dx, dy, {\n            snapped: true,\n            restrict: this.graph.hook.getRestrictArea(targetView)\n          });\n\n          if (horizontalWidth) {\n            horizontalWidth += dx;\n          }\n\n          if (verticalHeight) {\n            verticalHeight += dy;\n          }\n        }\n\n        this.update({\n          verticalLeft: verticalLeft,\n          verticalTop: verticalTop,\n          verticalHeight: verticalHeight,\n          horizontalTop: horizontalTop,\n          horizontalLeft: horizontalLeft,\n          horizontalWidth: horizontalWidth\n        });\n      }\n    }\n  }, {\n    key: \"isIgnored\",\n    value: function isIgnored(snapNode, targetNode) {\n      return targetNode.id === snapNode.id || targetNode.isDescendantOf(snapNode) || this.filterShapes[targetNode.shape] || this.filterCells[targetNode.id] || this.filterFunction && FunctionExt.call(this.filterFunction, this.graph, targetNode);\n    }\n  }, {\n    key: \"update\",\n    value: function update(metadata) {\n      var ctm = this.graph.matrix();\n      var sx = ctm.a;\n      var sy = ctm.d;\n      var tx = ctm.e;\n      var ty = ctm.f;\n      var sharp = this.options.sharp;\n      var hasScroller = this.graph.scroller.widget != null;\n\n      if (metadata.horizontalTop) {\n        this.$horizontal.css({\n          top: metadata.horizontalTop * sy + ty,\n          left: sharp ? metadata.horizontalLeft * sx + tx : hasScroller ? '-300%' : 0,\n          width: sharp ? metadata.horizontalWidth * sx : hasScroller ? '700%' : '100%'\n        }).show();\n      } else {\n        this.$horizontal.hide();\n      }\n\n      if (metadata.verticalLeft) {\n        this.$vertical.css({\n          left: metadata.verticalLeft * sx + tx,\n          top: sharp ? metadata.verticalTop * sy + ty : hasScroller ? '-300%' : 0,\n          height: sharp ? metadata.verticalHeight * sy : hasScroller ? '700%' : '100%'\n        }).show();\n      } else {\n        this.$vertical.hide();\n      }\n\n      this.show();\n    }\n  }, {\n    key: \"resetTimer\",\n    value: function resetTimer() {\n      if (this.timer) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.$container.show();\n      this.resetTimer();\n\n      if (this.container.parentNode == null) {\n        this.graph.container.appendChild(this.container);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this5 = this;\n\n      this.$container.hide();\n      this.resetTimer();\n      var clean = this.options.clean;\n      var delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;\n\n      if (delay > 0) {\n        this.timer = window.setTimeout(function () {\n          _this5.unmount();\n        }, delay);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.stopListening();\n      this.hide();\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.remove();\n    }\n  }, {\n    key: \"model\",\n    get: function get() {\n      return this.graph.model;\n    }\n  }, {\n    key: \"containerClassName\",\n    get: function get() {\n      return this.prefixClassName('widget-snapline');\n    }\n  }, {\n    key: \"verticalClassName\",\n    get: function get() {\n      return \"\".concat(this.containerClassName, \"-vertical\");\n    }\n  }, {\n    key: \"horizontalClassName\",\n    get: function get() {\n      return \"\".concat(this.containerClassName, \"-horizontal\");\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this.options.enabled !== true || this.graph.options.snapline.enabled !== true;\n    }\n  }]);\n\n  return Snapline;\n}(View);\n\n__decorate([View.dispose()], Snapline.prototype, \"dispose\", null);","map":null,"metadata":{},"sourceType":"module"}