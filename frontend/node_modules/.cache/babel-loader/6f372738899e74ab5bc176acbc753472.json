{"ast":null,"code":"import acyclic from './acyclic';\nimport normalize from './normalize';\nimport rank from './rank';\nimport util, { normalizeRanks, removeEmptyRanks } from './util';\nimport parentDummyChains from './parent-dummy-chains';\nimport nestingGraph from './nesting-graph';\nimport addBorderSegments from './add-border-segments';\nimport coordinateSystem from './coordinate-system';\nimport order from './order';\nimport position from './position';\nimport graphlib from './graphlib';\nimport initDataOrder from './order/init-data-order';\nvar Graph = graphlib.Graph;\n\nvar layout = function layout(g, opts) {\n  var time = opts && opts.debugTiming ? util.time : util.notime;\n  time(\"layout\", function () {\n    // 如果在原图基础上修改，继承原图的order结果\n    if (opts && !opts.keepNodeOrder && opts.prevGraph) {\n      time(\"  inheritOrder\", function () {\n        inheritOrder(g, opts.prevGraph);\n      });\n    }\n\n    var layoutGraph = time(\"  buildLayoutGraph\", function () {\n      return buildLayoutGraph(g);\n    }); // 控制是否为边的label留位置（这会影响是否在边中间添加dummy node）\n\n    if (!(opts && opts.edgeLabelSpace === false)) {\n      time(\"  makeSpaceForEdgeLabels\", function () {\n        makeSpaceForEdgeLabels(layoutGraph);\n      });\n    } // TODO: 暂时处理层级设置不正确时的异常报错，提示设置正确的层级\n\n\n    try {\n      time(\"  runLayout\", function () {\n        runLayout(layoutGraph, time, opts);\n      });\n    } catch (e) {\n      if (e.message === \"Not possible to find intersection inside of the rectangle\") {\n        console.error('The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph\\'s structure:\\n', e);\n        return;\n      }\n\n      throw e;\n    }\n\n    time(\"  updateInputGraph\", function () {\n      updateInputGraph(g, layoutGraph);\n    });\n  });\n};\n\nvar runLayout = function runLayout(g, time, opts) {\n  time(\"    removeSelfEdges\", function () {\n    removeSelfEdges(g);\n  });\n  time(\"    acyclic\", function () {\n    acyclic.run(g);\n  });\n  time(\"    nestingGraph.run\", function () {\n    nestingGraph.run(g);\n  });\n  time(\"    rank\", function () {\n    rank(util.asNonCompoundGraph(g));\n  });\n  time(\"    injectEdgeLabelProxies\", function () {\n    injectEdgeLabelProxies(g);\n  });\n  time(\"    removeEmptyRanks\", function () {\n    removeEmptyRanks(g);\n  });\n  time(\"    nestingGraph.cleanup\", function () {\n    nestingGraph.cleanup(g);\n  });\n  time(\"    normalizeRanks\", function () {\n    normalizeRanks(g);\n  });\n  time(\"    assignRankMinMax\", function () {\n    assignRankMinMax(g);\n  });\n  time(\"    removeEdgeLabelProxies\", function () {\n    removeEdgeLabelProxies(g);\n  });\n  time(\"    normalize.run\", function () {\n    normalize.run(g);\n  });\n  time(\"    parentDummyChains\", function () {\n    parentDummyChains(g);\n  });\n  time(\"    addBorderSegments\", function () {\n    addBorderSegments(g);\n  });\n\n  if (opts && opts.keepNodeOrder) {\n    time(\"    initDataOrder\", function () {\n      initDataOrder(g, opts.nodeOrder);\n    });\n  }\n\n  time(\"    order\", function () {\n    order(g);\n  });\n  time(\"    insertSelfEdges\", function () {\n    insertSelfEdges(g);\n  });\n  time(\"    adjustCoordinateSystem\", function () {\n    coordinateSystem.adjust(g);\n  });\n  time(\"    position\", function () {\n    position(g);\n  });\n  time(\"    positionSelfEdges\", function () {\n    positionSelfEdges(g);\n  });\n  time(\"    removeBorderNodes\", function () {\n    removeBorderNodes(g);\n  });\n  time(\"    normalize.undo\", function () {\n    normalize.undo(g);\n  });\n  time(\"    fixupEdgeLabelCoords\", function () {\n    fixupEdgeLabelCoords(g);\n  });\n  time(\"    undoCoordinateSystem\", function () {\n    coordinateSystem.undo(g);\n  });\n  time(\"    translateGraph\", function () {\n    translateGraph(g);\n  });\n  time(\"    assignNodeIntersects\", function () {\n    assignNodeIntersects(g);\n  });\n  time(\"    reversePoints\", function () {\n    reversePointsForReversedEdges(g);\n  });\n  time(\"    acyclic.undo\", function () {\n    acyclic.undo(g);\n  });\n};\n/**\n * 继承上一个布局中的order，防止翻转\n * TODO: 暂时没有考虑涉及层级变动的布局，只保证原来布局层级和相对顺序不变\n */\n\n\nvar inheritOrder = function inheritOrder(currG, prevG) {\n  var prevNodeMap = prevG._nodes || {};\n  currG.nodes().forEach(function (n) {\n    var node = currG.node(n);\n\n    if (prevNodeMap[n] !== undefined) {\n      node.fixorder = prevNodeMap[n]._order;\n      delete prevNodeMap[n]._order;\n    } else {\n      delete node.fixorder;\n    }\n  });\n};\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\n\n\nvar updateInputGraph = function updateInputGraph(inputGraph, layoutGraph) {\n  inputGraph.nodes().forEach(function (v) {\n    var _a;\n\n    var inputLabel = inputGraph.node(v);\n    var layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n      inputLabel._order = layoutLabel.order;\n      inputLabel._rank = layoutLabel.rank;\n\n      if ((_a = layoutGraph.children(v)) === null || _a === void 0 ? void 0 : _a.length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n  inputGraph.edges().forEach(function (e) {\n    var inputLabel = inputGraph.edge(e);\n    var layoutLabel = layoutGraph.edge(e);\n    inputLabel.points = layoutLabel.points;\n\n    if (layoutLabel.hasOwnProperty(\"x\")) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n};\n\nvar graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nvar graphDefaults = {\n  ranksep: 50,\n  edgesep: 20,\n  nodesep: 50,\n  rankdir: \"tb\"\n};\nvar graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nvar nodeNumAttrs = [\"width\", \"height\", \"layer\", \"fixorder\"]; // 需要传入layer, fixOrder作为参数参考\n\nvar nodeDefaults = {\n  width: 0,\n  height: 0\n};\nvar edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nvar edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: \"r\"\n};\nvar edgeAttrs = [\"labelpos\"];\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\n\nvar buildLayoutGraph = function buildLayoutGraph(inputGraph) {\n  var g = new Graph({\n    multigraph: true,\n    compound: true\n  });\n  var graph = canonicalize(inputGraph.graph());\n  var pickedProperties = {};\n  graphAttrs === null || graphAttrs === void 0 ? void 0 : graphAttrs.forEach(function (key) {\n    if (graph[key] !== undefined) pickedProperties[key] = graph[key];\n  });\n  g.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), pickedProperties));\n  inputGraph.nodes().forEach(function (v) {\n    var node = canonicalize(inputGraph.node(v));\n    var defaultAttrs = selectNumberAttrs(node, nodeNumAttrs);\n    Object.keys(nodeDefaults).forEach(function (key) {\n      if (defaultAttrs[key] === undefined) {\n        defaultAttrs[key] = nodeDefaults[key];\n      }\n    });\n    g.setNode(v, defaultAttrs);\n    g.setParent(v, inputGraph.parent(v));\n  });\n  inputGraph.edges().forEach(function (e) {\n    var edge = canonicalize(inputGraph.edge(e));\n    var pickedProperties = {};\n    edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach(function (key) {\n      if (edge[key] !== undefined) pickedProperties[key] = edge[key];\n    });\n    g.setEdge(e, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties));\n  });\n  return g;\n};\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\n\n\nvar makeSpaceForEdgeLabels = function makeSpaceForEdgeLabels(g) {\n  var graph = g.graph();\n  if (!graph.ranksep) graph.ranksep = 0;\n  graph.ranksep /= 2;\n  g.nodes().forEach(function (n) {\n    var node = g.node(n);\n\n    if (!isNaN(node.layer)) {\n      if (!node.layer) node.layer = 0;else node.layer *= 2; // TODO: 因为默认的rank变为两倍，设定的layer也*2\n    }\n  });\n  g.edges().forEach(function (e) {\n    var _a;\n\n    var edge = g.edge(e);\n    edge.minlen *= 2;\n\n    if (((_a = edge.labelpos) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== \"c\") {\n      if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n};\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\n\n\nvar injectEdgeLabelProxies = function injectEdgeLabelProxies(g) {\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e);\n\n    if (edge.width && edge.height) {\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = {\n        e: e,\n        rank: (w.rank - v.rank) / 2 + v.rank\n      };\n      util.addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n  });\n};\n\nvar assignRankMinMax = function assignRankMinMax(g) {\n  var maxRank = 0;\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      maxRank = Math.max(maxRank, node.maxRank || -Infinity);\n    }\n  });\n  g.graph().maxRank = maxRank;\n};\n\nvar removeEdgeLabelProxies = function removeEdgeLabelProxies(g) {\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n\n    if (node.dummy === \"edge-proxy\") {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n};\n\nvar translateGraph = function translateGraph(g) {\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = 0;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = 0;\n  var graphLabel = g.graph();\n  var marginX = graphLabel.marginx || 0;\n  var marginY = graphLabel.marginy || 0;\n\n  var getExtremes = function getExtremes(attrs) {\n    if (!attrs) return;\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n\n    if (!isNaN(x) && !isNaN(w)) {\n      minX = Math.min(minX, x - w / 2);\n      maxX = Math.max(maxX, x + w / 2);\n    }\n\n    if (!isNaN(y) && !isNaN(h)) {\n      minY = Math.min(minY, y - h / 2);\n      maxY = Math.max(maxY, y + h / 2);\n    }\n  };\n\n  g.nodes().forEach(function (v) {\n    getExtremes(g.node(v));\n  });\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e);\n\n    if (edge.hasOwnProperty(\"x\")) {\n      getExtremes(edge);\n    }\n  });\n  minX -= marginX;\n  minY -= marginY;\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n  g.edges().forEach(function (e) {\n    var _a;\n\n    var edge = g.edge(e);\n    (_a = edge.points) === null || _a === void 0 ? void 0 : _a.forEach(function (p) {\n      p.x -= minX;\n      p.y -= minY;\n    });\n\n    if (edge.hasOwnProperty(\"x\")) {\n      edge.x -= minX;\n    }\n\n    if (edge.hasOwnProperty(\"y\")) {\n      edge.y -= minY;\n    }\n  });\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n};\n\nvar assignNodeIntersects = function assignNodeIntersects(g) {\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e);\n    var nodeV = g.node(e.v);\n    var nodeW = g.node(e.w);\n    var p1;\n    var p2;\n\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n};\n\nvar fixupEdgeLabelCoords = function fixupEdgeLabelCoords(g) {\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e);\n\n    if (edge.hasOwnProperty(\"x\")) {\n      if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n        edge.width -= edge.labeloffset;\n      }\n\n      switch (edge.labelpos) {\n        case \"l\":\n          edge.x -= edge.width / 2 + edge.labeloffset;\n          break;\n\n        case \"r\":\n          edge.x += edge.width / 2 + edge.labeloffset;\n          break;\n      }\n    }\n  });\n};\n\nvar reversePointsForReversedEdges = function reversePointsForReversedEdges(g) {\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e);\n\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n};\n\nvar removeBorderNodes = function removeBorderNodes(g) {\n  g.nodes().forEach(function (v) {\n    var _a, _b, _c;\n\n    if ((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length) {\n      var node = g.node(v);\n      var t = g.node(node.borderTop);\n      var b = g.node(node.borderBottom);\n      var l = g.node(node.borderLeft[((_b = node.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);\n      var r = g.node(node.borderRight[((_c = node.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);\n      node.width = Math.abs((r === null || r === void 0 ? void 0 : r.x) - (l === null || l === void 0 ? void 0 : l.x)) || 10;\n      node.height = Math.abs((b === null || b === void 0 ? void 0 : b.y) - (t === null || t === void 0 ? void 0 : t.y)) || 10;\n      node.x = ((l === null || l === void 0 ? void 0 : l.x) || 0) + node.width / 2;\n      node.y = ((t === null || t === void 0 ? void 0 : t.y) || 0) + node.height / 2;\n    }\n  });\n  g.nodes().forEach(function (v) {\n    if (g.node(v).dummy === \"border\") {\n      g.removeNode(v);\n    }\n  });\n};\n\nvar removeSelfEdges = function removeSelfEdges(g) {\n  g.edges().forEach(function (e) {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n\n      node.selfEdges.push({\n        e: e,\n        label: g.edge(e)\n      });\n      g.removeEdge(e);\n    }\n  });\n};\n\nvar insertSelfEdges = function insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n  layers === null || layers === void 0 ? void 0 : layers.forEach(function (layer) {\n    var orderShift = 0;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, i) {\n      var _a;\n\n      var node = g.node(v);\n      node.order = i + orderShift;\n      (_a = node.selfEdges) === null || _a === void 0 ? void 0 : _a.forEach(function (selfEdge) {\n        util.addDummyNode(g, \"selfedge\", {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + ++orderShift,\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, \"_se\");\n      });\n      delete node.selfEdges;\n    });\n  });\n};\n\nvar positionSelfEdges = function positionSelfEdges(g) {\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n\n    if (node.dummy === \"selfedge\") {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [{\n        x: x + 2 * dx / 3,\n        y: y - dy\n      }, {\n        x: x + 5 * dx / 6,\n        y: y - dy\n      }, {\n        y: y,\n        x: x + dx\n      }, {\n        x: x + 5 * dx / 6,\n        y: y + dy\n      }, {\n        x: x + 2 * dx / 3,\n        y: y + dy\n      }];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n};\n\nvar selectNumberAttrs = function selectNumberAttrs(obj, attrs) {\n  var pickedProperties = {};\n  attrs === null || attrs === void 0 ? void 0 : attrs.forEach(function (key) {\n    if (obj[key] === undefined) return;\n    pickedProperties[key] = +obj[key];\n  });\n  return pickedProperties;\n};\n\nvar canonicalize = function canonicalize(attrs) {\n  var newAttrs = {};\n  Object.keys(attrs).forEach(function (k) {\n    var v = attrs[k];\n    newAttrs[k.toLowerCase()] = v;\n  });\n  return newAttrs;\n};\n\nexport default layout;","map":null,"metadata":{},"sourceType":"module"}