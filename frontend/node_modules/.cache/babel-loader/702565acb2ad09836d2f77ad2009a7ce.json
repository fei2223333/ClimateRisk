{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Platform, NumberExt, ObjectExt, Dom, FunctionExt } from '../../util';\nimport { Point, Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Renderer } from '../../graph/renderer';\nimport { GraphView } from '../../graph/view';\nimport { BackgroundManager } from '../../graph/background';\nexport var Scroller = /*#__PURE__*/function (_View) {\n  _inherits(Scroller, _View);\n\n  function Scroller(options) {\n    var _this;\n\n    _classCallCheck(this, Scroller);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Scroller).call(this));\n    _this.padding = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    _this.options = Util.getOptions(options);\n\n    var scale = _this.graph.transform.getScale();\n\n    _this.sx = scale.sx;\n    _this.sy = scale.sy;\n    var width = _this.options.width || _this.graph.options.width;\n    var height = _this.options.height || _this.graph.options.height;\n    _this.container = document.createElement('div');\n    _this.$container = _this.$(_this.container).addClass(_this.prefixClassName(Util.containerClass)).css({\n      width: width,\n      height: height\n    });\n\n    if (_this.options.pageVisible) {\n      _this.$container.addClass(_this.prefixClassName(Util.pagedClass));\n    }\n\n    if (_this.options.className) {\n      _this.$container.addClass(_this.options.className);\n    }\n\n    var graphContainer = _this.graph.container;\n\n    if (graphContainer.parentNode) {\n      _this.$container.insertBefore(graphContainer);\n    } // copy style\n\n\n    var style = graphContainer.getAttribute('style');\n\n    if (style) {\n      var obj = {};\n      var styles = style.split(';');\n      styles.forEach(function (item) {\n        var section = item.trim();\n\n        if (section) {\n          var pair = section.split(':');\n\n          if (pair.length) {\n            obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';\n          }\n        }\n      });\n      Object.keys(obj).forEach(function (key) {\n        if (key === 'width' || key === 'height') {\n          return;\n        }\n\n        graphContainer.style[key] = '';\n        _this.container.style[key] = obj[key];\n      });\n    }\n\n    _this.content = document.createElement('div');\n    _this.$content = _this.$(_this.content).addClass(_this.prefixClassName(Util.contentClass)).css({\n      width: _this.graph.options.width,\n      height: _this.graph.options.height\n    }); // custom background\n\n    _this.background = document.createElement('div');\n    _this.$background = _this.$(_this.background).addClass(_this.prefixClassName(Util.backgroundClass));\n\n    _this.$content.append(_this.background);\n\n    if (!_this.options.pageVisible) {\n      _this.$content.append(_this.graph.view.grid);\n    }\n\n    _this.$content.append(graphContainer);\n\n    _this.$content.appendTo(_this.container);\n\n    _this.startListening();\n\n    if (!_this.options.pageVisible) {\n      _this.graph.grid.update();\n    }\n\n    _this.backgroundManager = new Scroller.Background(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    if (!_this.options.autoResize) {\n      _this.update();\n    }\n\n    return _this;\n  }\n\n  _createClass(Scroller, [{\n    key: \"startListening\",\n    value: function startListening() {\n      var graph = this.graph;\n      var model = this.model;\n      graph.on('scale', this.onScale, this);\n      graph.on('resize', this.onResize, this);\n      graph.on('before:print', this.storeScrollPosition, this);\n      graph.on('before:export', this.storeScrollPosition, this);\n      graph.on('after:print', this.restoreScrollPosition, this);\n      graph.on('after:export', this.restoreScrollPosition, this);\n      graph.on('render:done', this.onRenderDone, this);\n      graph.on('unfreeze', this.onUpdate, this);\n      model.on('reseted', this.onUpdate, this);\n      model.on('cell:added', this.onUpdate, this);\n      model.on('cell:removed', this.onUpdate, this);\n      model.on('cell:changed', this.onUpdate, this);\n      model.on('batch:stop', this.onBatchStop, this);\n      this.delegateBackgroundEvents();\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      var graph = this.graph;\n      var model = this.model;\n      graph.off('scale', this.onScale, this);\n      graph.off('resize', this.onResize, this);\n      graph.off('beforeprint', this.storeScrollPosition, this);\n      graph.off('beforeexport', this.storeScrollPosition, this);\n      graph.off('afterprint', this.restoreScrollPosition, this);\n      graph.off('afterexport', this.restoreScrollPosition, this);\n      graph.off('render:done', this.onRenderDone, this);\n      graph.off('unfreeze', this.onUpdate, this);\n      model.off('reseted', this.onUpdate, this);\n      model.off('cell:added', this.onUpdate, this);\n      model.off('cell:removed', this.onUpdate, this);\n      model.off('cell:changed', this.onUpdate, this);\n      model.off('batch:stop', this.onBatchStop, this);\n      this.undelegateBackgroundEvents();\n    }\n  }, {\n    key: \"enableAutoResize\",\n    value: function enableAutoResize() {\n      this.options.autoResize = true;\n    }\n  }, {\n    key: \"disableAutoResize\",\n    value: function disableAutoResize() {\n      this.options.autoResize = false;\n    }\n  }, {\n    key: \"onUpdate\",\n    value: function onUpdate() {\n      if (this.graph.isAsync() || !this.options.autoResize) {\n        return;\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"onBatchStop\",\n    value: function onBatchStop(args) {\n      if (this.graph.isAsync() || !this.options.autoResize) {\n        return;\n      }\n\n      if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {\n        this.update();\n      }\n    }\n  }, {\n    key: \"delegateBackgroundEvents\",\n    value: function delegateBackgroundEvents(events) {\n      var _this2 = this;\n\n      var evts = events || GraphView.events;\n      this.delegatedHandlers = Object.keys(evts).reduce(function (memo, name) {\n        var handler = evts[name];\n\n        if (name.indexOf(' ') === -1) {\n          if (typeof handler === 'function') {\n            memo[name] = handler;\n          } else {\n            var method = _this2.graph.view[handler];\n\n            if (typeof method === 'function') {\n              method = method.bind(_this2.graph.view);\n              memo[name] = method;\n            }\n          }\n        }\n\n        return memo;\n      }, {});\n      this.onBackgroundEvent = this.onBackgroundEvent.bind(this);\n      Object.keys(this.delegatedHandlers).forEach(function (name) {\n        _this2.delegateEvent(name, {\n          guarded: false\n        }, _this2.onBackgroundEvent);\n      });\n    }\n  }, {\n    key: \"undelegateBackgroundEvents\",\n    value: function undelegateBackgroundEvents() {\n      var _this3 = this;\n\n      Object.keys(this.delegatedHandlers).forEach(function (name) {\n        _this3.undelegateEvent(name, _this3.onBackgroundEvent);\n      });\n    }\n  }, {\n    key: \"onBackgroundEvent\",\n    value: function onBackgroundEvent(e) {\n      var valid = false;\n      var target = e.target;\n\n      if (!this.options.pageVisible) {\n        var view = this.graph.view;\n        valid = view.background === target || view.grid === target;\n      } else if (this.options.background) {\n        valid = this.background === target;\n      } else {\n        valid = this.content === target;\n      }\n\n      if (valid) {\n        var handler = this.delegatedHandlers[e.type];\n\n        if (typeof handler === 'function') {\n          handler.apply(this.graph, arguments); // eslint-disable-line\n        }\n      }\n    }\n  }, {\n    key: \"onRenderDone\",\n    value: function onRenderDone(_ref) {\n      var stats = _ref.stats;\n\n      if (this.options.autoResize && stats.priority < 2) {\n        this.update();\n      }\n    }\n  }, {\n    key: \"onResize\",\n    value: function onResize() {\n      if (this.cachedCenterPoint) {\n        this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);\n        this.updatePageBreak();\n      }\n    }\n  }, {\n    key: \"onScale\",\n    value: function onScale(_ref2) {\n      var sx = _ref2.sx,\n          sy = _ref2.sy,\n          ox = _ref2.ox,\n          oy = _ref2.oy;\n      this.updateScale(sx, sy);\n\n      if (ox || oy) {\n        this.centerPoint(ox, oy);\n        this.updatePageBreak();\n      }\n\n      var autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n\n      if (typeof autoResizeOptions === 'function') {\n        this.update();\n      }\n    }\n  }, {\n    key: \"storeScrollPosition\",\n    value: function storeScrollPosition() {\n      this.cachedScrollLeft = this.container.scrollLeft;\n      this.cachedScrollTop = this.container.scrollTop;\n    }\n  }, {\n    key: \"restoreScrollPosition\",\n    value: function restoreScrollPosition() {\n      this.container.scrollLeft = this.cachedScrollLeft;\n      this.container.scrollTop = this.cachedScrollTop;\n      this.cachedScrollLeft = null;\n      this.cachedScrollTop = null;\n    }\n  }, {\n    key: \"storeClientSize\",\n    value: function storeClientSize() {\n      this.cachedClientSize = {\n        width: this.container.clientWidth,\n        height: this.container.clientHeight\n      };\n    }\n  }, {\n    key: \"restoreClientSize\",\n    value: function restoreClientSize() {\n      this.cachedClientSize = null;\n    }\n  }, {\n    key: \"beforeManipulation\",\n    value: function beforeManipulation() {\n      if (Platform.IS_IE || Platform.IS_EDGE) {\n        this.$container.css('visibility', 'hidden');\n      }\n    }\n  }, {\n    key: \"afterManipulation\",\n    value: function afterManipulation() {\n      if (Platform.IS_IE || Platform.IS_EDGE) {\n        this.$container.css('visibility', 'visible');\n      }\n    }\n  }, {\n    key: \"updatePageSize\",\n    value: function updatePageSize(width, height) {\n      if (width != null) {\n        this.options.pageWidth = width;\n      }\n\n      if (height != null) {\n        this.options.pageHeight = height;\n      }\n\n      this.updatePageBreak();\n    }\n  }, {\n    key: \"updatePageBreak\",\n    value: function updatePageBreak() {\n      if (this.pageBreak && this.pageBreak.parentNode) {\n        this.pageBreak.parentNode.removeChild(this.pageBreak);\n      }\n\n      this.pageBreak = null;\n\n      if (this.options.pageVisible && this.options.pageBreak) {\n        var graphWidth = this.graph.options.width;\n        var graphHeight = this.graph.options.height;\n        var pageWidth = this.options.pageWidth * this.sx;\n        var pageHeight = this.options.pageHeight * this.sy;\n\n        if (graphWidth > pageWidth || graphHeight > pageHeight) {\n          var hasPageBreak = false;\n          var container = document.createElement('div');\n\n          for (var i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {\n            this.$('<div/>').addClass(this.prefixClassName(\"graph-pagebreak-vertical\")).css({\n              left: i * pageWidth\n            }).appendTo(container);\n            hasPageBreak = true;\n          }\n\n          for (var _i = 1, _l = Math.floor(graphHeight / pageHeight); _i < _l; _i += 1) {\n            this.$('<div/>').addClass(this.prefixClassName(\"graph-pagebreak-horizontal\")).css({\n              top: _i * pageHeight\n            }).appendTo(container);\n            hasPageBreak = true;\n          }\n\n          if (hasPageBreak) {\n            Dom.addClass(container, this.prefixClassName('graph-pagebreak'));\n            this.$(this.graph.view.grid).after(container);\n            this.pageBreak = container;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var size = this.getClientSize();\n      this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);\n      var resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n\n      if (typeof resizeOptions === 'function') {\n        resizeOptions = FunctionExt.call(resizeOptions, this, this);\n      }\n\n      var options = Object.assign({\n        gridWidth: this.options.pageWidth,\n        gridHeight: this.options.pageHeight,\n        allowNewOrigin: 'negative'\n      }, resizeOptions);\n      this.graph.fitToContent(this.getFitToContentOptions(options));\n    }\n  }, {\n    key: \"getFitToContentOptions\",\n    value: function getFitToContentOptions(options) {\n      var sx = this.sx;\n      var sy = this.sy;\n      options.gridWidth && (options.gridWidth *= sx);\n      options.gridHeight && (options.gridHeight *= sy);\n      options.minWidth && (options.minWidth *= sx);\n      options.minHeight && (options.minHeight *= sy);\n\n      if (typeof options.padding === 'object') {\n        options.padding = {\n          left: (options.padding.left || 0) * sx,\n          right: (options.padding.right || 0) * sx,\n          top: (options.padding.top || 0) * sy,\n          bottom: (options.padding.bottom || 0) * sy\n        };\n      } else if (typeof options.padding === 'number') {\n        options.padding *= sx;\n      }\n\n      if (!this.options.autoResize) {\n        options.contentArea = Rectangle.create();\n      }\n\n      return options;\n    }\n  }, {\n    key: \"updateScale\",\n    value: function updateScale(sx, sy) {\n      var options = this.graph.options;\n      var dx = sx / this.sx;\n      var dy = sy / this.sy;\n      this.sx = sx;\n      this.sy = sy;\n      this.graph.translate(options.x * dx, options.y * dy);\n      this.graph.resizeGraph(options.width * dx, options.height * dy);\n    }\n  }, {\n    key: \"scrollbarPosition\",\n    value: function scrollbarPosition(left, top, options) {\n      if (left == null && top == null) {\n        return {\n          left: this.container.scrollLeft,\n          top: this.container.scrollTop\n        };\n      }\n\n      var prop = {};\n\n      if (typeof left === 'number') {\n        prop.scrollLeft = left;\n      }\n\n      if (typeof top === 'number') {\n        prop.scrollTop = top;\n      }\n\n      if (options && options.animation) {\n        this.$container.animate(prop, options.animation);\n      } else {\n        this.$container.prop(prop);\n      }\n\n      return this;\n    }\n    /**\n     * Try to scroll to ensure that the position (x,y) on the graph (in local\n     * coordinates) is at the center of the viewport. If only one of the\n     * coordinates is specified, only scroll in the specified dimension and\n     * keep the other coordinate unchanged.\n     */\n\n  }, {\n    key: \"scrollToPoint\",\n    value: function scrollToPoint(x, y, options) {\n      var size = this.getClientSize();\n      var ctm = this.graph.matrix();\n      var prop = {};\n\n      if (typeof x === 'number') {\n        prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);\n      }\n\n      if (typeof y === 'number') {\n        prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);\n      }\n\n      if (options && options.animation) {\n        this.$container.animate(prop, options.animation);\n      } else {\n        this.$container.prop(prop);\n      }\n\n      return this;\n    }\n    /**\n     * Try to scroll to ensure that the center of graph content is at the\n     * center of the viewport.\n     */\n\n  }, {\n    key: \"scrollToContent\",\n    value: function scrollToContent(options) {\n      var sx = this.sx;\n      var sy = this.sy;\n      var center = this.graph.getContentArea().getCenter();\n      return this.scrollToPoint(center.x * sx, center.y * sy, options);\n    }\n    /**\n     * Try to scroll to ensure that the center of cell is at the center of\n     * the viewport.\n     */\n\n  }, {\n    key: \"scrollToCell\",\n    value: function scrollToCell(cell, options) {\n      var sx = this.sx;\n      var sy = this.sy;\n      var center = cell.getBBox().getCenter();\n      return this.scrollToPoint(center.x * sx, center.y * sy, options);\n    }\n    /**\n     * The center methods are more aggressive than the scroll methods. These\n     * methods position the graph so that a specific point on the graph lies\n     * at the center of the viewport, adding paddings around the paper if\n     * necessary (e.g. if the requested point lies in a corner of the paper).\n     * This means that the requested point will always move into the center\n     * of the viewport. (Use the scroll functions to avoid adding paddings\n     * and only scroll the viewport as far as the graph boundary.)\n     */\n\n    /**\n     * Position the center of graph to the center of the viewport.\n     */\n\n  }, {\n    key: \"center\",\n    value: function center(optons) {\n      return this.centerPoint(optons);\n    }\n  }, {\n    key: \"centerPoint\",\n    value: function centerPoint(x, y, options) {\n      var ctm = this.graph.matrix();\n      var sx = ctm.a;\n      var sy = ctm.d;\n      var tx = -ctm.e;\n      var ty = -ctm.f;\n      var tWidth = tx + this.graph.options.width;\n      var tHeight = ty + this.graph.options.height;\n      var localOptions;\n      this.storeClientSize(); // avoid multilple reflow\n\n      if (typeof x === 'number' || typeof y === 'number') {\n        localOptions = options;\n        var visibleCenter = this.getVisibleArea().getCenter();\n\n        if (typeof x === 'number') {\n          x *= sx; // eslint-disable-line\n        } else {\n          x = visibleCenter.x; // eslint-disable-line\n        }\n\n        if (typeof y === 'number') {\n          y *= sy; // eslint-disable-line\n        } else {\n          y = visibleCenter.y; // eslint-disable-line\n        }\n      } else {\n        localOptions = x;\n        x = (tx + tWidth) / 2; // eslint-disable-line\n\n        y = (ty + tHeight) / 2; // eslint-disable-line\n      }\n\n      if (localOptions && localOptions.padding) {\n        return this.positionPoint({\n          x: x,\n          y: y\n        }, '50%', '50%', localOptions);\n      }\n\n      var padding = this.getPadding();\n      var clientSize = this.getClientSize();\n      var cx = clientSize.width / 2;\n      var cy = clientSize.height / 2;\n      var left = cx - padding.left - x + tx;\n      var right = cx - padding.right + x - tWidth;\n      var top = cy - padding.top - y + ty;\n      var bottom = cy - padding.bottom + y - tHeight;\n      this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));\n      var result = this.scrollToPoint(x, y, localOptions || undefined);\n      this.restoreClientSize();\n      return result;\n    }\n  }, {\n    key: \"centerContent\",\n    value: function centerContent(options) {\n      return this.positionContent('center', options);\n    }\n  }, {\n    key: \"centerCell\",\n    value: function centerCell(cell, options) {\n      return this.positionCell(cell, 'center', options);\n    }\n    /**\n     * The position methods are a more general version of the center methods.\n     * They position the graph so that a specific point on the graph lies at\n     * requested coordinates inside the viewport.\n     */\n\n    /**\n     *\n     */\n\n  }, {\n    key: \"positionContent\",\n    value: function positionContent(pos, options) {\n      var rect = this.graph.getContentArea(options);\n      return this.positionRect(rect, pos, options);\n    }\n  }, {\n    key: \"positionCell\",\n    value: function positionCell(cell, pos, options) {\n      var bbox = cell.getBBox();\n      return this.positionRect(bbox, pos, options);\n    }\n  }, {\n    key: \"positionRect\",\n    value: function positionRect(rect, pos, options) {\n      var bbox = Rectangle.create(rect);\n\n      switch (pos) {\n        case 'center':\n          return this.positionPoint(bbox.getCenter(), '50%', '50%', options);\n\n        case 'top':\n          return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);\n\n        case 'top-right':\n          return this.positionPoint(bbox.getTopRight(), '100%', 0, options);\n\n        case 'right':\n          return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);\n\n        case 'bottom-right':\n          return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);\n\n        case 'bottom':\n          return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);\n\n        case 'bottom-left':\n          return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);\n\n        case 'left':\n          return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);\n\n        case 'top-left':\n          return this.positionPoint(bbox.getTopLeft(), 0, 0, options);\n\n        default:\n          return this;\n      }\n    }\n  }, {\n    key: \"positionPoint\",\n    value: function positionPoint(point, x, y) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var pad = options.padding,\n          localOptions = __rest(options, [\"padding\"]);\n\n      var padding = NumberExt.normalizeSides(pad);\n      var clientRect = Rectangle.fromSize(this.getClientSize());\n      var targetRect = clientRect.clone().moveAndExpand({\n        x: padding.left,\n        y: padding.top,\n        width: -padding.right - padding.left,\n        height: -padding.top - padding.bottom\n      }); // eslint-disable-next-line\n\n      x = NumberExt.normalizePercentage(x, Math.max(0, targetRect.width));\n\n      if (x < 0) {\n        x = targetRect.width + x; // eslint-disable-line\n      } // eslint-disable-next-line\n\n\n      y = NumberExt.normalizePercentage(y, Math.max(0, targetRect.height));\n\n      if (y < 0) {\n        y = targetRect.height + y; // eslint-disable-line\n      }\n\n      var origin = targetRect.getTopLeft().translate(x, y);\n      var diff = clientRect.getCenter().diff(origin);\n      var scale = this.zoom();\n      var rawDiff = diff.scale(1 / scale, 1 / scale);\n      var result = Point.create(point).translate(rawDiff);\n      return this.centerPoint(result.x, result.y, localOptions);\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom(factor, options) {\n      if (factor == null) {\n        return this.sx;\n      }\n\n      options = options || {}; // eslint-disable-line\n\n      var cx;\n      var cy;\n      var clientSize = this.getClientSize();\n      var center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n      var sx = factor;\n      var sy = factor;\n\n      if (!options.absolute) {\n        sx += this.sx;\n        sy += this.sy;\n      }\n\n      if (options.scaleGrid) {\n        sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n        sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n      }\n\n      if (options.maxScale) {\n        sx = Math.min(options.maxScale, sx);\n        sy = Math.min(options.maxScale, sy);\n      }\n\n      if (options.minScale) {\n        sx = Math.max(options.minScale, sx);\n        sy = Math.max(options.minScale, sy);\n      }\n\n      sx = this.graph.transform.clampScale(sx);\n      sy = this.graph.transform.clampScale(sy);\n\n      if (options.center) {\n        var fx = sx / this.sx;\n        var fy = sy / this.sy;\n        cx = options.center.x - (options.center.x - center.x) / fx;\n        cy = options.center.y - (options.center.y - center.y) / fy;\n      } else {\n        cx = center.x;\n        cy = center.y;\n      }\n\n      this.beforeManipulation();\n      this.graph.transform.scale(sx, sy);\n      this.centerPoint(cx, cy);\n      this.afterManipulation();\n      return this;\n    }\n  }, {\n    key: \"zoomToRect\",\n    value: function zoomToRect(rect) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var area = Rectangle.create(rect);\n      var graph = this.graph;\n      options.contentArea = area;\n\n      if (options.viewportArea == null) {\n        options.viewportArea = {\n          x: graph.options.x,\n          y: graph.options.y,\n          width: this.$container.width(),\n          height: this.$container.height()\n        };\n      }\n\n      this.beforeManipulation();\n      graph.transform.scaleContentToFitImpl(options, false);\n      var center = area.getCenter();\n      this.centerPoint(center.x, center.y);\n      this.afterManipulation();\n      return this;\n    }\n  }, {\n    key: \"zoomToFit\",\n    value: function zoomToFit() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.zoomToRect(this.graph.getContentArea(options), options);\n    }\n  }, {\n    key: \"transitionToPoint\",\n    value: function transitionToPoint(x, y, options) {\n      var _this4 = this;\n\n      if (typeof x === 'object') {\n        options = y; // eslint-disable-line\n\n        y = x.y; // eslint-disable-line\n\n        x = x.x; // eslint-disable-line\n      } else {\n        y = y; // eslint-disable-line\n      }\n\n      if (options == null) {\n        options = {}; // eslint-disable-line\n      }\n\n      var transform;\n      var transformOrigin;\n      var scale = this.sx;\n      var targetScale = Math.max(options.scale || scale, 0.000001);\n      var clientSize = this.getClientSize();\n      var targetPoint = new Point(x, y);\n      var localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n\n      if (scale === targetScale) {\n        var translate = localPoint.diff(targetPoint).scale(scale, scale).round();\n        transform = \"translate(\".concat(translate.x, \"px,\").concat(translate.y, \"px)\");\n      } else {\n        var delta = targetScale / (scale - targetScale) * targetPoint.distance(localPoint);\n        var range = localPoint.clone().move(targetPoint, delta);\n        var origin = this.localToBackgroundPoint(range).round();\n        transform = \"scale(\".concat(targetScale / scale, \")\");\n        transformOrigin = \"\".concat(origin.x, \"px \").concat(origin.y, \"px\");\n      }\n\n      var onTransitionEnd = options.onTransitionEnd;\n      this.$container.addClass(Util.transitionClassName);\n      this.$content.off(Util.transitionEventName).on(Util.transitionEventName, function (e) {\n        _this4.syncTransition(targetScale, {\n          x: x,\n          y: y\n        });\n\n        if (typeof onTransitionEnd === 'function') {\n          FunctionExt.call(onTransitionEnd, _this4, e.originalEvent);\n        }\n      }).css({\n        transform: transform,\n        transformOrigin: transformOrigin,\n        transition: 'transform',\n        transitionDuration: options.duration || '1s',\n        transitionDelay: options.delay,\n        transitionTimingFunction: options.timing\n      });\n      return this;\n    }\n  }, {\n    key: \"syncTransition\",\n    value: function syncTransition(scale, p) {\n      this.beforeManipulation();\n      this.graph.scale(scale);\n      this.removeTransition();\n      this.centerPoint(p.x, p.y);\n      this.afterManipulation();\n      return this;\n    }\n  }, {\n    key: \"removeTransition\",\n    value: function removeTransition() {\n      this.$container.removeClass(Util.transitionClassName);\n      this.$content.off(Util.transitionEventName).css({\n        transform: '',\n        transformOrigin: '',\n        transition: '',\n        transitionDuration: '',\n        transitionDelay: '',\n        transitionTimingFunction: ''\n      });\n      return this;\n    }\n  }, {\n    key: \"transitionToRect\",\n    value: function transitionToRect(rectangle) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rect = Rectangle.create(rectangle);\n      var maxScale = options.maxScale || Infinity;\n      var minScale = options.minScale || Number.MIN_VALUE;\n      var scaleGrid = options.scaleGrid || null;\n      var PIXEL_SIZE = options.visibility || 1;\n      var center = options.center ? Point.create(options.center) : rect.getCenter();\n      var clientSize = this.getClientSize();\n      var w = clientSize.width * PIXEL_SIZE;\n      var h = clientSize.height * PIXEL_SIZE;\n      var scale = new Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);\n      scale = Math.min(scale, maxScale);\n\n      if (scaleGrid) {\n        scale = Math.floor(scale / scaleGrid) * scaleGrid;\n      }\n\n      scale = Math.max(minScale, scale);\n      return this.transitionToPoint(center, Object.assign({\n        scale: scale\n      }, options));\n    }\n  }, {\n    key: \"startPanning\",\n    value: function startPanning(evt) {\n      var e = this.normalizeEvent(evt);\n      this.clientX = e.clientX;\n      this.clientY = e.clientY;\n      this.trigger('pan:start', {\n        e: e\n      });\n      this.$(document.body).on({\n        'mousemove.panning touchmove.panning': this.pan.bind(this),\n        'mouseup.panning touchend.panning': this.stopPanning.bind(this),\n        'mouseleave.panning': this.stopPanning.bind(this)\n      });\n      this.$(window).on('mouseup.panning', this.stopPanning.bind(this));\n    }\n  }, {\n    key: \"pan\",\n    value: function pan(evt) {\n      var e = this.normalizeEvent(evt);\n      var dx = e.clientX - this.clientX;\n      var dy = e.clientY - this.clientY;\n      this.container.scrollTop -= dy;\n      this.container.scrollLeft -= dx;\n      this.clientX = e.clientX;\n      this.clientY = e.clientY;\n      this.trigger('panning', {\n        e: e\n      });\n    }\n  }, {\n    key: \"stopPanning\",\n    value: function stopPanning(e) {\n      this.$(document.body).off('.panning');\n      this.$(window).off('.panning');\n      this.trigger('pan:stop', {\n        e: e\n      });\n    }\n  }, {\n    key: \"clientToLocalPoint\",\n    value: function clientToLocalPoint(a, b) {\n      var x = typeof a === 'object' ? a.x : a;\n      var y = typeof a === 'object' ? a.y : b;\n      var ctm = this.graph.matrix();\n      x += this.container.scrollLeft - this.padding.left - ctm.e;\n      y += this.container.scrollTop - this.padding.top - ctm.f;\n      return new Point(x / ctm.a, y / ctm.d);\n    }\n  }, {\n    key: \"localToBackgroundPoint\",\n    value: function localToBackgroundPoint(x, y) {\n      var p = typeof x === 'object' ? Point.create(x) : new Point(x, y);\n      var ctm = this.graph.matrix();\n      var padding = this.padding;\n      return Dom.transformPoint(p, ctm).translate(padding.left, padding.top);\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      var w = width != null ? width : this.container.clientWidth;\n      var h = height != null ? height : this.container.clientHeight;\n\n      if (typeof w === 'number') {\n        w = Math.round(w);\n      }\n\n      if (typeof h === 'number') {\n        h = Math.round(h);\n      }\n\n      this.options.width = w;\n      this.options.height = h;\n      this.$container.css({\n        width: w,\n        height: h\n      });\n      this.update();\n    }\n  }, {\n    key: \"getClientSize\",\n    value: function getClientSize() {\n      if (this.cachedClientSize) {\n        return this.cachedClientSize;\n      }\n\n      return {\n        width: this.container.clientWidth,\n        height: this.container.clientHeight\n      };\n    }\n  }, {\n    key: \"autoScroll\",\n    value: function autoScroll(clientX, clientY) {\n      var buffer = 10;\n      var container = this.container;\n      var rect = container.getBoundingClientRect();\n      var dx = 0;\n      var dy = 0;\n\n      if (clientX <= rect.left + buffer) {\n        dx = -buffer;\n      }\n\n      if (clientY <= rect.top + buffer) {\n        dy = -buffer;\n      }\n\n      if (clientX >= rect.right - buffer) {\n        dx = buffer;\n      }\n\n      if (clientY >= rect.bottom - buffer) {\n        dy = buffer;\n      }\n\n      if (dx !== 0) {\n        container.scrollLeft += dx;\n      }\n\n      if (dy !== 0) {\n        container.scrollTop += dy;\n      }\n\n      return {\n        scrollerX: dx,\n        scrollerY: dy\n      };\n    }\n  }, {\n    key: \"addPadding\",\n    value: function addPadding(left, right, top, bottom) {\n      var padding = this.getPadding();\n      this.padding = {\n        left: Math.round(padding.left + (left || 0)),\n        top: Math.round(padding.top + (top || 0)),\n        bottom: Math.round(padding.bottom + (bottom || 0)),\n        right: Math.round(padding.right + (right || 0))\n      };\n      padding = this.padding;\n      this.$content.css({\n        width: padding.left + this.graph.options.width + padding.right,\n        height: padding.top + this.graph.options.height + padding.bottom\n      });\n      var container = this.graph.container;\n      container.style.left = \"\".concat(this.padding.left, \"px\");\n      container.style.top = \"\".concat(this.padding.top, \"px\");\n      return this;\n    }\n  }, {\n    key: \"getPadding\",\n    value: function getPadding() {\n      var padding = this.options.padding;\n\n      if (typeof padding === 'function') {\n        return NumberExt.normalizeSides(FunctionExt.call(padding, this, this));\n      }\n\n      return NumberExt.normalizeSides(padding);\n    }\n    /**\n     * Returns the untransformed size and origin of the current viewport.\n     */\n\n  }, {\n    key: \"getVisibleArea\",\n    value: function getVisibleArea() {\n      var ctm = this.graph.matrix();\n      var size = this.getClientSize();\n      var box = {\n        x: this.container.scrollLeft || 0,\n        y: this.container.scrollTop || 0,\n        width: size.width,\n        height: size.height\n      };\n      var area = Dom.transformRectangle(box, ctm.inverse());\n      area.x -= (this.padding.left || 0) / this.sx;\n      area.y -= (this.padding.top || 0) / this.sy;\n      return area;\n    }\n  }, {\n    key: \"isCellVisible\",\n    value: function isCellVisible(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var bbox = cell.getBBox();\n      var area = this.getVisibleArea();\n      return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n    }\n  }, {\n    key: \"isPointVisible\",\n    value: function isPointVisible(point) {\n      return this.getVisibleArea().containsPoint(point);\n    }\n    /**\n     * Lock the current viewport by disabling user scrolling.\n     */\n\n  }, {\n    key: \"lock\",\n    value: function lock() {\n      this.$container.css('overflow', 'hidden');\n      return this;\n    }\n    /**\n     * Enable user scrolling if previously locked.\n     */\n\n  }, {\n    key: \"unlock\",\n    value: function unlock() {\n      this.$container.css('overflow', 'scroll');\n      return this;\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.stopListening();\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.$(this.graph.container).insertBefore(this.$container);\n      this.remove();\n    }\n  }, {\n    key: \"graph\",\n    get: function get() {\n      return this.options.graph;\n    }\n  }, {\n    key: \"model\",\n    get: function get() {\n      return this.graph.model;\n    }\n  }]);\n\n  return Scroller;\n}(View);\n\n__decorate([View.dispose()], Scroller.prototype, \"dispose\", null);\n\n(function (Scroller) {\n  var Background = /*#__PURE__*/function (_BackgroundManager) {\n    _inherits(Background, _BackgroundManager);\n\n    function Background(scroller) {\n      var _this5;\n\n      _classCallCheck(this, Background);\n\n      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Background).call(this, scroller.graph));\n      _this5.scroller = scroller;\n\n      if (scroller.options.background) {\n        _this5.draw(scroller.options.background);\n      }\n\n      return _this5;\n    }\n\n    _createClass(Background, [{\n      key: \"init\",\n      value: function init() {\n        this.graph.on('scale', this.update, this);\n        this.graph.on('translate', this.update, this);\n      }\n    }, {\n      key: \"updateBackgroundOptions\",\n      value: function updateBackgroundOptions(options) {\n        this.scroller.options.background = options;\n      }\n    }, {\n      key: \"elem\",\n      get: function get() {\n        return this.scroller.background;\n      }\n    }]);\n\n    return Background;\n  }(BackgroundManager);\n\n  Scroller.Background = Background;\n})(Scroller || (Scroller = {}));\n\nvar Util;\n\n(function (Util) {\n  Util.containerClass = 'graph-scroller';\n  Util.panningClass = \"\".concat(Util.containerClass, \"-panning\");\n  Util.pannableClass = \"\".concat(Util.containerClass, \"-pannable\");\n  Util.pagedClass = \"\".concat(Util.containerClass, \"-paged\");\n  Util.contentClass = \"\".concat(Util.containerClass, \"-content\");\n  Util.backgroundClass = \"\".concat(Util.containerClass, \"-background\");\n  Util.transitionClassName = 'transition-in-progress';\n  Util.transitionEventName = 'transitionend.graph-scroller-transition';\n  Util.defaultOptions = {\n    padding: function padding() {\n      var size = this.getClientSize();\n      var minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;\n      var minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;\n      var left = Math.max(size.width - minWidth, 0);\n      var top = Math.max(size.height - minHeight, 0);\n      return {\n        left: left,\n        top: top,\n        right: left,\n        bottom: top\n      };\n    },\n    minVisibleWidth: 50,\n    minVisibleHeight: 50,\n    pageVisible: false,\n    pageBreak: false,\n    autoResize: true\n  };\n\n  function getOptions(options) {\n    var result = ObjectExt.merge({}, Util.defaultOptions, options);\n\n    if (result.pageWidth == null) {\n      result.pageWidth = options.graph.options.width;\n    }\n\n    if (result.pageHeight == null) {\n      result.pageHeight = options.graph.options.height;\n    }\n\n    return result;\n  }\n\n  Util.getOptions = getOptions;\n})(Util || (Util = {}));","map":null,"metadata":{},"sourceType":"module"}