{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { isNumber, isFunction, isArray, getDegree, isObject, getEdgeTerminal } from \"../util\";\n\nvar proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n\n  return func;\n};\n/**\n * graphin 中的 force 布局\n */\n\n\nexport var GForceLayout = /*#__PURE__*/function (_Base) {\n  _inherits(GForceLayout, _Base);\n\n  function GForceLayout(options) {\n    var _this;\n\n    _classCallCheck(this, GForceLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GForceLayout).call(this));\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 1000;\n    /** 是否启动 worker */\n\n    _this.workerEnabled = false;\n    /** 弹簧引力系数 */\n\n    _this.edgeStrength = 200;\n    /** 斥力系数 */\n\n    _this.nodeStrength = 1000;\n    /** 库伦系数 */\n\n    _this.coulombDisScale = 0.005;\n    /** 阻尼系数 */\n\n    _this.damping = 0.9;\n    /** 最大速度 */\n\n    _this.maxSpeed = 1000;\n    /** 一次迭代的平均移动距离小于该值时停止迭代 */\n\n    _this.minMovement = 0.5;\n    /** 迭代中衰减 */\n\n    _this.interval = 0.02;\n    /** 斥力的一个系数 */\n\n    _this.factor = 1;\n    /** 理想边长 */\n\n    _this.linkDistance = 1;\n    /** 重力大小 */\n\n    _this.gravity = 10;\n    /** 是否防止重叠 */\n\n    _this.preventOverlap = true;\n    /** 每次迭代结束的回调函数 */\n\n    _this.tick = function () {};\n\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.nodeMap = {};\n    _this.nodeIdxMap = {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(GForceLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        maxIteration: 500,\n        gravity: 10,\n        enableTick: true\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _a, _b;\n\n      var self = this;\n      var nodes = self.nodes;\n\n      if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n        window.clearInterval(self.timeInterval);\n      }\n\n      if (!nodes || nodes.length === 0) {\n        (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      var center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n        return;\n      }\n\n      var nodeMap = {};\n      var nodeIdxMap = {};\n      nodes.forEach(function (node, i) {\n        if (!isNumber(node.x)) node.x = Math.random() * self.width;\n        if (!isNumber(node.y)) node.y = Math.random() * self.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap;\n      self.linkDistance = proccessToFunc(self.linkDistance, 1);\n      self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n      self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // node size function\n\n      var nodeSize = self.nodeSize;\n      var nodeSizeFunc;\n\n      if (self.preventOverlap) {\n        var nodeSpacing = self.nodeSpacing;\n        var nodeSpacingFunc;\n\n        if (isNumber(nodeSpacing)) {\n          nodeSpacingFunc = function nodeSpacingFunc() {\n            return nodeSpacing;\n          };\n        } else if (isFunction(nodeSpacing)) {\n          nodeSpacingFunc = nodeSpacing;\n        } else {\n          nodeSpacingFunc = function nodeSpacingFunc() {\n            return 0;\n          };\n        }\n\n        if (!nodeSize) {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            if (d.size) {\n              if (isArray(d.size)) {\n                var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                return res + nodeSpacingFunc(d);\n              }\n\n              if (isObject(d.size)) {\n                var _res = d.size.width > d.size.height ? d.size.width : d.size.height;\n\n                return _res + nodeSpacingFunc(d);\n              }\n\n              return d.size + nodeSpacingFunc(d);\n            }\n\n            return 10 + nodeSpacingFunc(d);\n          };\n        } else if (isArray(nodeSize)) {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            return res + nodeSpacingFunc(d);\n          };\n        } else {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            return nodeSize + nodeSpacingFunc(d);\n          };\n        }\n      }\n\n      self.nodeSize = nodeSizeFunc;\n      var edges = self.edges;\n      self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n\n      if (!self.getMass) {\n        self.getMass = function (d) {\n          var mass = self.degrees[self.nodeIdxMap[d.id]] || 1;\n          return mass;\n        };\n      } // layout\n\n\n      self.run();\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _a;\n\n      var self = this;\n      var maxIteration = self.maxIteration,\n          nodes = self.nodes,\n          workerEnabled = self.workerEnabled,\n          minMovement = self.minMovement;\n      if (!nodes) return;\n\n      if (workerEnabled) {\n        for (var i = 0; i < maxIteration; i++) {\n          var previousPos = self.runOneStep(i);\n\n          if (self.reachMoveThreshold(nodes, previousPos, minMovement)) {\n            break;\n          }\n        }\n\n        (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n      } else {\n        if (typeof window === \"undefined\") return;\n        var iter = 0; // interval for render the result after each iteration\n\n        this.timeInterval = window.setInterval(function () {\n          var _a, _b;\n\n          if (!nodes) return;\n          var previousPos = self.runOneStep(iter) || [];\n\n          if (self.reachMoveThreshold(nodes, previousPos, minMovement)) {\n            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n            window.clearInterval(self.timeInterval);\n          }\n\n          iter++;\n\n          if (iter >= maxIteration) {\n            (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n            window.clearInterval(self.timeInterval);\n          }\n        }, 0);\n      }\n    }\n  }, {\n    key: \"reachMoveThreshold\",\n    value: function reachMoveThreshold(nodes, previousPos, minMovement) {\n      // whether to stop the iteration\n      var movement = 0;\n      nodes.forEach(function (node, j) {\n        var vx = node.x - previousPos[j].x;\n        var vy = node.y - previousPos[j].y;\n        movement += Math.sqrt(vx * vx + vy * vy);\n      });\n      movement /= nodes.length;\n      return movement < minMovement;\n    }\n  }, {\n    key: \"runOneStep\",\n    value: function runOneStep(iter) {\n      var _a;\n\n      var self = this;\n      var nodes = self.nodes,\n          edges = self.edges;\n      var accArray = [];\n      var velArray = [];\n      if (!nodes) return;\n      nodes.forEach(function (_, i) {\n        accArray[2 * i] = 0;\n        accArray[2 * i + 1] = 0;\n        velArray[2 * i] = 0;\n        velArray[2 * i + 1] = 0;\n      });\n      self.calRepulsive(accArray, nodes);\n      if (edges) self.calAttractive(accArray, edges);\n      self.calGravity(accArray, nodes);\n      var stepInterval = Math.max(0.02, self.interval - iter * 0.002);\n      self.updateVelocity(accArray, velArray, stepInterval, nodes);\n      var previousPos = [];\n      nodes.forEach(function (node) {\n        previousPos.push({\n          x: node.x,\n          y: node.y\n        });\n      });\n      self.updatePosition(velArray, stepInterval, nodes);\n      (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);\n      return previousPos;\n    }\n  }, {\n    key: \"calRepulsive\",\n    value: function calRepulsive(accArray, nodes) {\n      var self = this; // const nodes = self.nodes;\n\n      var getMass = self.getMass;\n      var nodeStrength = self.nodeStrength;\n      var factor = self.factor;\n      var coulombDisScale = self.coulombDisScale;\n      var preventOverlap = self.preventOverlap;\n      var nodeSize = self.nodeSize;\n      nodes.forEach(function (ni, i) {\n        var massi = getMass ? getMass(ni) : 1;\n        nodes.forEach(function (nj, j) {\n          if (i >= j) return; // if (!accArray[j]) accArray[j] = 0;\n\n          var vecX = ni.x - nj.x;\n          var vecY = ni.y - nj.y;\n          var vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n          var nVecLength = (vecLength + 0.1) * coulombDisScale;\n          var direX = vecX / vecLength;\n          var direY = vecY / vecLength;\n          var param = (nodeStrength(ni) + nodeStrength(nj)) / 2 * factor / (nVecLength * nVecLength);\n          var massj = getMass ? getMass(nj) : 1;\n          accArray[2 * i] += direX * param;\n          accArray[2 * i + 1] += direY * param;\n          accArray[2 * j] -= direX * param;\n          accArray[2 * j + 1] -= direY * param;\n\n          if (preventOverlap && vecLength < (nodeSize(ni) + nodeSize(nj)) / 2) {\n            var paramOverlap = (nodeStrength(ni) + nodeStrength(nj)) / 2 / (vecLength * vecLength);\n            accArray[2 * i] += direX * paramOverlap / massi;\n            accArray[2 * i + 1] += direY * paramOverlap / massi;\n            accArray[2 * j] -= direX * paramOverlap / massj;\n            accArray[2 * j + 1] -= direY * paramOverlap / massj;\n          }\n        });\n      });\n    }\n  }, {\n    key: \"calAttractive\",\n    value: function calAttractive(accArray, edges) {\n      var self = this; // const edges = self.edges;\n\n      var nodeMap = self.nodeMap;\n      var nodeIdxMap = self.nodeIdxMap;\n      var linkDistance = self.linkDistance;\n      var edgeStrength = self.edgeStrength;\n      var getMass = self.getMass;\n      edges.forEach(function (edge, i) {\n        var source = getEdgeTerminal(edge, 'source');\n        var target = getEdgeTerminal(edge, 'target');\n        var sourceNode = nodeMap[source];\n        var targetNode = nodeMap[target];\n        var vecX = targetNode.x - sourceNode.x;\n        var vecY = targetNode.y - sourceNode.y;\n        var vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n        var direX = vecX / vecLength;\n        var direY = vecY / vecLength;\n        var length = linkDistance(edge) || 1;\n        var diff = length - vecLength;\n        var param = diff * edgeStrength(edge);\n        var sourceIdx = nodeIdxMap[source];\n        var targetIdx = nodeIdxMap[target];\n        var massSource = getMass ? getMass(sourceNode) : 1;\n        var massTarget = getMass ? getMass(targetNode) : 1;\n        accArray[2 * sourceIdx] -= direX * param / massSource;\n        accArray[2 * sourceIdx + 1] -= direY * param / massSource;\n        accArray[2 * targetIdx] += direX * param / massTarget;\n        accArray[2 * targetIdx + 1] += direY * param / massTarget;\n      });\n    }\n  }, {\n    key: \"calGravity\",\n    value: function calGravity(accArray, nodes) {\n      var self = this; // const nodes = self.nodes;\n\n      var center = self.center;\n      var defaultGravity = self.gravity;\n      var degrees = self.degrees;\n      var nodeLength = nodes.length;\n\n      for (var i = 0; i < nodeLength; i++) {\n        var node = nodes[i];\n        var vecX = node.x - center[0];\n        var vecY = node.y - center[1];\n        var gravity = defaultGravity;\n\n        if (self.getCenter) {\n          var customCenterOpt = self.getCenter(node, degrees[i]);\n\n          if (customCenterOpt && isNumber(customCenterOpt[0]) && isNumber(customCenterOpt[1]) && isNumber(customCenterOpt[2])) {\n            vecX = node.x - customCenterOpt[0];\n            vecY = node.y - customCenterOpt[1];\n            gravity = customCenterOpt[2];\n          }\n        }\n\n        if (!gravity) continue;\n        accArray[2 * i] -= gravity * vecX;\n        accArray[2 * i + 1] -= gravity * vecY;\n      }\n    }\n  }, {\n    key: \"updateVelocity\",\n    value: function updateVelocity(accArray, velArray, stepInterval, nodes) {\n      var self = this;\n      var param = stepInterval * self.damping; // const nodes = self.nodes;\n\n      nodes.forEach(function (node, i) {\n        var vx = accArray[2 * i] * param || 0.01;\n        var vy = accArray[2 * i + 1] * param || 0.01;\n        var vLength = Math.sqrt(vx * vx + vy * vy);\n\n        if (vLength > self.maxSpeed) {\n          var param2 = self.maxSpeed / vLength;\n          vx = param2 * vx;\n          vy = param2 * vy;\n        }\n\n        velArray[2 * i] = vx;\n        velArray[2 * i + 1] = vy;\n      });\n    }\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(velArray, stepInterval, nodes) {\n      nodes.forEach(function (node, i) {\n        if (isNumber(node.fx) && isNumber(node.fy)) {\n          node.x = node.fx;\n          node.y = node.fy;\n          return;\n        }\n\n        var distX = velArray[2 * i] * stepInterval;\n        var distY = velArray[2 * i + 1] * stepInterval;\n        node.x += distX;\n        node.y += distY;\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.timeInterval && typeof window !== \"undefined\") {\n        window.clearInterval(this.timeInterval);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var self = this;\n      self.stop();\n      self.tick = null;\n      self.nodes = null;\n      self.edges = null;\n      self.destroyed = true;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"gForce\";\n    }\n  }]);\n\n  return GForceLayout;\n}(Base);","map":null,"metadata":{},"sourceType":"module"}