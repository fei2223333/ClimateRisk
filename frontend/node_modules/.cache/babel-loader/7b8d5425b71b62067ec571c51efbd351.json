{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Point } from './point';\nimport { Line } from './line';\nimport { Rectangle } from './rectangle';\nimport { Polyline } from './polyline';\nimport { Geometry } from './geometry';\nexport var Curve = /*#__PURE__*/function (_Geometry) {\n  _inherits(Curve, _Geometry);\n\n  function Curve(start, controlPoint1, controlPoint2, end) {\n    var _this;\n\n    _classCallCheck(this, Curve);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Curve).call(this));\n    _this.PRECISION = 3;\n    _this.start = Point.create(start);\n    _this.controlPoint1 = Point.create(controlPoint1);\n    _this.controlPoint2 = Point.create(controlPoint2);\n    _this.end = Point.create(end);\n    return _this;\n  }\n\n  _createClass(Curve, [{\n    key: \"bbox\",\n    value: function bbox() {\n      var start = this.start;\n      var controlPoint1 = this.controlPoint1;\n      var controlPoint2 = this.controlPoint2;\n      var end = this.end;\n      var x0 = start.x;\n      var y0 = start.y;\n      var x1 = controlPoint1.x;\n      var y1 = controlPoint1.y;\n      var x2 = controlPoint2.x;\n      var y2 = controlPoint2.y;\n      var x3 = end.x;\n      var y3 = end.y;\n      var points = []; // local extremes\n\n      var tvalues = []; // t values of local extremes\n\n      var bounds = [[], []];\n      var a;\n      var b;\n      var c;\n      var t;\n      var t1;\n      var t2;\n      var b2ac;\n      var sqrtb2ac;\n\n      for (var i = 0; i < 2; i += 1) {\n        if (i === 0) {\n          b = 6 * x0 - 12 * x1 + 6 * x2;\n          a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n          c = 3 * x1 - 3 * x0;\n        } else {\n          b = 6 * y0 - 12 * y1 + 6 * y2;\n          a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n          c = 3 * y1 - 3 * y0;\n        }\n\n        if (Math.abs(a) < 1e-12) {\n          if (Math.abs(b) < 1e-12) {\n            continue;\n          }\n\n          t = -c / b;\n          if (t > 0 && t < 1) tvalues.push(t);\n          continue;\n        }\n\n        b2ac = b * b - 4 * c * a;\n        sqrtb2ac = Math.sqrt(b2ac);\n        if (b2ac < 0) continue;\n        t1 = (-b + sqrtb2ac) / (2 * a);\n        if (t1 > 0 && t1 < 1) tvalues.push(t1);\n        t2 = (-b - sqrtb2ac) / (2 * a);\n        if (t2 > 0 && t2 < 1) tvalues.push(t2);\n      }\n\n      var x;\n      var y;\n      var mt;\n      var j = tvalues.length;\n      var jlen = j;\n\n      while (j) {\n        j -= 1;\n        t = tvalues[j];\n        mt = 1 - t;\n        x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n        bounds[0][j] = x;\n        y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n        bounds[1][j] = y;\n        points[j] = {\n          X: x,\n          Y: y\n        };\n      }\n\n      tvalues[jlen] = 0;\n      tvalues[jlen + 1] = 1;\n      points[jlen] = {\n        X: x0,\n        Y: y0\n      };\n      points[jlen + 1] = {\n        X: x3,\n        Y: y3\n      };\n      bounds[0][jlen] = x0;\n      bounds[1][jlen] = y0;\n      bounds[0][jlen + 1] = x3;\n      bounds[1][jlen + 1] = y3;\n      tvalues.length = jlen + 2;\n      bounds[0].length = jlen + 2;\n      bounds[1].length = jlen + 2;\n      points.length = jlen + 2;\n      var left = Math.min.apply(null, bounds[0]);\n      var top = Math.min.apply(null, bounds[1]);\n      var right = Math.max.apply(null, bounds[0]);\n      var bottom = Math.max.apply(null, bounds[1]);\n      return new Rectangle(left, top, right - left, bottom - top);\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.pointAtT(this.closestPointT(p, options));\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var opts = this.getOptions(options);\n      return this.lengthAtT(this.closestPointT(p, opts), opts);\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var opts = this.getOptions(options);\n      var cpLength = this.closestPointLength(p, opts);\n\n      if (!cpLength) {\n        return 0;\n      }\n\n      var length = this.length(opts);\n\n      if (length === 0) {\n        return 0;\n      }\n\n      return cpLength / length;\n    }\n  }, {\n    key: \"closestPointT\",\n    value: function closestPointT(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var precision = this.getPrecision(options);\n      var subdivisions = this.getDivisions(options);\n      var precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n\n      var investigatedSubdivision = null;\n      var investigatedSubdivisionStartT = 0;\n      var investigatedSubdivisionEndT = 0;\n      var distFromStart = 0;\n      var distFromEnd = 0;\n      var chordLength = 0;\n      var minSumDist = null;\n      var count = subdivisions.length;\n      var piece = count > 0 ? 1 / count : 0;\n      subdivisions.forEach(function (division, i) {\n        var startDist = division.start.distance(p);\n        var endDist = division.end.distance(p);\n        var sumDist = startDist + endDist;\n\n        if (minSumDist == null || sumDist < minSumDist) {\n          investigatedSubdivision = division;\n          investigatedSubdivisionStartT = i * piece;\n          investigatedSubdivisionEndT = (i + 1) * piece;\n          distFromStart = startDist;\n          distFromEnd = endDist;\n          minSumDist = sumDist;\n          chordLength = division.endpointDistance();\n        }\n      }); // Recursively divide investigated subdivision, until distance between\n      // baselinePoint and closest path endpoint is within `10^(-precision)`,\n      // then return the closest endpoint of that final subdivision.\n      // eslint-disable-next-line\n\n      while (true) {\n        // check if we have reached at least one required observed precision\n        // - calculated as: the difference in distances from point to start and end divided by the distance\n        // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n        // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n        // - this criterion works well for points lying far away from the curve\n        var startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;\n        var endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;\n        var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio; // check if we have reached at least one required minimal distance\n        // - calculated as: the subdivision chord length multiplied by precisionRatio\n        // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n        // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\n        var hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n        var hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n        var hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;\n\n        if (hasRequiredPrecision || hasMiniDistance) {\n          return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n        } // otherwise, set up for next iteration\n\n\n        var divided = investigatedSubdivision.divide(0.5);\n        piece /= 2;\n        var startDist1 = divided[0].start.distance(p);\n        var endDist1 = divided[0].end.distance(p);\n        var sumDist1 = startDist1 + endDist1;\n        var startDist2 = divided[1].start.distance(p);\n        var endDist2 = divided[1].end.distance(p);\n        var sumDist2 = startDist2 + endDist2;\n\n        if (sumDist1 <= sumDist2) {\n          investigatedSubdivision = divided[0];\n          investigatedSubdivisionEndT -= piece;\n          distFromStart = startDist1;\n          distFromEnd = endDist1;\n        } else {\n          investigatedSubdivision = divided[1];\n          investigatedSubdivisionStartT += piece;\n          distFromStart = startDist2;\n          distFromEnd = endDist2;\n        }\n      }\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.tangentAtT(this.closestPointT(p, options));\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var polyline = this.toPolyline(options);\n      return polyline.containsPoint(p);\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (ratio <= 0) {\n        return this.divideAtT(0);\n      }\n\n      if (ratio >= 1) {\n        return this.divideAtT(1);\n      }\n\n      var t = this.tAt(ratio, options);\n      return this.divideAtT(t);\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var t = this.tAtLength(length, options);\n      return this.divideAtT(t);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(t) {\n      return this.divideAtT(t);\n    }\n  }, {\n    key: \"divideAtT\",\n    value: function divideAtT(t) {\n      var start = this.start;\n      var controlPoint1 = this.controlPoint1;\n      var controlPoint2 = this.controlPoint2;\n      var end = this.end;\n\n      if (t <= 0) {\n        return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n      }\n\n      if (t >= 1) {\n        return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n      }\n\n      var dividerPoints = this.getSkeletonPoints(t);\n      var startControl1 = dividerPoints.startControlPoint1;\n      var startControl2 = dividerPoints.startControlPoint2;\n      var divider = dividerPoints.divider;\n      var dividerControl1 = dividerPoints.dividerControlPoint1;\n      var dividerControl2 = dividerPoints.dividerControlPoint2;\n      return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n    }\n  }, {\n    key: \"endpointDistance\",\n    value: function endpointDistance() {\n      return this.start.distance(this.end);\n    }\n  }, {\n    key: \"getSkeletonPoints\",\n    value: function getSkeletonPoints(t) {\n      var start = this.start;\n      var control1 = this.controlPoint1;\n      var control2 = this.controlPoint2;\n      var end = this.end; // shortcuts for `t` values that are out of range\n\n      if (t <= 0) {\n        return {\n          startControlPoint1: start.clone(),\n          startControlPoint2: start.clone(),\n          divider: start.clone(),\n          dividerControlPoint1: control1.clone(),\n          dividerControlPoint2: control2.clone()\n        };\n      }\n\n      if (t >= 1) {\n        return {\n          startControlPoint1: control1.clone(),\n          startControlPoint2: control2.clone(),\n          divider: end.clone(),\n          dividerControlPoint1: end.clone(),\n          dividerControlPoint2: end.clone()\n        };\n      }\n\n      var midpoint1 = new Line(start, control1).pointAt(t);\n      var midpoint2 = new Line(control1, control2).pointAt(t);\n      var midpoint3 = new Line(control2, end).pointAt(t);\n      var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n      var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n      var divideLine = new Line(subControl1, subControl2).pointAt(t);\n      return {\n        startControlPoint1: midpoint1,\n        startControlPoint2: subControl1,\n        divider: divideLine,\n        dividerControlPoint1: subControl2,\n        dividerControlPoint2: midpoint3\n      };\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var precision = this.getPrecision(options);\n      var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n\n      if (precision === 0) {\n        return subdivisions;\n      }\n\n      var previousLength = this.endpointDistance();\n      var precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n      // Recursively divide curve at `t = 0.5`, until the difference between\n      // observed length at subsequent iterations is lower than precision.\n\n      var iteration = 0; // eslint-disable-next-line\n\n      var _loop = function _loop() {\n        iteration += 1;\n        var divisions = [];\n        subdivisions.forEach(function (c) {\n          // dividing at t = 0.5 (not at middle length!)\n          var divided = c.divide(0.5);\n          divisions.push(divided[0], divided[1]);\n        }); // measure new length\n\n        var length = divisions.reduce(function (memo, c) {\n          return memo + c.endpointDistance();\n        }, 0); // check if we have reached required observed precision\n        // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n        // not a problem for further iterations because cubic curves cannot have more than two local extrema\n        // (i.e. cubic curves cannot intersect the baseline more than once)\n        // therefore two subsequent iterations cannot produce sampling with equal length\n\n        var ratio = length !== 0 ? (length - previousLength) / length : 0;\n\n        if (iteration > 1 && ratio < precisionRatio) {\n          return {\n            v: divisions\n          };\n        }\n\n        subdivisions = divisions;\n        previousLength = length;\n      };\n\n      while (true) {\n        var _ret = _loop();\n\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var divisions = this.getDivisions(options);\n      return divisions.reduce(function (memo, c) {\n        return memo + c.endpointDistance();\n      }, 0);\n    }\n  }, {\n    key: \"lengthAtT\",\n    value: function lengthAtT(t) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (t <= 0) {\n        return 0;\n      }\n\n      var precision = options.precision === undefined ? this.PRECISION : options.precision;\n      var subCurve = this.divide(t)[0];\n      return subCurve.length({\n        precision: precision\n      });\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (ratio <= 0) {\n        return this.start.clone();\n      }\n\n      if (ratio >= 1) {\n        return this.end.clone();\n      }\n\n      var t = this.tAt(ratio, options);\n      return this.pointAtT(t);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var t = this.tAtLength(length, options);\n      return this.pointAtT(t);\n    }\n  }, {\n    key: \"pointAtT\",\n    value: function pointAtT(t) {\n      if (t <= 0) {\n        return this.start.clone();\n      }\n\n      if (t >= 1) {\n        return this.end.clone();\n      }\n\n      return this.getSkeletonPoints(t).divider;\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      var start = this.start;\n      var control1 = this.controlPoint1;\n      var control2 = this.controlPoint2;\n      var end = this.end;\n      return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!this.isDifferentiable()) return null;\n\n      if (ratio < 0) {\n        ratio = 0; // eslint-disable-line\n      } else if (ratio > 1) {\n        ratio = 1; // eslint-disable-line\n      }\n\n      var t = this.tAt(ratio, options);\n      return this.tangentAtT(t);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.isDifferentiable()) {\n        return null;\n      }\n\n      var t = this.tAtLength(length, options);\n      return this.tangentAtT(t);\n    }\n  }, {\n    key: \"tangentAtT\",\n    value: function tangentAtT(t) {\n      if (!this.isDifferentiable()) {\n        return null;\n      }\n\n      if (t < 0) {\n        t = 0; // eslint-disable-line\n      }\n\n      if (t > 1) {\n        t = 1; // eslint-disable-line\n      }\n\n      var skeletonPoints = this.getSkeletonPoints(t);\n      var p1 = skeletonPoints.startControlPoint2;\n      var p2 = skeletonPoints.dividerControlPoint1;\n      var tangentStart = skeletonPoints.divider;\n      var tangentLine = new Line(p1, p2); // move so that tangent line starts at the point requested\n\n      tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);\n      return tangentLine;\n    }\n  }, {\n    key: \"getPrecision\",\n    value: function getPrecision() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return options.precision == null ? this.PRECISION : options.precision;\n    }\n  }, {\n    key: \"getDivisions\",\n    value: function getDivisions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.subdivisions != null) {\n        return options.subdivisions;\n      }\n\n      var precision = this.getPrecision(options);\n      return this.getSubdivisions({\n        precision: precision\n      });\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var precision = this.getPrecision(options);\n      var subdivisions = this.getDivisions(options);\n      return {\n        precision: precision,\n        subdivisions: subdivisions\n      };\n    }\n  }, {\n    key: \"tAt\",\n    value: function tAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (ratio <= 0) {\n        return 0;\n      }\n\n      if (ratio >= 1) {\n        return 1;\n      }\n\n      var opts = this.getOptions(options);\n      var total = this.length(opts);\n      var length = total * ratio;\n      return this.tAtLength(length, opts);\n    }\n  }, {\n    key: \"tAtLength\",\n    value: function tAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var subdivisions = this.getDivisions(options);\n      var opts = {\n        precision: precision,\n        subdivisions: subdivisions\n      };\n      var investigatedSubdivision = null;\n      var investigatedSubdivisionStartT;\n      var investigatedSubdivisionEndT;\n      var baselinePointDistFromStart = 0;\n      var baselinePointDistFromEnd = 0;\n      var memo = 0;\n      var count = subdivisions.length;\n      var piece = count > 0 ? 1 / count : 0;\n\n      for (var i = 0; i < count; i += 1) {\n        var index = fromStart ? i : count - 1 - i;\n        var division = subdivisions[i];\n        var dist = division.endpointDistance();\n\n        if (length <= memo + dist) {\n          investigatedSubdivision = division;\n          investigatedSubdivisionStartT = index * piece;\n          investigatedSubdivisionEndT = (index + 1) * piece;\n          baselinePointDistFromStart = fromStart ? length - memo : dist + memo - length;\n          baselinePointDistFromEnd = fromStart ? dist + memo - length : length - memo;\n          break;\n        }\n\n        memo += dist;\n      }\n\n      if (investigatedSubdivision == null) {\n        return fromStart ? 1 : 0;\n      } // note that precision affects what length is recorded\n      // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n      // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n\n      var total = this.length(opts);\n      var precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n      // recursively divide investigated subdivision:\n      // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n      // then return the closest endpoint of that final subdivision\n      // eslint-disable-next-line\n\n      while (true) {\n        var ratio = void 0;\n        ratio = total !== 0 ? baselinePointDistFromStart / total : 0;\n\n        if (ratio < precisionRatio) {\n          return investigatedSubdivisionStartT;\n        }\n\n        ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;\n\n        if (ratio < precisionRatio) {\n          return investigatedSubdivisionEndT;\n        } // otherwise, set up for next iteration\n\n\n        var newBaselinePointDistFromStart = void 0;\n        var newBaselinePointDistFromEnd = void 0;\n        var divided = investigatedSubdivision.divide(0.5);\n        piece /= 2;\n        var baseline1Length = divided[0].endpointDistance();\n        var baseline2Length = divided[1].endpointDistance();\n\n        if (baselinePointDistFromStart <= baseline1Length) {\n          investigatedSubdivision = divided[0];\n          investigatedSubdivisionEndT -= piece;\n          newBaselinePointDistFromStart = baselinePointDistFromStart;\n          newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n        } else {\n          investigatedSubdivision = divided[1];\n          investigatedSubdivisionStartT += piece;\n          newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n          newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n        }\n\n        baselinePointDistFromStart = newBaselinePointDistFromStart;\n        baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n      }\n    }\n  }, {\n    key: \"toPoints\",\n    value: function toPoints() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var subdivisions = this.getDivisions(options);\n      var points = [subdivisions[0].start.clone()];\n      subdivisions.forEach(function (c) {\n        return points.push(c.end.clone());\n      });\n      return points;\n    }\n  }, {\n    key: \"toPolyline\",\n    value: function toPolyline() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Polyline(this.toPoints(options));\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.start.scale(sx, sy, origin);\n      this.controlPoint1.scale(sx, sy, origin);\n      this.controlPoint2.scale(sx, sy, origin);\n      this.end.scale(sx, sy, origin);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.start.rotate(angle, origin);\n      this.controlPoint1.rotate(angle, origin);\n      this.controlPoint2.rotate(angle, origin);\n      this.end.rotate(angle, origin);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n      } else {\n        this.start.translate(tx);\n        this.controlPoint1.translate(tx);\n        this.controlPoint2.translate(tx);\n        this.end.translate(tx);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(c) {\n      return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        start: this.start.toJSON(),\n        controlPoint1: this.controlPoint1.toJSON(),\n        controlPoint2: this.controlPoint2.toJSON(),\n        end: this.end.toJSON()\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return [this.start.serialize(), this.controlPoint1.serialize(), this.controlPoint2.serialize(), this.end.serialize()].join(' ');\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Curve.toStringTag;\n    }\n  }]);\n\n  return Curve;\n}(Geometry);\n\n(function (Curve) {\n  Curve.toStringTag = \"X6.Geometry.\".concat(Curve.name);\n\n  function isCurve(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Curve) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var curve = instance;\n\n    try {\n      if ((tag == null || tag === Curve.toStringTag) && Point.isPoint(curve.start) && Point.isPoint(curve.controlPoint1) && Point.isPoint(curve.controlPoint2) && Point.isPoint(curve.end) && typeof curve.toPoints === 'function' && typeof curve.toPolyline === 'function') {\n        return true;\n      }\n    } catch (e) {\n      return false;\n    }\n\n    return false;\n  }\n\n  Curve.isCurve = isCurve;\n})(Curve || (Curve = {}));\n\n(function (Curve) {\n  function getFirstControlPoints(rhs) {\n    var n = rhs.length;\n    var x = []; // `x` is a solution vector.\n\n    var tmp = [];\n    var b = 2.0;\n    x[0] = rhs[0] / b; // Decomposition and forward substitution.\n\n    for (var i = 1; i < n; i += 1) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (var _i = 1; _i < n; _i += 1) {\n      // Backsubstitution.\n      x[n - _i - 1] -= tmp[n - _i] * x[n - _i];\n    }\n\n    return x;\n  }\n\n  function getCurveControlPoints(points) {\n    var knots = points.map(function (p) {\n      return Point.clone(p);\n    });\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1; // Special case: Bezier curve should be a straight line.\n\n    if (n === 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 â€“ P0\n\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    } // Calculate first Bezier control points.\n    // Right hand side vector.\n\n\n    var rhs = []; // Set right hand side X values.\n\n    for (var i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.\n\n    var x = getFirstControlPoints(rhs); // Set right hand side Y values.\n\n    for (var _i2 = 1; _i2 < n - 1; _i2 += 1) {\n      rhs[_i2] = 4 * knots[_i2].y + 2 * knots[_i2 + 1].y;\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.\n\n    var y = getFirstControlPoints(rhs); // Fill output arrays.\n\n    for (var _i3 = 0; _i3 < n; _i3 += 1) {\n      // First control point.\n      firstControlPoints.push(new Point(x[_i3], y[_i3])); // Second control point.\n\n      if (_i3 < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[_i3 + 1].x - x[_i3 + 1], 2 * knots[_i3 + 1].y - y[_i3 + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints];\n  }\n\n  function throughPoints(points) {\n    if (points == null || Array.isArray(points) && points.length < 2) {\n      throw new Error('At least 2 points are required');\n    }\n\n    var controlPoints = getCurveControlPoints(points);\n    var curves = [];\n\n    for (var i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n      var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n      var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n    }\n\n    return curves;\n  }\n\n  Curve.throughPoints = throughPoints;\n})(Curve || (Curve = {}));","map":null,"metadata":{},"sourceType":"module"}