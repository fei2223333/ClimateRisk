{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GForceLayout = void 0;\n\nvar base_1 = require(\"./base\");\n\nvar util_1 = require(\"../util\");\n\nvar proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if ((0, util_1.isNumber)(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n\n  return func;\n};\n/**\n * graphin 中的 force 布局\n */\n\n\nvar GForceLayout =\n/** @class */\nfunction (_super) {\n  __extends(GForceLayout, _super);\n\n  function GForceLayout(options) {\n    var _this = _super.call(this) || this;\n    /** 停止迭代的最大迭代数 */\n\n\n    _this.maxIteration = 500;\n    /** 是否启动 worker */\n\n    _this.workerEnabled = false;\n    /** 弹簧引力系数 */\n\n    _this.edgeStrength = 200;\n    /** 斥力系数 */\n\n    _this.nodeStrength = 1000;\n    /** 库伦系数 */\n\n    _this.coulombDisScale = 0.005;\n    /** 阻尼系数 */\n\n    _this.damping = 0.9;\n    /** 最大速度 */\n\n    _this.maxSpeed = 1000;\n    /** 一次迭代的平均移动距离小于该值时停止迭代 */\n\n    _this.minMovement = 0.5;\n    /** 迭代中衰减 */\n\n    _this.interval = 0.02;\n    /** 斥力的一个系数 */\n\n    _this.factor = 1;\n    /** 理想边长 */\n\n    _this.linkDistance = 1;\n    /** 重力大小 */\n\n    _this.gravity = 10;\n    /** 是否防止重叠 */\n\n    _this.preventOverlap = true;\n    /** 防止重叠的力大小参数 */\n\n    _this.collideStrength = 1;\n    /** 每次迭代结束的回调函数 */\n\n    _this.tick = function () {};\n\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.nodeMap = {};\n    _this.nodeIdxMap = {};\n    /** 是否使用 window.setInterval 运行迭代 */\n\n    _this.animate = true;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  GForceLayout.prototype.getDefaultCfg = function () {\n    return {\n      maxIteration: 500,\n      gravity: 10,\n      enableTick: true,\n      animate: true\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  GForceLayout.prototype.execute = function () {\n    var _a, _b;\n\n    var self = this;\n    var nodes = self.nodes;\n\n    if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n      window.clearInterval(self.timeInterval);\n    }\n\n    if (!nodes || nodes.length === 0) {\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    var center = self.center;\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n      return;\n    }\n\n    var nodeMap = {};\n    var nodeIdxMap = {};\n    nodes.forEach(function (node, i) {\n      if (!(0, util_1.isNumber)(node.x)) node.x = Math.random() * self.width;\n      if (!(0, util_1.isNumber)(node.y)) node.y = Math.random() * self.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n    self.linkDistance = proccessToFunc(self.linkDistance, 1);\n    self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n    self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // node size function\n\n    var nodeSize = self.nodeSize;\n    var nodeSizeFunc;\n\n    if (self.preventOverlap) {\n      var nodeSpacing_1 = self.nodeSpacing;\n      var nodeSpacingFunc_1;\n\n      if ((0, util_1.isNumber)(nodeSpacing_1)) {\n        nodeSpacingFunc_1 = function nodeSpacingFunc_1() {\n          return nodeSpacing_1;\n        };\n      } else if ((0, util_1.isFunction)(nodeSpacing_1)) {\n        nodeSpacingFunc_1 = nodeSpacing_1;\n      } else {\n        nodeSpacingFunc_1 = function nodeSpacingFunc_1() {\n          return 0;\n        };\n      }\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if ((0, util_1.isArray)(d.size)) {\n              return Math.max(d.size[0], d.size[1]) + nodeSpacingFunc_1(d);\n            }\n\n            if ((0, util_1.isObject)(d.size)) {\n              return Math.max(d.size.width, d.size.height) + nodeSpacingFunc_1(d);\n            }\n\n            return d.size + nodeSpacingFunc_1(d);\n          }\n\n          return 10 + nodeSpacingFunc_1(d);\n        };\n      } else if ((0, util_1.isArray)(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return Math.max(nodeSize[0], nodeSize[1]) + nodeSpacingFunc_1(d);\n        };\n      } else {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return nodeSize + nodeSpacingFunc_1(d);\n        };\n      }\n    }\n\n    self.nodeSize = nodeSizeFunc;\n    var edges = self.edges;\n    self.degrees = (0, util_1.getDegree)(nodes.length, self.nodeIdxMap, edges);\n\n    if (!self.getMass) {\n      self.getMass = function (d) {\n        var mass = d.mass || self.degrees[self.nodeIdxMap[d.id]] || 1;\n        return mass;\n      };\n    } // layout\n\n\n    self.run();\n  };\n\n  GForceLayout.prototype.run = function () {\n    var _a;\n\n    var self = this;\n    var maxIteration = self.maxIteration,\n        nodes = self.nodes,\n        workerEnabled = self.workerEnabled,\n        minMovement = self.minMovement,\n        animate = self.animate;\n    if (!nodes) return;\n\n    if (workerEnabled || !animate) {\n      for (var i = 0; i < maxIteration; i++) {\n        var previousPos = self.runOneStep(i);\n\n        if (self.reachMoveThreshold(nodes, previousPos, minMovement)) {\n          break;\n        }\n      }\n\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n    } else {\n      if (typeof window === \"undefined\") return;\n      var iter_1 = 0; // interval for render the result after each iteration\n\n      this.timeInterval = window.setInterval(function () {\n        var _a, _b;\n\n        if (!nodes) return;\n        var previousPos = self.runOneStep(iter_1) || [];\n\n        if (self.reachMoveThreshold(nodes, previousPos, minMovement)) {\n          (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n          window.clearInterval(self.timeInterval);\n        }\n\n        iter_1++;\n\n        if (iter_1 >= maxIteration) {\n          (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n          window.clearInterval(self.timeInterval);\n        }\n      }, 0);\n    }\n  };\n\n  GForceLayout.prototype.reachMoveThreshold = function (nodes, previousPos, minMovement) {\n    // whether to stop the iteration\n    var movement = 0;\n    nodes.forEach(function (node, j) {\n      var vx = node.x - previousPos[j].x;\n      var vy = node.y - previousPos[j].y;\n      movement += Math.sqrt(vx * vx + vy * vy);\n    });\n    movement /= nodes.length;\n    return movement < minMovement;\n  };\n\n  GForceLayout.prototype.runOneStep = function (iter) {\n    var _a;\n\n    var self = this;\n    var nodes = self.nodes,\n        edges = self.edges;\n    var accArray = [];\n    var velArray = [];\n    if (!nodes) return;\n    nodes.forEach(function (_, i) {\n      accArray[2 * i] = 0;\n      accArray[2 * i + 1] = 0;\n      velArray[2 * i] = 0;\n      velArray[2 * i + 1] = 0;\n    });\n    self.calRepulsive(accArray, nodes);\n    if (edges) self.calAttractive(accArray, edges);\n    self.calGravity(accArray, nodes);\n    var stepInterval = Math.max(0.02, self.interval - iter * 0.002);\n    self.updateVelocity(accArray, velArray, stepInterval, nodes);\n    var previousPos = [];\n    nodes.forEach(function (node) {\n      previousPos.push({\n        x: node.x,\n        y: node.y\n      });\n    });\n    self.updatePosition(velArray, stepInterval, nodes);\n    (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);\n    return previousPos;\n  };\n\n  GForceLayout.prototype.calRepulsive = function (accArray, nodes) {\n    var self = this;\n    var getMass = self.getMass,\n        factor = self.factor,\n        coulombDisScale = self.coulombDisScale,\n        preventOverlap = self.preventOverlap,\n        _a = self.collideStrength,\n        collideStrength = _a === void 0 ? 1 : _a;\n    var nodeStrength = self.nodeStrength;\n    var nodeSize = self.nodeSize;\n    nodes.forEach(function (ni, i) {\n      var massi = getMass ? getMass(ni) : 1;\n      nodes.forEach(function (nj, j) {\n        if (i >= j) return; // if (!accArray[j]) accArray[j] = 0;\n\n        var vecX = ni.x - nj.x;\n        var vecY = ni.y - nj.y;\n\n        if (vecX === 0 && vecY === 0) {\n          vecX = Math.random() * 0.01;\n          vecY = Math.random() * 0.01;\n        }\n\n        var lengthSqr = vecX * vecX + vecY * vecY;\n        var vecLength = Math.sqrt(lengthSqr);\n        var nVecLength = (vecLength + 0.1) * coulombDisScale;\n        var direX = vecX / vecLength;\n        var direY = vecY / vecLength;\n        var param = (nodeStrength(ni) + nodeStrength(nj)) * 0.5 * factor / (nVecLength * nVecLength);\n        var massj = getMass ? getMass(nj) : 1;\n        accArray[2 * i] += direX * param;\n        accArray[2 * i + 1] += direY * param;\n        accArray[2 * j] -= direX * param;\n        accArray[2 * j + 1] -= direY * param;\n\n        if (preventOverlap && (nodeSize(ni) + nodeSize(nj)) / 2 > vecLength) {\n          var paramOverlap = collideStrength * (nodeStrength(ni) + nodeStrength(nj)) * 0.5 / lengthSqr;\n          accArray[2 * i] += direX * paramOverlap / massi;\n          accArray[2 * i + 1] += direY * paramOverlap / massi;\n          accArray[2 * j] -= direX * paramOverlap / massj;\n          accArray[2 * j + 1] -= direY * paramOverlap / massj;\n        }\n      });\n    });\n  };\n\n  GForceLayout.prototype.calAttractive = function (accArray, edges) {\n    var self = this;\n    var nodeMap = self.nodeMap,\n        nodeIdxMap = self.nodeIdxMap,\n        linkDistance = self.linkDistance,\n        edgeStrength = self.edgeStrength;\n    var nodeSize = self.nodeSize;\n    var getMass = self.getMass;\n    edges.forEach(function (edge, i) {\n      var source = (0, util_1.getEdgeTerminal)(edge, 'source');\n      var target = (0, util_1.getEdgeTerminal)(edge, 'target');\n      var sourceNode = nodeMap[source];\n      var targetNode = nodeMap[target];\n      var vecX = targetNode.x - sourceNode.x;\n      var vecY = targetNode.y - sourceNode.y;\n\n      if (vecX === 0 && vecY === 0) {\n        vecX = Math.random() * 0.01;\n        vecY = Math.random() * 0.01;\n      }\n\n      var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n      var direX = vecX / vecLength;\n      var direY = vecY / vecLength;\n      var length = linkDistance(edge, sourceNode, targetNode) || 1 + (nodeSize(sourceNode) + nodeSize(sourceNode) || 0) / 2;\n      var diff = length - vecLength;\n      var param = diff * edgeStrength(edge);\n      var sourceIdx = nodeIdxMap[source];\n      var targetIdx = nodeIdxMap[target];\n      var massSource = getMass ? getMass(sourceNode) : 1;\n      var massTarget = getMass ? getMass(targetNode) : 1;\n      accArray[2 * sourceIdx] -= direX * param / massSource;\n      accArray[2 * sourceIdx + 1] -= direY * param / massSource;\n      accArray[2 * targetIdx] += direX * param / massTarget;\n      accArray[2 * targetIdx + 1] += direY * param / massTarget;\n    });\n  };\n\n  GForceLayout.prototype.calGravity = function (accArray, nodes) {\n    var self = this; // const nodes = self.nodes;\n\n    var center = self.center;\n    var defaultGravity = self.gravity;\n    var degrees = self.degrees;\n    var nodeLength = nodes.length;\n\n    for (var i = 0; i < nodeLength; i++) {\n      var node = nodes[i];\n      var vecX = node.x - center[0];\n      var vecY = node.y - center[1];\n      var gravity = defaultGravity;\n\n      if (self.getCenter) {\n        var customCenterOpt = self.getCenter(node, degrees[i]);\n\n        if (customCenterOpt && (0, util_1.isNumber)(customCenterOpt[0]) && (0, util_1.isNumber)(customCenterOpt[1]) && (0, util_1.isNumber)(customCenterOpt[2])) {\n          vecX = node.x - customCenterOpt[0];\n          vecY = node.y - customCenterOpt[1];\n          gravity = customCenterOpt[2];\n        }\n      }\n\n      if (!gravity) continue;\n      accArray[2 * i] -= gravity * vecX;\n      accArray[2 * i + 1] -= gravity * vecY;\n    }\n  };\n\n  GForceLayout.prototype.updateVelocity = function (accArray, velArray, stepInterval, nodes) {\n    var self = this;\n    var param = stepInterval * self.damping; // const nodes = self.nodes;\n\n    nodes.forEach(function (node, i) {\n      var vx = accArray[2 * i] * param || 0.01;\n      var vy = accArray[2 * i + 1] * param || 0.01;\n      var vLength = Math.sqrt(vx * vx + vy * vy);\n\n      if (vLength > self.maxSpeed) {\n        var param2 = self.maxSpeed / vLength;\n        vx = param2 * vx;\n        vy = param2 * vy;\n      }\n\n      velArray[2 * i] = vx;\n      velArray[2 * i + 1] = vy;\n    });\n  };\n\n  GForceLayout.prototype.updatePosition = function (velArray, stepInterval, nodes) {\n    nodes.forEach(function (node, i) {\n      if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {\n        node.x = node.fx;\n        node.y = node.fy;\n        return;\n      }\n\n      var distX = velArray[2 * i] * stepInterval;\n      var distY = velArray[2 * i + 1] * stepInterval;\n      node.x += distX;\n      node.y += distY;\n    });\n  };\n\n  GForceLayout.prototype.stop = function () {\n    if (this.timeInterval && typeof window !== \"undefined\") {\n      window.clearInterval(this.timeInterval);\n    }\n  };\n\n  GForceLayout.prototype.destroy = function () {\n    var self = this;\n    self.stop();\n    self.tick = null;\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  };\n\n  GForceLayout.prototype.getType = function () {\n    return \"gForce\";\n  };\n\n  return GForceLayout;\n}(base_1.Base);\n\nexports.GForceLayout = GForceLayout;","map":null,"metadata":{},"sourceType":"script"}