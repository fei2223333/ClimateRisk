{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Curve } from '../curve';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport var CurveTo = /*#__PURE__*/function (_Segment) {\n  _inherits(CurveTo, _Segment);\n\n  function CurveTo(arg0, arg1, arg2, arg3, arg4, arg5) {\n    var _this;\n\n    _classCallCheck(this, CurveTo);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CurveTo).call(this));\n\n    if (Curve.isCurve(arg0)) {\n      _this.controlPoint1 = arg0.controlPoint1.clone().round(2);\n      _this.controlPoint2 = arg0.controlPoint2.clone().round(2);\n      _this.endPoint = arg0.end.clone().round(2);\n    } else if (typeof arg0 === 'number') {\n      _this.controlPoint1 = new Point(arg0, arg1).round(2);\n      _this.controlPoint2 = new Point(arg2, arg3).round(2);\n      _this.endPoint = new Point(arg4, arg5).round(2);\n    } else {\n      _this.controlPoint1 = Point.create(arg0).round(2);\n      _this.controlPoint2 = Point.create(arg1).round(2);\n      _this.endPoint = Point.create(arg2).round(2);\n    }\n\n    return _this;\n  }\n\n  _createClass(CurveTo, [{\n    key: \"bbox\",\n    value: function bbox() {\n      return this.curve.bbox();\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      return this.curve.closestPoint(p);\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      return this.curve.closestPointLength(p);\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      return this.curve.closestPointNormalizedLength(p);\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      return this.curve.closestPointTangent(p);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.curve.length();\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // TODO: fix options\n      var divided = this.curve.divideAt(ratio, options);\n      return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // TODO: fix options\n      var divided = this.curve.divideAtLength(length, options);\n      return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n    }\n  }, {\n    key: \"divideAtT\",\n    value: function divideAtT(t) {\n      var divided = this.curve.divideAtT(t);\n      return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      return [];\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      return this.curve.pointAt(ratio);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      return this.curve.pointAtLength(length);\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      return this.curve.tangentAt(ratio);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      return this.curve.tangentAtLength(length);\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      if (!this.previousSegment) {\n        return false;\n      }\n\n      var start = this.start;\n      var control1 = this.controlPoint1;\n      var control2 = this.controlPoint2;\n      var end = this.end;\n      return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.controlPoint1.scale(sx, sy, origin);\n      this.controlPoint2.scale(sx, sy, origin);\n      this.end.scale(sx, sy, origin);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.controlPoint1.rotate(angle, origin);\n      this.controlPoint2.rotate(angle, origin);\n      this.end.rotate(angle, origin);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n      } else {\n        this.controlPoint1.translate(tx);\n        this.controlPoint2.translate(tx);\n        this.end.translate(tx);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(s) {\n      return this.start.equals(s.start) && this.end.equals(s.end) && this.controlPoint1.equals(s.controlPoint1) && this.controlPoint2.equals(s.controlPoint2);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.type,\n        start: this.start.toJSON(),\n        controlPoint1: this.controlPoint1.toJSON(),\n        controlPoint2: this.controlPoint2.toJSON(),\n        end: this.end.toJSON()\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var c1 = this.controlPoint1;\n      var c2 = this.controlPoint2;\n      var end = this.end;\n      return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'C';\n    }\n  }, {\n    key: \"curve\",\n    get: function get() {\n      return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    }\n  }]);\n\n  return CurveTo;\n}(Segment);\n\n(function (CurveTo) {\n  function create() {\n    var len = arguments.length;\n    var arg0 = arguments.length <= 0 ? undefined : arguments[0]; // curve provided\n\n    if (Curve.isCurve(arg0)) {\n      return new CurveTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 3) {\n        return new CurveTo(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      } // this is a poly-bezier segment\n\n\n      var _segments = [];\n\n      for (var i = 0; i < len; i += 3) {\n        _segments.push(new CurveTo(i < 0 || arguments.length <= i ? undefined : arguments[i], i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1], i + 2 < 0 || arguments.length <= i + 2 ? undefined : arguments[i + 2]));\n      }\n\n      return _segments;\n    } // coordinates provided\n\n\n    if (len === 6) {\n      return new CurveTo(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2], arguments.length <= 3 ? undefined : arguments[3], arguments.length <= 4 ? undefined : arguments[4], arguments.length <= 5 ? undefined : arguments[5]);\n    } // this is a poly-bezier segment\n\n\n    var segments = [];\n\n    for (var _i = 0; _i < len; _i += 6) {\n      segments.push(new CurveTo(_i < 0 || arguments.length <= _i ? undefined : arguments[_i], _i + 1 < 0 || arguments.length <= _i + 1 ? undefined : arguments[_i + 1], _i + 2 < 0 || arguments.length <= _i + 2 ? undefined : arguments[_i + 2], _i + 3 < 0 || arguments.length <= _i + 3 ? undefined : arguments[_i + 3], _i + 4 < 0 || arguments.length <= _i + 4 ? undefined : arguments[_i + 4], _i + 5 < 0 || arguments.length <= _i + 5 ? undefined : arguments[_i + 5]));\n    }\n\n    return segments;\n  }\n\n  CurveTo.create = create;\n})(CurveTo || (CurveTo = {}));","map":null,"metadata":{},"sourceType":"module"}