{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { getEdgeTerminal, isNumber } from \"../util\";\nvar SPEED_DIVISOR = 800;\n/**\n * fruchterman 布局\n */\n\nexport var FruchtermanLayout = /*#__PURE__*/function (_Base) {\n  _inherits(FruchtermanLayout, _Base);\n\n  function FruchtermanLayout(options) {\n    var _this;\n\n    _classCallCheck(this, FruchtermanLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FruchtermanLayout).call(this));\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 1000;\n    /** 是否启动 worker */\n\n    _this.workerEnabled = false;\n    /** 重力大小，影响图的紧凑程度 */\n\n    _this.gravity = 10;\n    /** 速度 */\n\n    _this.speed = 5;\n    /** 是否产生聚类力 */\n\n    _this.clustering = false;\n    /** 聚类力大小 */\n\n    _this.clusterGravity = 10;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.nodeMap = {};\n    _this.nodeIdxMap = {};\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n    /** 每次迭代结束的回调函数 */\n\n\n    _this.tick = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(FruchtermanLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        maxIteration: 1000,\n        gravity: 10,\n        speed: 1,\n        clustering: false,\n        clusterGravity: 10\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var _a, _b;\n\n      var self = this;\n      var nodes = self.nodes;\n\n      if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n        window.clearInterval(self.timeInterval);\n      }\n\n      if (!nodes || nodes.length === 0) {\n        (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      var center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n        return;\n      }\n\n      var nodeMap = {};\n      var nodeIdxMap = {};\n      nodes.forEach(function (node, i) {\n        if (!isNumber(node.x)) node.x = Math.random() * _this2.width;\n        if (!isNumber(node.y)) node.y = Math.random() * _this2.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap; // layout\n\n      return self.run();\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _a;\n\n      var self = this;\n      var nodes = self.nodes;\n      if (!nodes) return;\n      var edges = self.edges,\n          maxIteration = self.maxIteration,\n          workerEnabled = self.workerEnabled,\n          clustering = self.clustering;\n      var clusterMap = {};\n\n      if (clustering) {\n        nodes.forEach(function (n) {\n          if (clusterMap[n.cluster] === undefined) {\n            clusterMap[n.cluster] = {\n              name: n.cluster,\n              cx: 0,\n              cy: 0,\n              count: 0\n            };\n          }\n        });\n      }\n\n      if (workerEnabled) {\n        for (var i = 0; i < maxIteration; i++) {\n          self.runOneStep(clusterMap);\n        }\n\n        (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n      } else {\n        if (typeof window === \"undefined\") return;\n        var iter = 0; // interval for render the result after each iteration\n\n        this.timeInterval = window.setInterval(function () {\n          var _a;\n\n          self.runOneStep(clusterMap);\n          iter++;\n\n          if (iter >= maxIteration) {\n            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n            window.clearInterval(self.timeInterval);\n          }\n        }, 0);\n      }\n\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n  }, {\n    key: \"runOneStep\",\n    value: function runOneStep(clusterMap) {\n      var _a;\n\n      var self = this;\n      var nodes = self.nodes;\n      if (!nodes) return;\n      var edges = self.edges,\n          center = self.center,\n          gravity = self.gravity,\n          speed = self.speed,\n          clustering = self.clustering;\n      var area = self.height * self.width;\n      var maxDisplace = Math.sqrt(area) / 10;\n      var k2 = area / (nodes.length + 1);\n      var k = Math.sqrt(k2);\n      var displacements = [];\n      nodes.forEach(function (_, j) {\n        displacements[j] = {\n          x: 0,\n          y: 0\n        };\n      });\n      self.applyCalculate(nodes, edges, displacements, k, k2); // gravity for clusters\n\n      if (clustering) {\n        // re-compute the clustering centers\n        for (var key in clusterMap) {\n          clusterMap[key].cx = 0;\n          clusterMap[key].cy = 0;\n          clusterMap[key].count = 0;\n        }\n\n        nodes.forEach(function (n) {\n          var c = clusterMap[n.cluster];\n\n          if (isNumber(n.x)) {\n            c.cx += n.x;\n          }\n\n          if (isNumber(n.y)) {\n            c.cy += n.y;\n          }\n\n          c.count++;\n        });\n\n        for (var _key in clusterMap) {\n          clusterMap[_key].cx /= clusterMap[_key].count;\n          clusterMap[_key].cy /= clusterMap[_key].count;\n        } // compute the cluster gravity forces\n\n\n        var clusterGravity = self.clusterGravity || gravity;\n        nodes.forEach(function (n, j) {\n          if (!isNumber(n.x) || !isNumber(n.y)) return;\n          var c = clusterMap[n.cluster];\n          var distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));\n          var gravityForce = k * clusterGravity;\n          displacements[j].x -= gravityForce * (n.x - c.cx) / distLength;\n          displacements[j].y -= gravityForce * (n.y - c.cy) / distLength;\n        });\n      } // gravity\n\n\n      nodes.forEach(function (n, j) {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        var gravityForce = 0.01 * k * gravity;\n        displacements[j].x -= gravityForce * (n.x - center[0]);\n        displacements[j].y -= gravityForce * (n.y - center[1]);\n      }); // move\n\n      nodes.forEach(function (n, j) {\n        if (isNumber(n.fx) && isNumber(n.fy)) {\n          n.x = n.fx;\n          n.y = n.fy;\n          return;\n        }\n\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        var distLength = Math.sqrt(displacements[j].x * displacements[j].x + displacements[j].y * displacements[j].y);\n\n        if (distLength > 0) {\n          // && !n.isFixed()\n          var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n          n.x += displacements[j].x / distLength * limitedDist;\n          n.y += displacements[j].y / distLength * limitedDist;\n        }\n      });\n      (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);\n    }\n  }, {\n    key: \"applyCalculate\",\n    value: function applyCalculate(nodes, edges, displacements, k, k2) {\n      var self = this;\n      self.calRepulsive(nodes, displacements, k2);\n      if (edges) self.calAttractive(edges, displacements, k);\n    }\n  }, {\n    key: \"calRepulsive\",\n    value: function calRepulsive(nodes, displacements, k2) {\n      nodes.forEach(function (v, i) {\n        displacements[i] = {\n          x: 0,\n          y: 0\n        };\n        nodes.forEach(function (u, j) {\n          if (i === j) {\n            return;\n          }\n\n          if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n            return;\n          }\n\n          var vecX = v.x - u.x;\n          var vecY = v.y - u.y;\n          var vecLengthSqr = vecX * vecX + vecY * vecY;\n\n          if (vecLengthSqr === 0) {\n            vecLengthSqr = 1;\n            var sign = i > j ? 1 : -1;\n            vecX = 0.01 * sign;\n            vecY = 0.01 * sign;\n          }\n\n          var common = k2 / vecLengthSqr;\n          displacements[i].x += vecX * common;\n          displacements[i].y += vecY * common;\n        });\n      });\n    }\n  }, {\n    key: \"calAttractive\",\n    value: function calAttractive(edges, displacements, k) {\n      var _this3 = this;\n\n      edges.forEach(function (e) {\n        var source = getEdgeTerminal(e, 'source');\n        var target = getEdgeTerminal(e, 'target');\n        if (!source || !target) return;\n        var uIndex = _this3.nodeIdxMap[source];\n        var vIndex = _this3.nodeIdxMap[target];\n\n        if (uIndex === vIndex) {\n          return;\n        }\n\n        var u = _this3.nodeMap[source];\n        var v = _this3.nodeMap[target];\n\n        if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n          return;\n        }\n\n        var vecX = v.x - u.x;\n        var vecY = v.y - u.y;\n        var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n        var common = vecLength * vecLength / k;\n        displacements[vIndex].x -= vecX / vecLength * common;\n        displacements[vIndex].y -= vecY / vecLength * common;\n        displacements[uIndex].x += vecX / vecLength * common;\n        displacements[uIndex].y += vecY / vecLength * common;\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.timeInterval && typeof window !== \"undefined\") {\n        window.clearInterval(this.timeInterval);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var self = this;\n      self.stop();\n      self.tick = null;\n      self.nodes = null;\n      self.edges = null;\n      self.destroyed = true;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"fruchterman\";\n    }\n  }]);\n\n  return FruchtermanLayout;\n}(Base);","map":null,"metadata":{},"sourceType":"module"}