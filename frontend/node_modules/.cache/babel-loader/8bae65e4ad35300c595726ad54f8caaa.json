{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar grid_1 = __importDefault(require(\"./grid\"));\n\nfunction layout(data, options) {\n  if (!data.nodes || data.nodes.length === 0) return data;\n  var width = options.width;\n  var height = options.height;\n  var nodeMinGap = options.nodeMinGap; // 2. 网格布局\n\n  var CELL_W = 10000;\n  var CELL_H = 10000;\n  data.nodes.forEach(function (node) {\n    var nodeWidth = node.size[0] || 50;\n    var nodeHeight = node.size[1] || 50;\n    CELL_W = Math.min(nodeWidth, CELL_W);\n    CELL_H = Math.min(nodeHeight, CELL_H);\n  });\n  var grid = new grid_1.default();\n  grid.init(width, height, {\n    CELL_H: CELL_H,\n    CELL_W: CELL_W\n  });\n  data.nodes.forEach(function (d) {\n    var gridpoint = grid.occupyNearest(d);\n\n    if (gridpoint) {\n      gridpoint.node = {\n        id: d.id,\n        size: d.size\n      };\n      d.x = gridpoint.x;\n      d.y = gridpoint.y;\n      d.dx = gridpoint.dx;\n      d.dy = gridpoint.dy;\n    }\n  }); // 加入节点size\n\n  for (var i = 0; i < data.nodes.length; i++) {\n    //  节点宽度大于网格宽度，则往当前网格的右边插入列\n    var node = data.nodes[i];\n    var result = grid.findGridByNodeId(node.id);\n    if (!result) throw new Error(\"can not find node cell\");\n    var column = result.column,\n        row = result.row;\n\n    if (node.size[0] + nodeMinGap > CELL_W) {\n      var addGridSize = Math.ceil((node.size[0] + nodeMinGap) / CELL_W) - 1;\n      var realAdd = addGridSize; // 优化，假设同一列，不同行存在两个size为2的节点，遍历到第一个节点的时候，会往右插入两列，遍历到第二个节点，又往右插入。就会导致多余的网格\n\n      for (var j = 0; j < addGridSize; j++) {\n        var hasColumn = grid.additionColumn.indexOf(column + j + 1) > -1;\n\n        if (hasColumn && !grid.cells[column + j + 1][row].node) {\n          realAdd--;\n        } else {\n          break;\n        }\n      }\n\n      grid.insertColumn(column, realAdd);\n    } // 节点高度大于网格宽度，则往当前网格的下边插入行\n\n\n    if (node.size[1] + nodeMinGap > CELL_H) {\n      var addGridSize = Math.ceil((node.size[1] + nodeMinGap) / CELL_H) - 1;\n      var realAdd = addGridSize;\n\n      for (var j = 0; j < addGridSize; j++) {\n        var hasColumn = grid.additionRow.indexOf(row + j + 1) > -1;\n\n        if (hasColumn && !grid.cells[column][row + j + 1].node) {\n          realAdd--;\n        } else {\n          break;\n        }\n      }\n\n      grid.insertRow(row, realAdd);\n    }\n  } // 同步节点坐标\n\n\n  for (var i = 0; i < grid.columnNum; i++) {\n    var _loop_1 = function _loop_1(j) {\n      var cell = grid.cells[i][j];\n\n      if (cell.node) {\n        var node = data.nodes.find(function (node) {\n          var _a;\n\n          return node.id === ((_a = cell === null || cell === void 0 ? void 0 : cell.node) === null || _a === void 0 ? void 0 : _a.id);\n        });\n\n        if (node) {\n          node.x = cell.x + node.size[0] / 2;\n          node.y = cell.y + node.size[1] / 2;\n        }\n      }\n    };\n\n    for (var j = 0; j < grid.rowNum; j++) {\n      _loop_1(j);\n    }\n  }\n}\n\nexports.default = layout;","map":null,"metadata":{},"sourceType":"script"}