{"ast":null,"code":"import { Point } from '../../geometry';\nimport { attr } from './attr';\nimport { getBBox, getTransformToElement } from './geom';\nimport { createSVGTransform, parseTransformString, transformStringToMatrix, matrixToTransformString } from './matrix';\nexport function transform(elem, matrix) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (matrix == null) {\n    return transformStringToMatrix(attr(elem, 'transform'));\n  }\n\n  if (options.absolute) {\n    elem.setAttribute('transform', matrixToTransformString(matrix));\n    return;\n  }\n\n  var transformList = elem.transform;\n  var svgTransform = createSVGTransform(matrix);\n  transformList.baseVal.appendItem(svgTransform);\n}\nexport function translate(elem, tx) {\n  var ty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var transformAttr = attr(elem, 'transform');\n  var transform = parseTransformString(transformAttr);\n\n  if (tx == null) {\n    return transform.translation;\n  }\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n  var newTx = options.absolute ? tx : transform.translation.tx + tx;\n  var newTy = options.absolute ? ty : transform.translation.ty + ty;\n  var newTranslate = \"translate(\".concat(newTx, \",\").concat(newTy, \")\"); // Note that `translate()` is always the first transformation. This is\n  // usually the desired case.\n\n  elem.setAttribute('transform', \"\".concat(newTranslate, \" \").concat(transformAttr).trim());\n}\nexport function rotate(elem, angle, cx, cy) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var transformAttr = attr(elem, 'transform');\n  var transform = parseTransformString(transformAttr);\n\n  if (angle == null) {\n    return transform.rotation;\n  }\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n  angle %= 360; // eslint-disable-line\n\n  var newAngle = options.absolute ? angle : transform.rotation.angle + angle;\n  var newOrigin = cx != null && cy != null ? \",\".concat(cx, \",\").concat(cy) : '';\n  var newRotate = \"rotate(\".concat(newAngle).concat(newOrigin, \")\");\n  elem.setAttribute('transform', \"\".concat(transformAttr, \" \").concat(newRotate).trim());\n}\nexport function scale(elem, sx, sy) {\n  var transformAttr = attr(elem, 'transform');\n  var transform = parseTransformString(transformAttr);\n\n  if (sx == null) {\n    return transform.scale;\n  }\n\n  sy = sy == null ? sx : sy; // eslint-disable-line\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n  var newScale = \"scale(\".concat(sx, \",\").concat(sy, \")\");\n  elem.setAttribute('transform', \"\".concat(transformAttr, \" \").concat(newScale).trim());\n}\nexport function translateAndAutoOrient(elem, position, reference, target) {\n  var pos = Point.create(position);\n  var ref = Point.create(reference);\n\n  if (!target) {\n    var svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n    target = svg; // eslint-disable-line\n  } // Clean-up previously set transformations except the scale.\n  // If we didn't clean up the previous transformations then they'd\n  // add up with the old ones. Scale is an exception as it doesn't\n  // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n  // is that the element is scaled by the factor 2, not 8.\n\n\n  var s = scale(elem);\n  elem.setAttribute('transform', '');\n  var bbox = getBBox(elem, {\n    target: target\n  }).scale(s.sx, s.sy); // 1. Translate to origin.\n\n  var translateToOrigin = createSVGTransform();\n  translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2); // 2. Rotate around origin.\n\n  var rotateAroundOrigin = createSVGTransform();\n  var angle = pos.angleBetween(ref, pos.clone().translate(1, 0));\n  if (angle) rotateAroundOrigin.setRotate(angle, 0, 0); // 3. Translate to the `position` + the offset (half my width)\n  //    towards the `reference` point.\n\n  var translateFromOrigin = createSVGTransform();\n  var finalPosition = pos.clone().move(ref, bbox.width / 2);\n  translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y); // 4. Get the current transformation matrix of this node\n\n  var ctm = getTransformToElement(elem, target); // 5. Apply transformations and the scale\n\n  var transform = createSVGTransform();\n  transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));\n  elem.setAttribute('transform', matrixToTransformString(transform.matrix));\n}","map":null,"metadata":{},"sourceType":"module"}