{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Dom, NumberExt } from '../util';\nimport { Point, Rectangle } from '../geometry';\nimport { Base } from './base';\nexport var TransformManager = /*#__PURE__*/function (_Base) {\n  _inherits(TransformManager, _Base);\n\n  function TransformManager() {\n    var _this;\n\n    _classCallCheck(this, TransformManager);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TransformManager).apply(this, arguments));\n    _this.widgets = new Map();\n    return _this;\n  }\n\n  _createClass(TransformManager, [{\n    key: \"init\",\n    value: function init() {\n      this.startListening();\n      this.resize();\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      this.graph.on('node:mouseup', this.onNodeMouseUp, this);\n      this.graph.on('node:selected', this.onNodeSelected, this);\n      this.graph.on('node:unselected', this.onNodeUnSelected, this);\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      this.graph.off('node:mouseup', this.onNodeMouseUp, this);\n      this.graph.off('node:selected', this.onNodeSelected, this);\n      this.graph.off('node:unselected', this.onNodeUnSelected, this);\n    }\n  }, {\n    key: \"onNodeMouseUp\",\n    value: function onNodeMouseUp(_ref) {\n      var node = _ref.node;\n\n      if (!this.isSelectionEnabled) {\n        var widget = this.graph.hook.createTransform(node, {\n          clearAll: true\n        });\n\n        if (widget) {\n          this.widgets.set(node, widget);\n        }\n      }\n    }\n  }, {\n    key: \"onNodeSelected\",\n    value: function onNodeSelected(_ref2) {\n      var node = _ref2.node;\n\n      if (this.isSelectionEnabled) {\n        var widget = this.graph.hook.createTransform(node, {\n          clearAll: false\n        });\n\n        if (widget) {\n          this.widgets.set(node, widget);\n        }\n      }\n    }\n  }, {\n    key: \"onNodeUnSelected\",\n    value: function onNodeUnSelected(_ref3) {\n      var node = _ref3.node;\n\n      if (this.isSelectionEnabled) {\n        var widget = this.widgets.get(node);\n\n        if (widget) {\n          widget.dispose();\n        }\n\n        this.widgets.delete(node);\n      }\n    }\n    /**\n     * Returns the current transformation matrix of the graph.\n     */\n\n  }, {\n    key: \"getMatrix\",\n    value: function getMatrix() {\n      var transform = this.viewport.getAttribute('transform');\n\n      if (transform !== this.viewportTransformString) {\n        // `getCTM`: top-left relative to the SVG element\n        // `getScreenCTM`: top-left relative to the document\n        this.viewportMatrix = this.viewport.getCTM();\n        this.viewportTransformString = transform;\n      } // Clone the cached current transformation matrix.\n      // If no matrix previously stored the identity matrix is returned.\n\n\n      return Dom.createSVGMatrix(this.viewportMatrix);\n    }\n    /**\n     * Sets new transformation with the given `matrix`\n     */\n\n  }, {\n    key: \"setMatrix\",\n    value: function setMatrix(matrix) {\n      var ctm = Dom.createSVGMatrix(matrix);\n      var transform = Dom.matrixToTransformString(ctm);\n      this.viewport.setAttribute('transform', transform);\n      this.viewportMatrix = ctm;\n      this.viewportTransformString = transform;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      var w = width === undefined ? this.options.width : width;\n      var h = height === undefined ? this.options.height : height;\n      this.options.width = w;\n      this.options.height = h;\n\n      if (typeof w === 'number') {\n        w = Math.round(w);\n      }\n\n      if (typeof h === 'number') {\n        h = Math.round(h);\n      }\n\n      this.container.style.width = w == null ? '' : \"\".concat(w, \"px\");\n      this.container.style.height = h == null ? '' : \"\".concat(h, \"px\");\n      var size = this.getComputedSize();\n      this.graph.trigger('resize', Object.assign({}, size));\n      return this;\n    }\n  }, {\n    key: \"getComputedSize\",\n    value: function getComputedSize() {\n      var w = this.options.width;\n      var h = this.options.height;\n\n      if (!NumberExt.isNumber(w)) {\n        w = this.container.clientWidth;\n      }\n\n      if (!NumberExt.isNumber(h)) {\n        h = this.container.clientHeight;\n      }\n\n      return {\n        width: w,\n        height: h\n      };\n    }\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      return Dom.matrixToScale(this.getMatrix());\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx) {\n      var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sx;\n      var ox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var oy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      sx = this.clampScale(sx); // eslint-disable-line\n\n      sy = this.clampScale(sy); // eslint-disable-line\n\n      if (ox || oy) {\n        var ts = this.getTranslation();\n        var tx = ts.tx - ox * (sx - 1);\n        var ty = ts.ty - oy * (sy - 1);\n\n        if (tx !== ts.tx || ty !== ts.ty) {\n          this.translate(tx, ty);\n        }\n      }\n\n      var matrix = this.getMatrix();\n      matrix.a = sx;\n      matrix.d = sy;\n      this.setMatrix(matrix);\n      this.graph.trigger('scale', {\n        sx: sx,\n        sy: sy,\n        ox: ox,\n        oy: oy\n      });\n      return this;\n    }\n  }, {\n    key: \"clampScale\",\n    value: function clampScale(scale) {\n      var range = this.graph.options.scaling;\n      return NumberExt.clamp(scale, range.min || 0.01, range.max || 16);\n    }\n  }, {\n    key: \"getZoom\",\n    value: function getZoom() {\n      return this.getScale().sx;\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom(factor, options) {\n      options = options || {}; // eslint-disable-line\n\n      var sx = factor;\n      var sy = factor;\n      var scale = this.getScale();\n      var clientSize = this.getComputedSize();\n      var cx = clientSize.width / 2;\n      var cy = clientSize.height / 2;\n\n      if (!options.absolute) {\n        sx += scale.sx;\n        sy += scale.sy;\n      }\n\n      if (options.scaleGrid) {\n        sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n        sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n      }\n\n      if (options.maxScale) {\n        sx = Math.min(options.maxScale, sx);\n        sy = Math.min(options.maxScale, sy);\n      }\n\n      if (options.minScale) {\n        sx = Math.max(options.minScale, sx);\n        sy = Math.max(options.minScale, sy);\n      }\n\n      if (options.center) {\n        cx = options.center.x;\n        cy = options.center.y;\n      }\n\n      sx = this.clampScale(sx);\n      sy = this.clampScale(sy);\n\n      if (cx || cy) {\n        var ts = this.getTranslation();\n        var tx = cx - (cx - ts.tx) * (sx / scale.sx);\n        var ty = cy - (cy - ts.ty) * (sy / scale.sy);\n\n        if (tx !== ts.tx || ty !== ts.ty) {\n          this.translate(tx, ty);\n        }\n      }\n\n      this.scale(sx, sy);\n      return this;\n    }\n  }, {\n    key: \"getRotation\",\n    value: function getRotation() {\n      return Dom.matrixToRotation(this.getMatrix());\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, cx, cy) {\n      if (cx == null || cy == null) {\n        var bbox = Dom.getBBox(this.graph.view.stage);\n        cx = bbox.width / 2; // eslint-disable-line\n\n        cy = bbox.height / 2; // eslint-disable-line\n      }\n\n      var ctm = this.getMatrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);\n      this.setMatrix(ctm);\n      return this;\n    }\n  }, {\n    key: \"getTranslation\",\n    value: function getTranslation() {\n      return Dom.matrixToTranslation(this.getMatrix());\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      var matrix = this.getMatrix();\n      matrix.e = tx || 0;\n      matrix.f = ty || 0;\n      this.setMatrix(matrix);\n      var ts = this.getTranslation();\n      this.options.x = ts.tx;\n      this.options.y = ts.ty;\n      this.graph.trigger('translate', Object.assign({}, ts));\n      return this;\n    }\n  }, {\n    key: \"setOrigin\",\n    value: function setOrigin(ox, oy) {\n      return this.translate(ox || 0, oy || 0);\n    }\n  }, {\n    key: \"fitToContent\",\n    value: function fitToContent(gridWidth, gridHeight, padding, options) {\n      if (typeof gridWidth === 'object') {\n        var opts = gridWidth;\n        gridWidth = opts.gridWidth || 1; // eslint-disable-line\n\n        gridHeight = opts.gridHeight || 1; // eslint-disable-line\n\n        padding = opts.padding || 0; // eslint-disable-line\n\n        options = opts; // eslint-disable-line\n      } else {\n        gridWidth = gridWidth || 1; // eslint-disable-line\n\n        gridHeight = gridHeight || 1; // eslint-disable-line\n\n        padding = padding || 0; // eslint-disable-line\n\n        if (options == null) {\n          options = {}; // eslint-disable-line\n        }\n      }\n\n      var paddings = NumberExt.normalizeSides(padding);\n      var border = options.border || 0;\n      var contentArea = options.contentArea ? Rectangle.create(options.contentArea) : this.getContentArea(options);\n\n      if (border > 0) {\n        contentArea.inflate(border);\n      }\n\n      var scale = this.getScale();\n      var translate = this.getTranslation();\n      var sx = scale.sx;\n      var sy = scale.sy;\n      contentArea.x *= sx;\n      contentArea.y *= sy;\n      contentArea.width *= sx;\n      contentArea.height *= sy;\n      var width = Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) * gridWidth;\n      var height = Math.max(Math.ceil((contentArea.height + contentArea.y) / gridHeight), 1) * gridHeight;\n      var tx = 0;\n      var ty = 0;\n\n      if (options.allowNewOrigin === 'negative' && contentArea.x < 0 || options.allowNewOrigin === 'positive' && contentArea.x >= 0 || options.allowNewOrigin === 'any') {\n        tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth;\n        tx += paddings.left;\n        width += tx;\n      }\n\n      if (options.allowNewOrigin === 'negative' && contentArea.y < 0 || options.allowNewOrigin === 'positive' && contentArea.y >= 0 || options.allowNewOrigin === 'any') {\n        ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight;\n        ty += paddings.top;\n        height += ty;\n      }\n\n      width += paddings.right;\n      height += paddings.bottom; // Make sure the resulting width and height are greater than minimum.\n\n      width = Math.max(width, options.minWidth || 0);\n      height = Math.max(height, options.minHeight || 0); // Make sure the resulting width and height are lesser than maximum.\n\n      width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER);\n      height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER);\n      var size = this.getComputedSize();\n      var sizeChanged = width !== size.width || height !== size.height;\n      var originChanged = tx !== translate.tx || ty !== translate.ty; // Change the dimensions only if there is a size discrepency or an origin change\n\n      if (originChanged) {\n        this.translate(tx, ty);\n      }\n\n      if (sizeChanged) {\n        this.resize(width, height);\n      }\n\n      return new Rectangle(-tx / sx, -ty / sy, width / sx, height / sy);\n    }\n  }, {\n    key: \"scaleContentToFit\",\n    value: function scaleContentToFit() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.scaleContentToFitImpl(options);\n    }\n  }, {\n    key: \"scaleContentToFitImpl\",\n    value: function scaleContentToFitImpl() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var contentBBox;\n      var contentLocalOrigin;\n\n      if (options.contentArea) {\n        var contentArea = options.contentArea;\n        contentBBox = this.graph.localToGraph(contentArea);\n        contentLocalOrigin = Point.create(contentArea);\n      } else {\n        contentBBox = this.getContentBBox(options);\n        contentLocalOrigin = this.graph.graphToLocal(contentBBox);\n      }\n\n      if (!contentBBox.width || !contentBBox.height) {\n        return;\n      }\n\n      var padding = NumberExt.normalizeSides(options.padding);\n      var minScale = options.minScale || 0;\n      var maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;\n      var minScaleX = options.minScaleX || minScale;\n      var maxScaleX = options.maxScaleX || maxScale;\n      var minScaleY = options.minScaleY || minScale;\n      var maxScaleY = options.maxScaleY || maxScale;\n      var fittingBox;\n\n      if (options.viewportArea) {\n        fittingBox = options.viewportArea;\n      } else {\n        var computedSize = this.getComputedSize();\n        var currentTranslate = this.getTranslation();\n        fittingBox = {\n          x: currentTranslate.tx,\n          y: currentTranslate.ty,\n          width: computedSize.width,\n          height: computedSize.height\n        };\n      }\n\n      fittingBox = Rectangle.create(fittingBox).moveAndExpand({\n        x: padding.left,\n        y: padding.top,\n        width: -padding.left - padding.right,\n        height: -padding.top - padding.bottom\n      });\n      var currentScale = this.getScale();\n      var newSX = fittingBox.width / contentBBox.width * currentScale.sx;\n      var newSY = fittingBox.height / contentBBox.height * currentScale.sy;\n\n      if (options.preserveAspectRatio !== false) {\n        newSX = newSY = Math.min(newSX, newSY);\n      } // snap scale to a grid\n\n\n      var gridSize = options.scaleGrid;\n\n      if (gridSize) {\n        newSX = gridSize * Math.floor(newSX / gridSize);\n        newSY = gridSize * Math.floor(newSY / gridSize);\n      } // scale min/max boundaries\n\n\n      newSX = NumberExt.clamp(newSX, minScaleX, maxScaleX);\n      newSY = NumberExt.clamp(newSY, minScaleY, maxScaleY);\n      this.scale(newSX, newSY);\n\n      if (translate) {\n        var origin = this.options;\n        var newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x;\n        var newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y;\n        this.translate(newOX, newOY);\n      }\n    }\n  }, {\n    key: \"getContentArea\",\n    value: function getContentArea() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.useCellGeometry) {\n        return this.model.getAllCellsBBox() || new Rectangle();\n      }\n\n      return Dom.getBBox(this.graph.view.stage);\n    }\n  }, {\n    key: \"getContentBBox\",\n    value: function getContentBBox() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.graph.localToGraph(this.getContentArea(options));\n    }\n  }, {\n    key: \"getGraphArea\",\n    value: function getGraphArea() {\n      var rect = Rectangle.fromSize(this.getComputedSize());\n      return this.graph.graphToLocal(rect);\n    }\n  }, {\n    key: \"zoomToRect\",\n    value: function zoomToRect(rect) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var area = Rectangle.create(rect);\n      var graph = this.graph;\n      options.contentArea = area;\n\n      if (options.viewportArea == null) {\n        options.viewportArea = {\n          x: graph.options.x,\n          y: graph.options.y,\n          width: this.options.width,\n          height: this.options.height\n        };\n      }\n\n      this.scaleContentToFitImpl(options, false);\n      var center = area.getCenter();\n      this.centerPoint(center.x, center.y);\n      return this;\n    }\n  }, {\n    key: \"zoomToFit\",\n    value: function zoomToFit() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.zoomToRect(this.getContentArea(options), options);\n    }\n  }, {\n    key: \"centerPoint\",\n    value: function centerPoint(x, y) {\n      var clientSize = this.getComputedSize();\n      var scale = this.getScale();\n      var ts = this.getTranslation();\n      var cx = clientSize.width / 2;\n      var cy = clientSize.height / 2;\n      x = typeof x === 'number' ? x : cx; // eslint-disable-line\n\n      y = typeof y === 'number' ? y : cy; // eslint-disable-line\n\n      x = cx - x * scale.sx; // eslint-disable-line\n\n      y = cy - y * scale.sy; // eslint-disable-line\n\n      if (ts.tx !== x || ts.ty !== y) {\n        this.translate(x, y);\n      }\n    }\n  }, {\n    key: \"centerContent\",\n    value: function centerContent(options) {\n      var rect = this.graph.getContentArea(options);\n      var center = rect.getCenter();\n      this.centerPoint(center.x, center.y);\n    }\n  }, {\n    key: \"centerCell\",\n    value: function centerCell(cell) {\n      return this.positionCell(cell, 'center');\n    }\n  }, {\n    key: \"positionPoint\",\n    value: function positionPoint(point, x, y) {\n      var clientSize = this.getComputedSize(); // eslint-disable-next-line\n\n      x = NumberExt.normalizePercentage(x, Math.max(0, clientSize.width));\n\n      if (x < 0) {\n        x = clientSize.width + x; // eslint-disable-line\n      } // eslint-disable-next-line\n\n\n      y = NumberExt.normalizePercentage(y, Math.max(0, clientSize.height));\n\n      if (y < 0) {\n        y = clientSize.height + y; // eslint-disable-line\n      }\n\n      var ts = this.getTranslation();\n      var scale = this.getScale();\n      var dx = x - point.x * scale.sx;\n      var dy = y - point.y * scale.sy;\n\n      if (ts.tx !== dx || ts.ty !== dy) {\n        this.translate(dx, dy);\n      }\n    }\n  }, {\n    key: \"positionRect\",\n    value: function positionRect(rect, pos) {\n      var bbox = Rectangle.create(rect);\n\n      switch (pos) {\n        case 'center':\n          return this.positionPoint(bbox.getCenter(), '50%', '50%');\n\n        case 'top':\n          return this.positionPoint(bbox.getTopCenter(), '50%', 0);\n\n        case 'top-right':\n          return this.positionPoint(bbox.getTopRight(), '100%', 0);\n\n        case 'right':\n          return this.positionPoint(bbox.getRightMiddle(), '100%', '50%');\n\n        case 'bottom-right':\n          return this.positionPoint(bbox.getBottomRight(), '100%', '100%');\n\n        case 'bottom':\n          return this.positionPoint(bbox.getBottomCenter(), '50%', '100%');\n\n        case 'bottom-left':\n          return this.positionPoint(bbox.getBottomLeft(), 0, '100%');\n\n        case 'left':\n          return this.positionPoint(bbox.getLeftMiddle(), 0, '50%');\n\n        case 'top-left':\n          return this.positionPoint(bbox.getTopLeft(), 0, 0);\n\n        default:\n          return this;\n      }\n    }\n  }, {\n    key: \"positionCell\",\n    value: function positionCell(cell, pos) {\n      var bbox = cell.getBBox();\n      return this.positionRect(bbox, pos);\n    }\n  }, {\n    key: \"positionContent\",\n    value: function positionContent(pos, options) {\n      var rect = this.graph.getContentArea(options);\n      return this.positionRect(rect, pos);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.widgets.forEach(function (widget) {\n        return widget.dispose();\n      });\n      this.widgets.clear();\n      this.stopListening();\n    }\n  }, {\n    key: \"container\",\n    get: function get() {\n      return this.graph.view.container;\n    }\n  }, {\n    key: \"viewport\",\n    get: function get() {\n      return this.graph.view.viewport;\n    }\n  }, {\n    key: \"isSelectionEnabled\",\n    get: function get() {\n      return this.options.selecting.enabled === true;\n    }\n  }]);\n\n  return TransformManager;\n}(Base);\n\n__decorate([TransformManager.dispose()], TransformManager.prototype, \"dispose\", null);","map":null,"metadata":{},"sourceType":"module"}