{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport var LineTo = /*#__PURE__*/function (_Segment) {\n  _inherits(LineTo, _Segment);\n\n  function LineTo(x, y) {\n    var _this;\n\n    _classCallCheck(this, LineTo);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineTo).call(this));\n\n    if (Line.isLine(x)) {\n      _this.endPoint = x.end.clone().round(2);\n    } else {\n      _this.endPoint = Point.create(x, y).round(2);\n    }\n\n    return _this;\n  }\n\n  _createClass(LineTo, [{\n    key: \"bbox\",\n    value: function bbox() {\n      return this.line.bbox();\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      return this.line.closestPoint(p);\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      return this.line.closestPointLength(p);\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      return this.line.closestPointNormalizedLength(p);\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      return this.line.closestPointTangent(p);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.line.length();\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var divided = this.line.divideAt(ratio);\n      return [new LineTo(divided[0]), new LineTo(divided[1])];\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var divided = this.line.divideAtLength(length);\n      return [new LineTo(divided[0]), new LineTo(divided[1])];\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      return [];\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      return this.line.pointAt(ratio);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      return this.line.pointAtLength(length);\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      return this.line.tangentAt(ratio);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      return this.line.tangentAtLength(length);\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      if (this.previousSegment == null) {\n        return false;\n      }\n\n      return !this.start.equals(this.end);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new LineTo(this.end);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.end.scale(sx, sy, origin);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.end.rotate(angle, origin);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.end.translate(tx, ty);\n      } else {\n        this.end.translate(tx);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(s) {\n      return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.type,\n        start: this.start.toJSON(),\n        end: this.end.toJSON()\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var end = this.end;\n      return \"\".concat(this.type, \" \").concat(end.x, \" \").concat(end.y);\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'L';\n    }\n  }, {\n    key: \"line\",\n    get: function get() {\n      return new Line(this.start, this.end);\n    }\n  }]);\n\n  return LineTo;\n}(Segment);\n\n(function (LineTo) {\n  function create() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var len = args.length;\n    var arg0 = args[0]; // line provided\n\n    if (Line.isLine(arg0)) {\n      return new LineTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new LineTo(arg0);\n      } // poly-line segment\n\n\n      return args.map(function (arg) {\n        return new LineTo(arg);\n      });\n    } // coordinates provided\n\n\n    if (len === 2) {\n      return new LineTo(+args[0], +args[1]);\n    } // poly-line segment\n\n\n    var segments = [];\n\n    for (var i = 0; i < len; i += 2) {\n      var x = +args[i];\n      var y = +args[i + 1];\n      segments.push(new LineTo(x, y));\n    }\n\n    return segments;\n  }\n\n  LineTo.create = create;\n})(LineTo || (LineTo = {}));","map":null,"metadata":{},"sourceType":"module"}