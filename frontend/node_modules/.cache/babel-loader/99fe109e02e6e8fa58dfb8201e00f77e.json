{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { getJudgeFunction } from '../fn';\nimport { requestAnimationFrame } from './animationFrame';\nexport var TouchHandler = /*#__PURE__*/function () {\n  function TouchHandler(options) {\n    var _this = this;\n\n    _classCallCheck(this, TouchHandler);\n\n    this.didTouchMove = function () {\n      // Fire scroll callback based on computed drag delta.\n      // Also track accummulated delta so we can calculate velocity\n      _this.dragAnimationId = null;\n\n      _this.callback(_this.deltaX, _this.deltaY);\n\n      _this.accumulatedDeltaX += _this.deltaX;\n      _this.accumulatedDeltaY += _this.deltaY;\n      _this.deltaX = 0;\n      _this.deltaY = 0;\n    };\n\n    this.track = function () {\n      // Compute velocity based on a weighted average of drag over\n      // last 100ms and previous velocity. Combining into a moving average\n      // results in a smoother scroll.\n      var now = Date.now();\n      var elapsed = now - _this.lastFrameTimestamp;\n      var oldVelocityX = _this.velocityX;\n      var oldVelocityY = _this.velocityY; // We compute velocity using a weighted average of the current\n      // velocity and the previous velocity. If the previous velocity\n      // is 0, put the full weight on the last 100ms\n\n      var weight = 0.8;\n\n      if (elapsed < TouchHandler.TRACKER_TIMEOUT) {\n        weight *= elapsed / TouchHandler.TRACKER_TIMEOUT;\n      }\n\n      if (oldVelocityX === 0 && oldVelocityY === 0) {\n        weight = 1;\n      } // Formula for computing weighted average of velocity\n\n\n      _this.velocityX = weight * (TouchHandler.TRACKER_TIMEOUT * _this.accumulatedDeltaX / (1 + elapsed));\n\n      if (weight < 1) {\n        _this.velocityX += (1 - weight) * oldVelocityX;\n      }\n\n      _this.velocityY = weight * (TouchHandler.TRACKER_TIMEOUT * _this.accumulatedDeltaY / (1 + elapsed));\n\n      if (weight < 1) {\n        _this.velocityY += (1 - weight) * oldVelocityY;\n      }\n\n      _this.accumulatedDeltaX = 0;\n      _this.accumulatedDeltaY = 0;\n      _this.lastFrameTimestamp = now;\n    };\n\n    this.startAutoScroll = function () {\n      // To kick off deceleration / momentum scrolling, handle any\n      // scrolling from a drag which was waiting for an animation\n      // frame. Then update our velocity.\n      // Finally start the momentum scrolling handler (autoScroll)\n      _this.autoScrollTimestamp = Date.now();\n\n      if (_this.deltaX > 0 || _this.deltaY > 0) {\n        _this.didTouchMove();\n      }\n\n      _this.track();\n\n      _this.autoScroll();\n    };\n\n    this.autoScroll = function () {\n      // Compute a scroll delta with an exponential decay based on\n      // time elapsed since drag was released. This is called\n      // recursively on animation frames until the delta is below\n      // a threshold (5 pixels)\n      var elapsed = Date.now() - _this.autoScrollTimestamp;\n\n      var factor = TouchHandler.DECELERATION_AMPLITUDE * Math.exp(-elapsed / TouchHandler.DECELERATION_FACTOR);\n      var deltaX = factor * _this.velocityX;\n      var deltaY = factor * _this.velocityY;\n\n      if (Math.abs(deltaX) <= 5 || !_this.handleScrollX(deltaX, deltaY)) {\n        deltaX = 0;\n      }\n\n      if (Math.abs(deltaY) <= 5 || !_this.handleScrollY(deltaY, deltaX)) {\n        deltaY = 0;\n      }\n\n      if (deltaX !== 0 || deltaY !== 0) {\n        _this.callback(deltaX, deltaY);\n\n        requestAnimationFrame(_this.autoScroll);\n      }\n    };\n\n    this.trackerId = null;\n    this.dragAnimationId = null;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.lastTouchX = 0;\n    this.lastTouchY = 0;\n    this.velocityX = 0;\n    this.velocityY = 0;\n    this.accumulatedDeltaX = 0;\n    this.accumulatedDeltaY = 0;\n    this.lastFrameTimestamp = Date.now();\n    this.autoScrollTimestamp = Date.now();\n    this.callback = options.onTouchScroll;\n    this.handleScrollX = getJudgeFunction(options.shouldHandleScrollX);\n    this.handleScrollY = getJudgeFunction(options.shouldHandleScrollY);\n    this.stopPropagation = getJudgeFunction(options.stopPropagation);\n  }\n\n  _createClass(TouchHandler, [{\n    key: \"onTouchStart\",\n    value: function onTouchStart(e) {\n      this.lastTouchX = e.touches[0].pageX;\n      this.lastTouchY = e.touches[0].pageY;\n      this.velocityX = 0;\n      this.velocityY = 0;\n      this.accumulatedDeltaX = 0;\n      this.accumulatedDeltaY = 0;\n      this.lastFrameTimestamp = Date.now();\n\n      if (this.trackerId != null) {\n        clearInterval(this.trackerId);\n      }\n\n      this.trackerId = window.setInterval(this.track, TouchHandler.TRACKER_TIMEOUT);\n\n      if (this.stopPropagation()) {\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(e) {\n      this.onTouchCancel(e);\n      requestAnimationFrame(this.startAutoScroll);\n    }\n  }, {\n    key: \"onTouchCancel\",\n    value: function onTouchCancel(e) {\n      if (this.trackerId != null) {\n        clearInterval(this.trackerId);\n        this.trackerId = null;\n      }\n\n      if (this.stopPropagation()) {\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchMove\",\n    value: function onTouchMove(e) {\n      var moveX = e.touches[0].pageX;\n      var moveY = e.touches[0].pageY; // Compute delta scrolled since last drag\n      // Mobile, scrolling is inverted\n\n      this.deltaX = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchX - moveX);\n      this.deltaY = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchY - moveY);\n      var handleScrollX = this.handleScrollX(this.deltaX, this.deltaY);\n      var handleScrollY = this.handleScrollY(this.deltaY, this.deltaX);\n\n      if (!handleScrollX && !handleScrollY) {\n        return;\n      } // If we can handle scroll update last touch for computing delta\n\n\n      if (handleScrollX) {\n        this.lastTouchX = moveX;\n      } else {\n        this.deltaX = 0;\n      }\n\n      if (handleScrollY) {\n        this.lastTouchY = moveY;\n      } else {\n        this.deltaY = 0;\n      }\n\n      e.preventDefault(); // ensure minimum delta magnitude is met to avoid jitter\n\n      var changed = false;\n\n      if (Math.abs(this.deltaX) > 2 || Math.abs(this.deltaY) > 2) {\n        if (this.stopPropagation()) {\n          e.stopPropagation();\n        }\n\n        changed = true;\n      } // Request animation frame to trigger scroll of computed delta\n\n\n      if (changed && this.dragAnimationId == null) {\n        this.dragAnimationId = requestAnimationFrame(this.didTouchMove);\n      }\n    }\n  }]);\n\n  return TouchHandler;\n}();\n\n(function (TouchHandler) {\n  TouchHandler.MOVE_AMPLITUDE = 1.6;\n  TouchHandler.DECELERATION_AMPLITUDE = 1.6;\n  TouchHandler.DECELERATION_FACTOR = 325;\n  TouchHandler.TRACKER_TIMEOUT = 100;\n})(TouchHandler || (TouchHandler = {}));","map":null,"metadata":{},"sourceType":"module"}