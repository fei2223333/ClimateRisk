{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ml_matrix_1 = require(\"ml-matrix\");\n\nvar MDS =\n/** @class */\nfunction () {\n  function MDS(params) {\n    this.distances = params.distances;\n    this.dimension = params.dimension || 2;\n    this.linkDistance = params.linkDistance;\n  }\n\n  MDS.prototype.layout = function () {\n    var self = this;\n    var dimension = self.dimension,\n        distances = self.distances,\n        linkDistance = self.linkDistance;\n\n    try {\n      // square distances\n      var M = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n      var rowMeans = M.mean('row');\n      var colMeans = M.mean('column');\n      var totalMean = M.mean();\n      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n      // points from it\n\n      var ret = new ml_matrix_1.SingularValueDecomposition(M);\n      var eigenValues_1 = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();\n      return ret.leftSingularVectors.toJSON().map(function (row) {\n        return ml_matrix_1.Matrix.mul([row], [eigenValues_1]).toJSON()[0].splice(0, dimension);\n      });\n    } catch (_a) {\n      var res = [];\n\n      for (var i = 0; i < distances.length; i++) {\n        var x = Math.random() * linkDistance;\n        var y = Math.random() * linkDistance;\n        res.push([x, y]);\n      }\n\n      return res;\n    }\n  };\n\n  return MDS;\n}();\n\nexports.default = MDS;","map":null,"metadata":{},"sourceType":"script"}