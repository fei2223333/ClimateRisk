{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts\n\n/**\n * Given a name and a list of names that are not equal to the name, return a\n * spelling suggestion if there is one that is close enough. Names less than\n * length 3 only check for case-insensitive equality, not Levenshtein distance.\n *\n * - If there is a candidate that's the same except for case, return that.\n * - If there is a candidate that's within one edit of the name, return that.\n * - Otherwise, return the candidate with the smallest Levenshtein distance,\n *     except for candidates:\n *       * With no name\n *       * Whose length differs from the target name by more than 0.34 of the\n *         length of the name.\n *       * Whose levenshtein distance is more than 0.4 of the length of the\n *         name (0.4 allows 1 substitution/transposition for every 5 characters,\n *         and 1 insertion/deletion at 3 characters)\n */\nexport function getSpellingSuggestion(name, candidates, getName) {\n  var maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34)); // If the best result isn't better than this, don't bother.\n\n  var bestDistance = Math.floor(name.length * 0.4) + 1;\n  var bestCandidate;\n  var justCheckExactMatches = false;\n  var nameLowerCase = name.toLowerCase(); // eslint-disable-next-line\n\n  var _iterator = _createForOfIteratorHelper(candidates),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var candidate = _step.value;\n      var candidateName = getName(candidate);\n\n      if (candidateName !== undefined && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference) {\n        var candidateNameLowerCase = candidateName.toLowerCase();\n\n        if (candidateNameLowerCase === nameLowerCase) {\n          if (candidateName === name) {\n            continue;\n          }\n\n          return candidate;\n        }\n\n        if (justCheckExactMatches) {\n          continue;\n        }\n\n        if (candidateName.length < 3) {\n          // Don't bother, user would have noticed a\n          // 2-character name having an extra character.\n          continue;\n        } // Only care about a result better than the best so far.\n\n\n        var distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);\n\n        if (distance === undefined) {\n          continue;\n        }\n\n        if (distance < 3) {\n          justCheckExactMatches = true;\n          bestCandidate = candidate;\n        } else {\n          // Debug.assert(distance < bestDistance)\n          bestDistance = distance;\n          bestCandidate = candidate;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return bestCandidate;\n}\n\nfunction levenshteinWithMax(s1, s2, max) {\n  var previous = new Array(s2.length + 1); // eslint-disable-line\n\n  var current = new Array(s2.length + 1); // eslint-disable-line\n\n  /** Represents any value > max. We don't care about the particular value. */\n\n  var big = max + 1;\n\n  for (var i = 0; i <= s2.length; i += 1) {\n    previous[i] = i;\n  }\n\n  for (var _i = 1; _i <= s1.length; _i += 1) {\n    var c1 = s1.charCodeAt(_i - 1);\n    var minJ = _i > max ? _i - max : 1;\n    var maxJ = s2.length > max + _i ? max + _i : s2.length;\n    current[0] = _i;\n    /** Smallest value of the matrix in the ith column. */\n\n    var colMin = _i;\n\n    for (var j = 1; j < minJ; j += 1) {\n      current[j] = big;\n    }\n\n    for (var _j = minJ; _j <= maxJ; _j += 1) {\n      var dist = c1 === s2.charCodeAt(_j - 1) ? previous[_j - 1] : Math.min(\n      /* delete */\n      previous[_j] + 1,\n      /* insert */\n      current[_j - 1] + 1,\n      /* substitute */\n      previous[_j - 1] + 2);\n      current[_j] = dist;\n      colMin = Math.min(colMin, dist);\n    }\n\n    for (var _j2 = maxJ + 1; _j2 <= s2.length; _j2 += 1) {\n      current[_j2] = big;\n    }\n\n    if (colMin > max) {\n      // Give up -- everything in this column is > max\n      // and it can't get better in future columns.\n      return undefined;\n    }\n\n    var temp = previous;\n    previous = current;\n    current = temp;\n  }\n\n  var res = previous[s2.length];\n  return res > max ? undefined : res;\n}","map":null,"metadata":{},"sourceType":"module"}