{"ast":null,"code":"import _defineProperty from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt, FunctionExt, Dom, Vector } from '../util';\nimport { Router, Connector, NodeAnchor, EdgeAnchor, ConnectionPoint } from '../registry';\nimport { Edge } from '../model/edge';\nimport { Markup } from './markup';\nimport { CellView } from './cell';\nexport var EdgeView = /*#__PURE__*/function (_CellView) {\n  _inherits(EdgeView, _CellView);\n\n  function EdgeView() {\n    var _this;\n\n    _classCallCheck(this, EdgeView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EdgeView).apply(this, arguments));\n    _this.POINT_ROUNDING = 2;\n    _this.markerCache = {}; // #endregion\n    // #endregion\n\n    return _this;\n  }\n\n  _createClass(EdgeView, [{\n    key: \"getContainerClassName\",\n    value: function getContainerClassName() {\n      return [_get(_getPrototypeOf(EdgeView.prototype), \"getContainerClassName\", this).call(this), this.prefixClassName('edge')].join(' ');\n    }\n  }, {\n    key: \"isEdgeView\",\n    value: function isEdgeView() {\n      return true;\n    }\n  }, {\n    key: \"confirmUpdate\",\n    value: function confirmUpdate(flag) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ref = flag;\n\n      if (this.hasAction(ref, 'source')) {\n        if (!this.updateTerminalProperties('source')) {\n          return ref;\n        }\n\n        ref = this.removeAction(ref, 'source');\n      }\n\n      if (this.hasAction(ref, 'target')) {\n        if (!this.updateTerminalProperties('target')) {\n          return ref;\n        }\n\n        ref = this.removeAction(ref, 'target');\n      }\n\n      var graph = this.graph;\n      var sourceView = this.sourceView;\n      var targetView = this.targetView;\n\n      if (graph && (sourceView && !graph.renderer.isViewMounted(sourceView) || targetView && !graph.renderer.isViewMounted(targetView))) {\n        // Wait for the sourceView and targetView to be rendered.\n        return ref;\n      }\n\n      if (this.hasAction(ref, 'render')) {\n        this.render();\n        ref = this.removeAction(ref, ['render', 'update', 'vertices', 'labels', 'tools', 'widget']);\n        return ref;\n      }\n\n      ref = this.handleAction(ref, 'vertices', function () {\n        return _this2.renderVertexMarkers();\n      });\n      ref = this.handleAction(ref, 'update', function () {\n        return _this2.update(null, options);\n      });\n      ref = this.handleAction(ref, 'labels', function () {\n        return _this2.onLabelsChange(options);\n      });\n      ref = this.handleAction(ref, 'tools', function () {\n        _this2.renderTools();\n\n        _this2.updateToolsPosition();\n      });\n      ref = this.handleAction(ref, 'widget', function () {\n        return _this2.renderExternalTools();\n      });\n      return ref;\n    }\n  }, {\n    key: \"onLabelsChange\",\n    value: function onLabelsChange() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      // Note: this optimization works in async=false mode only\n      if (this.shouldRerenderLabels(options)) {\n        this.renderLabels();\n      } else {\n        this.updateLabels();\n      }\n\n      this.updateLabelPositions();\n    }\n  }, {\n    key: \"shouldRerenderLabels\",\n    value: function shouldRerenderLabels() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var previousLabels = this.cell.previous('labels');\n\n      if (previousLabels == null) {\n        return true;\n      } // Here is an optimization for cases when we know, that change does\n      // not require re-rendering of all labels.\n\n\n      if ('propertyPathArray' in options && 'propertyValue' in options) {\n        // The label is setting by `prop()` method\n        var pathArray = options.propertyPathArray || [];\n        var pathLength = pathArray.length;\n\n        if (pathLength > 1) {\n          // We are changing a single label here e.g. 'labels/0/position'\n          var index = pathArray[1];\n\n          if (previousLabels[index]) {\n            if (pathLength === 2) {\n              // We are changing the entire label. Need to check if the\n              // markup is also being changed.\n              return typeof options.propertyValue === 'object' && ObjectExt.has(options.propertyValue, 'markup');\n            } // We are changing a label property but not the markup\n\n\n            if (pathArray[2] !== 'markup') {\n              return false;\n            }\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.empty();\n      this.containers = {};\n      this.renderMarkup();\n      this.renderLabels();\n      this.update();\n      return this;\n    }\n  }, {\n    key: \"renderMarkup\",\n    value: function renderMarkup() {\n      var markup = this.cell.markup;\n\n      if (markup) {\n        if (typeof markup === 'string') {\n          return this.renderStringMarkup(markup);\n        }\n\n        return this.renderJSONMarkup(markup);\n      }\n\n      throw new TypeError('Invalid edge markup.');\n    }\n  }, {\n    key: \"renderJSONMarkup\",\n    value: function renderJSONMarkup(markup) {\n      var ret = this.parseJSONMarkup(markup, this.container);\n      this.selectors = ret.selectors;\n      this.container.append(ret.fragment);\n    }\n  }, {\n    key: \"renderStringMarkup\",\n    value: function renderStringMarkup(markup) {\n      var cache = this.containers;\n      var children = Vector.createVectors(markup); // Cache children elements for quicker access.\n\n      children.forEach(function (child) {\n        var className = child.attr('class');\n\n        if (className) {\n          cache[StringExt.camelCase(className)] = child.node;\n        }\n      });\n      this.renderTools();\n      this.renderVertexMarkers();\n      this.renderArrowheadMarkers();\n      Dom.append(this.container, children.map(function (child) {\n        return child.node;\n      }));\n    }\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      var edge = this.cell;\n      var labels = edge.getLabels();\n      var count = labels.length;\n      var container = this.containers.labels;\n      this.labelCache = {};\n      this.labelSelectors = {};\n\n      if (count <= 0) {\n        if (container && container.parentNode) {\n          container.parentNode.removeChild(container);\n        }\n\n        return this;\n      }\n\n      if (container) {\n        this.empty(container);\n      } else {\n        container = Dom.createSvgElement('g');\n        this.addClass(this.prefixClassName('edge-labels'), container);\n        this.containers.labels = container;\n      }\n\n      for (var i = 0, ii = labels.length; i < ii; i += 1) {\n        var label = labels[i];\n        var normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));\n        var labelNode = void 0;\n        var selectors = void 0;\n\n        if (normalized) {\n          labelNode = normalized.node;\n          selectors = normalized.selectors;\n        } else {\n          var defaultLabel = edge.getDefaultLabel();\n\n          var _normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));\n\n          labelNode = _normalized.node;\n          selectors = _normalized.selectors;\n        }\n\n        labelNode.setAttribute('data-index', \"\".concat(i));\n        container.appendChild(labelNode);\n        var rootSelector = this.rootSelector;\n\n        if (selectors[rootSelector]) {\n          throw new Error('Ambiguous label root selector.');\n        }\n\n        selectors[rootSelector] = labelNode;\n        this.labelCache[i] = labelNode;\n        this.labelSelectors[i] = selectors;\n      }\n\n      if (container.parentNode == null) {\n        this.container.appendChild(container);\n      }\n\n      this.updateLabels();\n      this.customizeLabels();\n      return this;\n    }\n  }, {\n    key: \"parseLabelMarkup\",\n    value: function parseLabelMarkup(markup) {\n      if (markup) {\n        if (typeof markup === 'string') {\n          return this.parseLabelStringMarkup(markup);\n        }\n\n        return this.parseJSONMarkup(markup);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"parseLabelStringMarkup\",\n    value: function parseLabelStringMarkup(labelMarkup) {\n      var children = Vector.createVectors(labelMarkup);\n      var fragment = document.createDocumentFragment();\n\n      for (var i = 0, n = children.length; i < n; i += 1) {\n        var currentChild = children[i].node;\n        fragment.appendChild(currentChild);\n      }\n\n      return {\n        fragment: fragment,\n        selectors: {}\n      };\n    }\n  }, {\n    key: \"normalizeLabelMarkup\",\n    value: function normalizeLabelMarkup(markup) {\n      if (markup == null) {\n        return;\n      }\n\n      var fragment = markup.fragment;\n\n      if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n        throw new Error('Invalid label markup.');\n      }\n\n      var vel;\n      var childNodes = fragment.childNodes;\n\n      if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n        // default markup fragment is not wrapped in `<g/>`\n        // add a `<g/>` container\n        vel = Vector.create('g').append(fragment);\n      } else {\n        vel = Vector.create(childNodes[0]);\n      }\n\n      vel.addClass(this.prefixClassName('edge-label'));\n      return {\n        node: vel.node,\n        selectors: markup.selectors\n      };\n    }\n  }, {\n    key: \"updateLabels\",\n    value: function updateLabels() {\n      if (this.containers.labels) {\n        var edge = this.cell;\n        var labels = edge.labels;\n        var canLabelMove = this.can('edgeLabelMovable');\n        var defaultLabel = edge.getDefaultLabel();\n\n        for (var i = 0, n = labels.length; i < n; i += 1) {\n          var elem = this.labelCache[i];\n          var selectors = this.labelSelectors[i];\n          elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n          var label = labels[i];\n          var attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs);\n          this.updateAttrs(elem, attrs, {\n            selectors: selectors,\n            rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined\n          });\n        }\n      }\n    }\n  }, {\n    key: \"mergeLabelAttrs\",\n    value: function mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {\n      if (labelAttrs === null) {\n        return null;\n      }\n\n      if (labelAttrs === undefined) {\n        if (defaultLabelAttrs === null) {\n          return null;\n        }\n\n        if (defaultLabelAttrs === undefined) {\n          return undefined;\n        }\n\n        if (hasCustomMarkup) {\n          return defaultLabelAttrs;\n        }\n\n        return ObjectExt.merge({}, defaultLabelAttrs);\n      }\n\n      if (hasCustomMarkup) {\n        return ObjectExt.merge({}, defaultLabelAttrs, labelAttrs);\n      }\n    }\n  }, {\n    key: \"customizeLabels\",\n    value: function customizeLabels() {\n      if (this.containers.labels) {\n        var edge = this.cell;\n        var labels = edge.labels;\n\n        for (var i = 0, n = labels.length; i < n; i += 1) {\n          var label = labels[i];\n          var container = this.labelCache[i];\n          var selectors = this.labelSelectors[i];\n          this.graph.hook.onEdgeLabelRendered({\n            edge: edge,\n            label: label,\n            container: container,\n            selectors: selectors\n          });\n        }\n      }\n    }\n  }, {\n    key: \"renderTools\",\n    value: function renderTools() {\n      var container = this.containers.tools;\n\n      if (container == null) {\n        return this;\n      }\n\n      var markup = this.cell.toolMarkup;\n      var $container = this.$(container).empty();\n\n      if (Markup.isStringMarkup(markup)) {\n        var template = StringExt.template(markup);\n        var tool = Vector.create(template());\n        $container.append(tool.node);\n        this.toolCache = tool.node; // If `doubleTools` is enabled, we render copy of the tools on the\n        // other side of the edge as well but only if the edge is longer\n        // than `longLength`.\n\n        if (this.options.doubleTools) {\n          var tool2;\n          var doubleToolMarkup = this.cell.doubleToolMarkup;\n\n          if (Markup.isStringMarkup(doubleToolMarkup)) {\n            template = StringExt.template(doubleToolMarkup);\n            tool2 = Vector.create(template());\n          } else {\n            tool2 = tool.clone();\n          }\n\n          $container.append(tool2.node);\n          this.tool2Cache = tool2.node;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"renderExternalTools\",\n    value: function renderExternalTools() {\n      var tools = this.cell.getTools();\n      this.addTools(tools);\n      return this;\n    }\n  }, {\n    key: \"renderVertexMarkers\",\n    value: function renderVertexMarkers() {\n      var container = this.containers.vertices;\n\n      if (container == null) {\n        return this;\n      }\n\n      var markup = this.cell.vertexMarkup;\n      var $container = this.$(container).empty();\n\n      if (Markup.isStringMarkup(markup)) {\n        var template = StringExt.template(markup);\n        this.cell.getVertices().forEach(function (vertex, index) {\n          $container.append(Vector.create(template(Object.assign({\n            index: index\n          }, vertex))).node);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"renderArrowheadMarkers\",\n    value: function renderArrowheadMarkers() {\n      var container = this.containers.arrowheads;\n\n      if (container == null) {\n        return this;\n      }\n\n      var markup = this.cell.arrowheadMarkup;\n      var $container = this.$(container).empty();\n\n      if (Markup.isStringMarkup(markup)) {\n        var template = StringExt.template(markup);\n        var sourceArrowhead = Vector.create(template({\n          end: 'source'\n        })).node;\n        var targetArrowhead = Vector.create(template({\n          end: 'target'\n        })).node;\n        this.containers.sourceArrowhead = sourceArrowhead;\n        this.containers.targetArrowhead = targetArrowhead;\n        $container.append(sourceArrowhead, targetArrowhead);\n      }\n\n      return this;\n    } // #endregion\n    // #region updating\n\n  }, {\n    key: \"update\",\n    value: function update(partialAttrs) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.cleanCache();\n      this.updateConnection(options);\n      var attrs = this.cell.getAttrs();\n\n      if (attrs != null) {\n        this.updateAttrs(this.container, attrs, {\n          attrs: partialAttrs === attrs ? null : partialAttrs,\n          selectors: this.selectors\n        });\n      }\n\n      this.updateConnectionPath();\n      this.updateLabelPositions();\n      this.updateToolsPosition();\n      this.updateArrowheadMarkers();\n\n      if (options.toolId == null) {\n        this.renderExternalTools();\n      } else {\n        this.updateTools(options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeRedundantLinearVertices\",\n    value: function removeRedundantLinearVertices() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var edge = this.cell;\n      var vertices = edge.getVertices();\n      var routePoints = [this.sourceAnchor].concat(_toConsumableArray(vertices), [this.targetAnchor]);\n      var rawCount = routePoints.length; // Puts the route points into a polyline and try to simplify.\n\n      var polyline = new Polyline(routePoints);\n      polyline.simplify({\n        threshold: 0.01\n      });\n      var simplifiedPoints = polyline.points.map(function (point) {\n        return point.toJSON();\n      });\n      var simplifiedCount = simplifiedPoints.length; // If simplification did not remove any redundant vertices.\n\n      if (rawCount === simplifiedCount) {\n        return 0;\n      } // Sets simplified polyline points as edge vertices.\n      // Removes first and last polyline points again (source/target anchors).\n\n\n      edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);\n      return rawCount - simplifiedCount;\n    }\n  }, {\n    key: \"updateConnectionPath\",\n    value: function updateConnectionPath() {\n      var containers = this.containers;\n\n      if (containers.connection) {\n        var pathData = this.getConnectionPathData();\n        containers.connection.setAttribute('d', pathData);\n      }\n\n      if (containers.connectionWrap) {\n        var _pathData = this.getConnectionPathData();\n\n        containers.connectionWrap.setAttribute('d', _pathData);\n      }\n\n      if (containers.sourceMarker && containers.targetMarker) {\n        this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);\n      }\n    }\n  }, {\n    key: \"getTerminalView\",\n    value: function getTerminalView(type) {\n      switch (type) {\n        case 'source':\n          return this.sourceView || null;\n\n        case 'target':\n          return this.targetView || null;\n\n        default:\n          throw new Error(\"Unknown terminal type '\".concat(type, \"'\"));\n      }\n    }\n  }, {\n    key: \"getTerminalAnchor\",\n    value: function getTerminalAnchor(type) {\n      switch (type) {\n        case 'source':\n          return Point.create(this.sourceAnchor);\n\n        case 'target':\n          return Point.create(this.targetAnchor);\n\n        default:\n          throw new Error(\"Unknown terminal type '\".concat(type, \"'\"));\n      }\n    }\n  }, {\n    key: \"getTerminalConnectionPoint\",\n    value: function getTerminalConnectionPoint(type) {\n      switch (type) {\n        case 'source':\n          return Point.create(this.sourcePoint);\n\n        case 'target':\n          return Point.create(this.targetPoint);\n\n        default:\n          throw new Error(\"Unknown terminal type '\".concat(type, \"'\"));\n      }\n    }\n  }, {\n    key: \"getTerminalMagnet\",\n    value: function getTerminalMagnet(type) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      switch (type) {\n        case 'source':\n          {\n            if (options.raw) {\n              return this.sourceMagnet;\n            }\n\n            var sourceView = this.sourceView;\n\n            if (!sourceView) {\n              return null;\n            }\n\n            return this.sourceMagnet || sourceView.container;\n          }\n\n        case 'target':\n          {\n            if (options.raw) {\n              return this.targetMagnet;\n            }\n\n            var targetView = this.targetView;\n\n            if (!targetView) {\n              return null;\n            }\n\n            return this.targetMagnet || targetView.container;\n          }\n\n        default:\n          {\n            throw new Error(\"Unknown terminal type '\".concat(type, \"'\"));\n          }\n      }\n    }\n  }, {\n    key: \"updateConnection\",\n    value: function updateConnection() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var edge = this.cell; // The edge is being translated by an ancestor that will shift\n      // source, target and vertices by an equal distance.\n\n      if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {\n        var tx = options.tx || 0;\n        var ty = options.ty || 0;\n        this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;\n        this.translateConnectionPoints(tx, ty);\n        this.path.translate(tx, ty);\n      } else {\n        var vertices = edge.getVertices(); // 1. Find anchor points\n\n        var anchors = this.findAnchors(vertices);\n        this.sourceAnchor = anchors.source;\n        this.targetAnchor = anchors.target; // 2. Find route points\n\n        this.routePoints = this.findRoutePoints(vertices); // 3. Find connection points\n\n        var connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target; // 4. Find Marker Connection Point\n\n        var markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint); // 5. Make path\n\n        this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);\n      }\n\n      this.cleanCache();\n    }\n  }, {\n    key: \"findAnchors\",\n    value: function findAnchors(vertices) {\n      var edge = this.cell;\n      var source = edge.source;\n      var target = edge.target;\n      var firstVertex = vertices[0];\n      var lastVertex = vertices[vertices.length - 1];\n\n      if (target.priority && !source.priority) {\n        // Reversed order\n        return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n      } // Usual order\n\n\n      return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    }\n  }, {\n    key: \"findAnchorsOrdered\",\n    value: function findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {\n      var _ref;\n\n      var firstAnchor;\n      var secondAnchor;\n      var edge = this.cell;\n      var firstTerminal = edge[firstType];\n      var secondTerminal = edge[secondType];\n      var firstView = this.getTerminalView(firstType);\n      var secondView = this.getTerminalView(secondType);\n      var firstMagnet = this.getTerminalMagnet(firstType);\n      var secondMagnet = this.getTerminalMagnet(secondType);\n\n      if (firstView) {\n        var firstRef;\n\n        if (firstPoint) {\n          firstRef = Point.create(firstPoint);\n        } else if (secondView) {\n          firstRef = secondMagnet;\n        } else {\n          firstRef = Point.create(secondTerminal);\n        }\n\n        firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);\n      } else {\n        firstAnchor = Point.create(firstTerminal);\n      }\n\n      if (secondView) {\n        var secondRef = Point.create(secondPoint || firstAnchor);\n        secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);\n      } else {\n        secondAnchor = Point.isPointLike(secondTerminal) ? Point.create(secondTerminal) : new Point();\n      }\n\n      return _ref = {}, _defineProperty(_ref, firstType, firstAnchor), _defineProperty(_ref, secondType, secondAnchor), _ref;\n    }\n  }, {\n    key: \"getAnchor\",\n    value: function getAnchor(def, cellView, magnet, ref, terminalType) {\n      var isEdge = cellView.isEdgeElement(magnet);\n      var connecting = this.graph.options.connecting;\n      var config = typeof def === 'string' ? {\n        name: def\n      } : def;\n\n      if (!config) {\n        var defaults = isEdge ? (terminalType === 'source' ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === 'source' ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;\n        config = typeof defaults === 'string' ? {\n          name: defaults\n        } : defaults;\n      }\n\n      if (!config) {\n        throw new Error(\"Anchor should be specified.\");\n      }\n\n      var anchor;\n      var name = config.name;\n\n      if (isEdge) {\n        var fn = EdgeAnchor.registry.get(name);\n\n        if (typeof fn !== 'function') {\n          return EdgeAnchor.registry.onNotFound(name);\n        }\n\n        anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n      } else {\n        var _fn = NodeAnchor.registry.get(name);\n\n        if (typeof _fn !== 'function') {\n          return NodeAnchor.registry.onNotFound(name);\n        }\n\n        anchor = FunctionExt.call(_fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n      }\n\n      return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();\n    }\n  }, {\n    key: \"findRoutePoints\",\n    value: function findRoutePoints() {\n      var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var defaultRouter = this.graph.options.connecting.router || Router.presets.normal;\n      var router = this.cell.getRouter() || defaultRouter;\n      var routePoints;\n\n      if (typeof router === 'function') {\n        routePoints = FunctionExt.call(router, this, vertices, {}, this);\n      } else {\n        var name = typeof router === 'string' ? router : router.name;\n        var args = typeof router === 'string' ? {} : router.args || {};\n        var fn = name ? Router.registry.get(name) : Router.presets.normal;\n\n        if (typeof fn !== 'function') {\n          return Router.registry.onNotFound(name);\n        }\n\n        routePoints = FunctionExt.call(fn, this, vertices, args, this);\n      }\n\n      return routePoints == null ? vertices.map(function (p) {\n        return Point.create(p);\n      }) : routePoints.map(function (p) {\n        return Point.create(p);\n      });\n    }\n  }, {\n    key: \"findConnectionPoints\",\n    value: function findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {\n      var edge = this.cell;\n      var connecting = this.graph.options.connecting;\n      var sourceTerminal = edge.getSource();\n      var targetTerminal = edge.getTarget();\n      var sourceView = this.sourceView;\n      var targetView = this.targetView;\n      var firstRoutePoint = routePoints[0];\n      var lastRoutePoint = routePoints[routePoints.length - 1]; // source\n\n      var sourcePoint;\n\n      if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n        var sourceMagnet = this.sourceMagnet || sourceView.container;\n        var sourcePointRef = firstRoutePoint || targetAnchor;\n        var sourceLine = new Line(sourcePointRef, sourceAnchor);\n        var connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;\n        sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n      } else {\n        sourcePoint = sourceAnchor;\n      } // target\n\n\n      var targetPoint;\n\n      if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n        var targetMagnet = this.targetMagnet || targetView.container;\n        var targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;\n        var targetPointRef = lastRoutePoint || sourceAnchor;\n        var targetLine = new Line(targetPointRef, targetAnchor);\n        targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n      } else {\n        targetPoint = targetAnchor;\n      }\n\n      return {\n        source: sourcePoint,\n        target: targetPoint\n      };\n    }\n  }, {\n    key: \"getConnectionPoint\",\n    value: function getConnectionPoint(def, view, magnet, line, endType) {\n      var anchor = line.end;\n\n      if (def == null) {\n        return anchor;\n      }\n\n      var name = typeof def === 'string' ? def : def.name;\n      var args = typeof def === 'string' ? {} : def.args;\n      var fn = ConnectionPoint.registry.get(name);\n\n      if (typeof fn !== 'function') {\n        return ConnectionPoint.registry.onNotFound(name);\n      }\n\n      var connectionPoint = FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);\n      return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;\n    }\n  }, {\n    key: \"updateMarkerAttr\",\n    value: function updateMarkerAttr(type) {\n      var attrs = this.cell.getAttrs();\n      var key = \".\".concat(type, \"-marker\");\n      var partial = attrs && attrs[key];\n\n      if (partial) {\n        this.updateAttrs(this.container, {}, {\n          attrs: _defineProperty({}, key, partial),\n          selectors: this.selectors\n        });\n      }\n    }\n  }, {\n    key: \"findMarkerPoints\",\n    value: function findMarkerPoints(routePoints, sourcePoint, targetPoint) {\n      var _this3 = this;\n\n      var getLineWidth = function getLineWidth(type) {\n        var attrs = _this3.cell.getAttrs();\n\n        var keys = Object.keys(attrs);\n\n        for (var i = 0, l = keys.length; i < l; i += 1) {\n          var attr = attrs[keys[i]];\n\n          if (attr[\"\".concat(type, \"Marker\")] || attr[\"\".concat(type, \"-marker\")]) {\n            var strokeWidth = attr.strokeWidth || attr['stroke-width'];\n\n            if (strokeWidth) {\n              return parseFloat(strokeWidth);\n            }\n\n            break;\n          }\n        }\n\n        return null;\n      };\n\n      var firstRoutePoint = routePoints[0];\n      var lastRoutePoint = routePoints[routePoints.length - 1];\n      var sourceMarkerElem = this.containers.sourceMarker;\n      var targetMarkerElem = this.containers.targetMarker;\n      var cache = this.markerCache;\n      var sourceMarkerPoint;\n      var targetMarkerPoint; // Move the source point by the width of the marker taking into\n      // account its scale around x-axis. Note that scale is the only\n      // transform that makes sense to be set in `.marker-source`\n      // attributes object as all other transforms (translate/rotate)\n      // will be replaced by the `translateAndAutoOrient()` function.\n\n      if (sourceMarkerElem) {\n        this.updateMarkerAttr('source'); // support marker connection point registry???\n\n        cache.sourceBBox = cache.sourceBBox || Dom.getBBox(sourceMarkerElem);\n\n        if (cache.sourceBBox.width > 0) {\n          var scale = Dom.scale(sourceMarkerElem);\n          sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1);\n        }\n      } else {\n        var strokeWidth = getLineWidth('source');\n\n        if (strokeWidth) {\n          sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -strokeWidth);\n        }\n      }\n\n      if (targetMarkerElem) {\n        this.updateMarkerAttr('target');\n        cache.targetBBox = cache.targetBBox || Dom.getBBox(targetMarkerElem);\n\n        if (cache.targetBBox.width > 0) {\n          var _scale = Dom.scale(targetMarkerElem);\n\n          targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, cache.targetBBox.width * _scale.sx * -1);\n        }\n      } else {\n        var _strokeWidth = getLineWidth('target');\n\n        if (_strokeWidth) {\n          targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -_strokeWidth);\n        }\n      } // If there was no markup for the marker, use the connection point.\n\n\n      cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n      cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n      return {\n        source: sourceMarkerPoint,\n        target: targetMarkerPoint\n      };\n    }\n  }, {\n    key: \"findPath\",\n    value: function findPath(routePoints, sourcePoint, targetPoint) {\n      var def = this.cell.getConnector() || this.graph.options.connecting.connector;\n      var name;\n      var args;\n      var fn;\n\n      if (typeof def === 'string') {\n        name = def;\n      } else {\n        name = def.name;\n        args = def.args;\n      }\n\n      if (name) {\n        var method = Connector.registry.get(name);\n\n        if (typeof method !== 'function') {\n          return Connector.registry.onNotFound(name);\n        }\n\n        fn = method;\n      } else {\n        fn = Connector.presets.normal;\n      }\n\n      var path = FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), {\n        raw: true\n      }), this);\n      return typeof path === 'string' ? Path.parse(path) : path;\n    }\n  }, {\n    key: \"translateConnectionPoints\",\n    value: function translateConnectionPoints(tx, ty) {\n      var cache = this.markerCache;\n\n      if (cache.sourcePoint) {\n        cache.sourcePoint.translate(tx, ty);\n      }\n\n      if (cache.targetPoint) {\n        cache.targetPoint.translate(tx, ty);\n      }\n\n      this.sourcePoint.translate(tx, ty);\n      this.targetPoint.translate(tx, ty);\n      this.sourceAnchor.translate(tx, ty);\n      this.targetAnchor.translate(tx, ty);\n    }\n  }, {\n    key: \"updateLabelPositions\",\n    value: function updateLabelPositions() {\n      if (this.containers.labels == null) {\n        return this;\n      }\n\n      var path = this.path;\n\n      if (!path) {\n        return this;\n      }\n\n      var edge = this.cell;\n      var labels = edge.getLabels();\n\n      if (labels.length === 0) {\n        return this;\n      }\n\n      var defaultLabel = edge.getDefaultLabel();\n      var defaultPosition = this.normalizeLabelPosition(defaultLabel.position);\n\n      for (var i = 0, ii = labels.length; i < ii; i += 1) {\n        var label = labels[i];\n        var labelPosition = this.normalizeLabelPosition(label.position);\n        var pos = ObjectExt.merge({}, defaultPosition, labelPosition);\n        var matrix = this.getLabelTransformationMatrix(pos);\n        this.labelCache[i].setAttribute('transform', Dom.matrixToTransformString(matrix));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateToolsPosition\",\n    value: function updateToolsPosition() {\n      if (this.containers.tools == null) {\n        return this;\n      } // Move the tools a bit to the target position but don't cover the\n      // `sourceArrowhead` marker. Note that the offset is hardcoded here.\n      // The offset should be always more than the\n      // `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n      // this up all the time would be slow.\n\n\n      var scale = '';\n      var offset = this.options.toolsOffset;\n      var connectionLength = this.getConnectionLength(); // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).\n      // In that case we won't update tools position at all.\n\n      if (connectionLength != null) {\n        // If the edge is too short, make the tools half the\n        // size and the offset twice as low.\n        if (connectionLength < this.options.shortLength) {\n          scale = 'scale(.5)';\n          offset /= 2;\n        }\n\n        var pos = this.getPointAtLength(offset);\n\n        if (pos != null) {\n          Dom.attr(this.toolCache, 'transform', \"translate(\".concat(pos.x, \",\").concat(pos.y, \") \").concat(scale));\n        }\n\n        if (this.options.doubleTools && connectionLength >= this.options.longLength) {\n          var doubleToolsOffset = this.options.doubleToolsOffset || offset;\n          pos = this.getPointAtLength(connectionLength - doubleToolsOffset);\n\n          if (pos != null) {\n            Dom.attr(this.tool2Cache, 'transform', \"translate(\".concat(pos.x, \",\").concat(pos.y, \") \").concat(scale));\n          }\n\n          Dom.attr(this.tool2Cache, 'visibility', 'visible');\n        } else if (this.options.doubleTools) {\n          Dom.attr(this.tool2Cache, 'visibility', 'hidden');\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateArrowheadMarkers\",\n    value: function updateArrowheadMarkers() {\n      var container = this.containers.arrowheads;\n\n      if (container == null) {\n        return this;\n      }\n\n      if (container.style.display === 'none') {\n        return this;\n      }\n\n      var sourceArrowhead = this.containers.sourceArrowhead;\n      var targetArrowhead = this.containers.targetArrowhead;\n\n      if (sourceArrowhead && targetArrowhead) {\n        var len = this.getConnectionLength() || 0;\n        var sx = len < this.options.shortLength ? 0.5 : 1;\n        Dom.scale(sourceArrowhead, sx);\n        Dom.scale(targetArrowhead, sx);\n        this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateTerminalProperties\",\n    value: function updateTerminalProperties(type) {\n      var edge = this.cell;\n      var graph = this.graph;\n      var terminal = edge[type];\n      var nodeId = terminal && terminal.cell;\n      var viewKey = \"\".concat(type, \"View\"); // terminal is a point\n\n      if (!nodeId) {\n        this[viewKey] = null;\n        this.updateTerminalMagnet(type);\n        return true;\n      }\n\n      var terminalCell = graph.getCellById(nodeId);\n\n      if (!terminalCell) {\n        throw new Error(\"Edge's \".concat(type, \" node with id \\\"\").concat(nodeId, \"\\\" not exists\"));\n      }\n\n      var endView = terminalCell.findView(graph);\n\n      if (!endView) {\n        return false;\n      }\n\n      this[viewKey] = endView;\n      this.updateTerminalMagnet(type);\n      return true;\n    }\n  }, {\n    key: \"updateTerminalMagnet\",\n    value: function updateTerminalMagnet(type) {\n      var propName = \"\".concat(type, \"Magnet\");\n      var terminalView = this.getTerminalView(type);\n\n      if (terminalView) {\n        var magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);\n\n        if (magnet === terminalView.container) {\n          magnet = null;\n        }\n\n        this[propName] = magnet;\n      } else {\n        this[propName] = null;\n      }\n    }\n  }, {\n    key: \"translateAndAutoOrientArrows\",\n    value: function translateAndAutoOrientArrows(sourceArrow, targetArrow) {\n      var route = this.routePoints;\n\n      if (sourceArrow) {\n        Dom.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);\n      }\n\n      if (targetArrow) {\n        Dom.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);\n      }\n    }\n  }, {\n    key: \"getLabelPositionAngle\",\n    value: function getLabelPositionAngle(idx) {\n      var label = this.cell.getLabelAt(idx);\n\n      if (label && label.position && typeof label.position === 'object') {\n        return label.position.angle || 0;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"getLabelPositionArgs\",\n    value: function getLabelPositionArgs(idx) {\n      var label = this.cell.getLabelAt(idx);\n\n      if (label && label.position && typeof label.position === 'object') {\n        return label.position.options;\n      }\n    }\n  }, {\n    key: \"getDefaultLabelPositionArgs\",\n    value: function getDefaultLabelPositionArgs() {\n      var defaultLabel = this.cell.getDefaultLabel();\n\n      if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === 'object') {\n        return defaultLabel.position.options;\n      }\n    } // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n\n  }, {\n    key: \"mergeLabelPositionArgs\",\n    value: function mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {\n      if (labelPositionArgs === null) {\n        return null;\n      }\n\n      if (labelPositionArgs === undefined) {\n        if (defaultLabelPositionArgs === null) {\n          return null;\n        }\n\n        return defaultLabelPositionArgs;\n      }\n\n      return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    }\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(p1, p2, p3, options) {\n      var localX;\n      var localY;\n      var localAngle = 0;\n      var localOptions;\n\n      if (typeof p1 !== 'number') {\n        localX = p1.x;\n        localY = p1.y;\n\n        if (typeof p2 === 'number') {\n          localAngle = p2;\n          localOptions = p3;\n        } else {\n          localOptions = p2;\n        }\n      } else {\n        localX = p1;\n        localY = p2;\n\n        if (typeof p3 === 'number') {\n          localAngle = p3;\n          localOptions = options;\n        } else {\n          localOptions = p3;\n        }\n      } // merge label position arguments\n\n\n      var defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n      var labelPositionArgs = localOptions;\n      var positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs); // append label to labels array\n\n      var label = {\n        position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n      };\n      var index = -1;\n      this.cell.insertLabel(label, index, localOptions);\n      return index;\n    }\n  }, {\n    key: \"addVertex\",\n    value: function addVertex(x, y, options) {\n      var isPoint = typeof x !== 'number';\n      var localX = isPoint ? x.x : x;\n      var localY = isPoint ? x.y : y;\n      var localOptions = isPoint ? y : options;\n      var vertex = {\n        x: localX,\n        y: localY\n      };\n      var index = this.getVertexIndex(localX, localY);\n      this.cell.insertVertex(vertex, index, localOptions);\n      return index;\n    }\n  }, {\n    key: \"sendToken\",\n    value: function sendToken(token, options, callback) {\n      var duration;\n      var reversed;\n      var selector;\n      var rorate;\n      var timing = 'linear';\n\n      if (typeof options === 'object') {\n        duration = options.duration;\n        reversed = options.reversed === true;\n        selector = options.selector;\n\n        if (options.rotate === false) {\n          rorate = '';\n        } else if (options.rotate === true) {\n          rorate = 'auto';\n        } else if (options.rotate != null) {\n          rorate = \"\".concat(options.rotate);\n        }\n\n        if (options.timing) {\n          timing = options.timing;\n        }\n      } else {\n        duration = options;\n        reversed = false;\n        selector = null;\n      }\n\n      duration = duration || 1000;\n      var attrs = {\n        dur: \"\".concat(duration, \"ms\"),\n        repeatCount: '1',\n        calcMode: timing,\n        fill: 'freeze'\n      };\n\n      if (rorate) {\n        attrs.rotate = rorate;\n      }\n\n      if (reversed) {\n        attrs.keyPoints = '1;0';\n        attrs.keyTimes = '0;1';\n      }\n\n      if (typeof options === 'object') {\n        var _duration = options.duration,\n            _reversed = options.reversed,\n            _selector = options.selector,\n            rotate = options.rotate,\n            _timing = options.timing,\n            others = __rest(options, [\"duration\", \"reversed\", \"selector\", \"rotate\", \"timing\"]);\n\n        Object.keys(others).forEach(function (key) {\n          attrs[key] = others[key];\n        });\n      }\n\n      var path;\n\n      if (typeof selector === 'string') {\n        path = this.findOne(selector, this.container, this.selectors);\n      } else {\n        // Select connection path automatically.\n        path = this.containers.connection ? this.containers.connection : this.container.querySelector('path');\n      }\n\n      if (!(path instanceof SVGPathElement)) {\n        throw new Error('Token animation requires a valid connection path.');\n      }\n\n      var target = typeof token === 'string' ? this.findOne(token) : token;\n\n      if (target == null) {\n        throw new Error('Token animation requires a valid token element.');\n      }\n\n      var parent = target.parentNode;\n\n      var revert = function revert() {\n        if (!parent) {\n          Dom.remove(target);\n        }\n      };\n\n      var vToken = Vector.create(target);\n\n      if (!parent) {\n        vToken.appendTo(this.graph.view.stage);\n      }\n\n      var onComplete = attrs.complete;\n\n      attrs.complete = function (e) {\n        revert();\n\n        if (callback) {\n          callback();\n        }\n\n        if (onComplete) {\n          onComplete(e);\n        }\n      };\n\n      var stop = vToken.animateAlongPath(attrs, path);\n      return function () {\n        revert();\n        stop();\n      };\n    } // #endregion\n\n  }, {\n    key: \"getConnection\",\n    value: function getConnection() {\n      return this.path != null ? this.path.clone() : null;\n    }\n  }, {\n    key: \"getConnectionPathData\",\n    value: function getConnectionPathData() {\n      if (this.path == null) {\n        return '';\n      }\n\n      var cache = this.cache.pathCache;\n\n      if (!ObjectExt.has(cache, 'data')) {\n        cache.data = this.path.serialize();\n      }\n\n      return cache.data || '';\n    }\n  }, {\n    key: \"getConnectionSubdivisions\",\n    value: function getConnectionSubdivisions() {\n      if (this.path == null) {\n        return null;\n      }\n\n      var cache = this.cache.pathCache;\n\n      if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n        cache.segmentSubdivisions = this.path.getSegmentSubdivisions();\n      }\n\n      return cache.segmentSubdivisions;\n    }\n  }, {\n    key: \"getConnectionLength\",\n    value: function getConnectionLength() {\n      if (this.path == null) {\n        return 0;\n      }\n\n      var cache = this.cache.pathCache;\n\n      if (!ObjectExt.has(cache, 'length')) {\n        cache.length = this.path.length({\n          segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n      }\n\n      return cache.length;\n    }\n  }, {\n    key: \"getPointAtLength\",\n    value: function getPointAtLength(length) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.pointAtLength(length, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getPointAtRatio\",\n    value: function getPointAtRatio(ratio) {\n      if (this.path == null) {\n        return null;\n      }\n\n      if (NumberExt.isPercentage(ratio)) {\n        // eslint-disable-next-line\n        ratio = parseFloat(ratio) / 100;\n      }\n\n      return this.path.pointAt(ratio, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getTangentAtLength\",\n    value: function getTangentAtLength(length) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.tangentAtLength(length, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getTangentAtRatio\",\n    value: function getTangentAtRatio(ratio) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.tangentAt(ratio, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getClosestPoint\",\n    value: function getClosestPoint(point) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.closestPoint(point, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getClosestPointLength\",\n    value: function getClosestPointLength(point) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.closestPointLength(point, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getClosestPointRatio\",\n    value: function getClosestPointRatio(point) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.closestPointNormalizedLength(point, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getLabelPosition\",\n    value: function getLabelPosition(x, y, p3, p4) {\n      var pos = {\n        distance: 0\n      }; // normalize data from the two possible signatures\n\n      var angle = 0;\n      var options;\n\n      if (typeof p3 === 'number') {\n        angle = p3;\n        options = p4;\n      } else {\n        options = p3;\n      }\n\n      if (options != null) {\n        pos.options = options;\n      } // identify distance/offset settings\n\n\n      var isOffsetAbsolute = options && options.absoluteOffset;\n      var isDistanceRelative = !(options && options.absoluteDistance);\n      var isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance; // find closest point t\n\n      var path = this.path;\n      var pathOptions = {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      };\n      var labelPoint = new Point(x, y);\n      var t = path.closestPointT(labelPoint, pathOptions); // distance\n\n      var totalLength = this.getConnectionLength() || 0;\n      var labelDistance = path.lengthAtT(t, pathOptions);\n\n      if (isDistanceRelative) {\n        labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;\n      }\n\n      if (isDistanceAbsoluteReverse) {\n        // fix for end point (-0 => 1)\n        labelDistance = -1 * (totalLength - labelDistance) || 1;\n      }\n\n      pos.distance = labelDistance; // offset\n      // use absolute offset if:\n      // - options.absoluteOffset is true,\n      // - options.absoluteOffset is not true but there is no tangent\n\n      var tangent;\n      if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n      var labelOffset;\n\n      if (tangent) {\n        labelOffset = tangent.pointOffset(labelPoint);\n      } else {\n        var closestPoint = path.pointAtT(t);\n        var labelOffsetDiff = labelPoint.diff(closestPoint);\n        labelOffset = {\n          x: labelOffsetDiff.x,\n          y: labelOffsetDiff.y\n        };\n      }\n\n      pos.offset = labelOffset;\n      pos.angle = angle;\n      return pos;\n    }\n  }, {\n    key: \"normalizeLabelPosition\",\n    value: function normalizeLabelPosition(pos) {\n      if (typeof pos === 'number') {\n        return {\n          distance: pos\n        };\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"getLabelTransformationMatrix\",\n    value: function getLabelTransformationMatrix(labelPosition) {\n      var pos = this.normalizeLabelPosition(labelPosition);\n      var options = pos.options || {};\n      var labelAngle = pos.angle || 0;\n      var labelDistance = pos.distance;\n      var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n      var labelOffset = 0;\n      var offsetCoord = {\n        x: 0,\n        y: 0\n      };\n      var offset = pos.offset;\n\n      if (offset) {\n        if (typeof offset === 'number') {\n          labelOffset = offset;\n        } else {\n          if (offset.x != null) {\n            offsetCoord.x = offset.x;\n          }\n\n          if (offset.y != null) {\n            offsetCoord.y = offset.y;\n          }\n        }\n      }\n\n      var isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;\n      var isKeepGradient = options.keepGradient;\n      var isEnsureLegibility = options.ensureLegibility;\n      var path = this.path;\n      var pathOpt = {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      };\n      var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n      var tangent = path.tangentAtLength(distance, pathOpt);\n      var translation;\n      var angle = labelAngle;\n\n      if (tangent) {\n        if (isOffsetAbsolute) {\n          translation = tangent.start;\n          translation.translate(offsetCoord);\n        } else {\n          var normal = tangent.clone();\n          normal.rotate(-90, tangent.start);\n          normal.setLength(labelOffset);\n          translation = normal.end;\n        }\n\n        if (isKeepGradient) {\n          angle = tangent.angle() + labelAngle;\n\n          if (isEnsureLegibility) {\n            angle = Angle.normalize((angle + 90) % 180 - 90);\n          }\n        }\n      } else {\n        // fallback - the connection has zero length\n        translation = path.start;\n\n        if (isOffsetAbsolute) {\n          translation.translate(offsetCoord);\n        }\n      }\n\n      return Dom.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n    }\n  }, {\n    key: \"getLabelCoordinates\",\n    value: function getLabelCoordinates(pos) {\n      var matrix = this.getLabelTransformationMatrix(pos);\n      return new Point(matrix.e, matrix.f);\n    }\n  }, {\n    key: \"getVertexIndex\",\n    value: function getVertexIndex(x, y) {\n      var edge = this.cell;\n      var vertices = edge.getVertices();\n      var vertexLength = this.getClosestPointLength(new Point(x, y));\n      var index = 0;\n\n      if (vertexLength != null) {\n        for (var ii = vertices.length; index < ii; index += 1) {\n          var currentVertex = vertices[index];\n          var currentLength = this.getClosestPointLength(currentVertex);\n\n          if (currentLength != null && vertexLength < currentLength) {\n            break;\n          }\n        }\n      }\n\n      return index;\n    }\n  }, {\n    key: \"getEventArgs\",\n    value: function getEventArgs(e, x, y) {\n      var view = this; // eslint-disable-line\n\n      var edge = view.cell;\n      var cell = edge;\n\n      if (x == null || y == null) {\n        return {\n          e: e,\n          view: view,\n          edge: edge,\n          cell: cell\n        };\n      }\n\n      return {\n        e: e,\n        x: x,\n        y: y,\n        view: view,\n        edge: edge,\n        cell: cell\n      };\n    }\n  }, {\n    key: \"notifyUnhandledMouseDown\",\n    value: function notifyUnhandledMouseDown(e, x, y) {\n      this.notify('edge:unhandled:mousedown', {\n        e: e,\n        x: x,\n        y: y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n  }, {\n    key: \"notifyMouseDown\",\n    value: function notifyMouseDown(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseDown\", this).call(this, e, x, y);\n\n      this.notify('edge:mousedown', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"notifyMouseMove\",\n    value: function notifyMouseMove(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseMove\", this).call(this, e, x, y);\n\n      this.notify('edge:mousemove', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"notifyMouseUp\",\n    value: function notifyMouseUp(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseUp\", this).call(this, e, x, y);\n\n      this.notify('edge:mouseup', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onClick\",\n    value: function onClick(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onClick\", this).call(this, e, x, y);\n\n      this.notify('edge:click', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onDblClick\",\n    value: function onDblClick(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onDblClick\", this).call(this, e, x, y);\n\n      this.notify('edge:dblclick', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onContextMenu\",\n    value: function onContextMenu(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onContextMenu\", this).call(this, e, x, y);\n\n      this.notify('edge:contextmenu', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(e, x, y) {\n      this.notifyMouseDown(e, x, y);\n      var className = e.target.getAttribute('class');\n\n      switch (className) {\n        case 'vertex':\n          {\n            this.startVertexDragging(e, x, y);\n            return;\n          }\n\n        case 'vertex-remove':\n        case 'vertex-remove-area':\n          {\n            this.handleVertexRemoving(e, x, y);\n            return;\n          }\n\n        case 'connection':\n        case 'connection-wrap':\n          {\n            this.handleVertexAdding(e, x, y);\n            return;\n          }\n\n        case 'arrowhead':\n          {\n            this.startArrowheadDragging(e, x, y);\n            return;\n          }\n\n        case 'source-marker':\n        case 'target-marker':\n          {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n          }\n\n        default:\n          break;\n      }\n\n      this.startEdgeDragging(e, x, y);\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(e, x, y) {\n      var data = this.getEventData(e);\n\n      switch (data.action) {\n        case 'drag-vertex':\n          {\n            this.dragVertex(e, x, y);\n            break;\n          }\n\n        case 'drag-label':\n          {\n            this.dragLabel(e, x, y);\n            break;\n          }\n\n        case 'drag-arrowhead':\n          {\n            this.dragArrowhead(e, x, y);\n            break;\n          }\n\n        case 'drag-edge':\n          {\n            this.dragEdge(e, x, y);\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      this.notifyMouseMove(e, x, y);\n      return data;\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(e, x, y) {\n      var data = this.getEventData(e);\n\n      switch (data.action) {\n        case 'drag-vertex':\n          {\n            this.stopVertexDragging(e, x, y);\n            break;\n          }\n\n        case 'drag-label':\n          {\n            this.stopLabelDragging(e, x, y);\n            break;\n          }\n\n        case 'drag-arrowhead':\n          {\n            this.stopArrowheadDragging(e, x, y);\n            break;\n          }\n\n        case 'drag-edge':\n          {\n            this.stopEdgeDragging(e, x, y);\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      this.notifyMouseUp(e, x, y);\n      this.checkMouseleave(e);\n      return data;\n    }\n  }, {\n    key: \"onMouseOver\",\n    value: function onMouseOver(e) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseOver\", this).call(this, e);\n\n      this.notify('edge:mouseover', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseOut\",\n    value: function onMouseOut(e) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseOut\", this).call(this, e);\n\n      this.notify('edge:mouseout', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseEnter\",\n    value: function onMouseEnter(e) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseEnter\", this).call(this, e);\n\n      this.notify('edge:mouseenter', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave(e) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseLeave\", this).call(this, e);\n\n      this.notify('edge:mouseleave', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(e, x, y, delta) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseWheel\", this).call(this, e, x, y, delta);\n\n      this.notify('edge:mousewheel', Object.assign({\n        delta: delta\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onCustomEvent\",\n    value: function onCustomEvent(e, name, x, y) {\n      // For default edge tool\n      var tool = Dom.findParentByClass(e.target, 'edge-tool', this.container);\n\n      if (tool) {\n        e.stopPropagation(); // no further action to be executed\n\n        if (this.can('useEdgeTools')) {\n          if (name === 'edge:remove') {\n            this.cell.remove({\n              ui: true\n            });\n            return;\n          }\n\n          this.notify('edge:customevent', Object.assign({\n            name: name\n          }, this.getEventArgs(e, x, y)));\n        }\n\n        this.notifyMouseDown(e, x, y);\n      } else {\n        this.notify('edge:customevent', Object.assign({\n          name: name\n        }, this.getEventArgs(e, x, y)));\n\n        _get(_getPrototypeOf(EdgeView.prototype), \"onCustomEvent\", this).call(this, e, name, x, y);\n      }\n    }\n  }, {\n    key: \"onLabelMouseDown\",\n    value: function onLabelMouseDown(e, x, y) {\n      this.notifyMouseDown(e, x, y);\n      this.startLabelDragging(e, x, y);\n      var stopPropagation = this.getEventData(e).stopPropagation;\n\n      if (stopPropagation) {\n        e.stopPropagation();\n      }\n    } // #region drag edge\n\n  }, {\n    key: \"startEdgeDragging\",\n    value: function startEdgeDragging(e, x, y) {\n      if (!this.can('edgeMovable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      }\n\n      this.setEventData(e, {\n        x: x,\n        y: y,\n        moving: false,\n        action: 'drag-edge'\n      });\n    }\n  }, {\n    key: \"dragEdge\",\n    value: function dragEdge(e, x, y) {\n      var data = this.getEventData(e);\n\n      if (!data.moving) {\n        data.moving = true;\n        this.addClass('edge-moving');\n        this.notify('edge:move', {\n          e: e,\n          x: x,\n          y: y,\n          view: this,\n          cell: this.cell,\n          edge: this.cell\n        });\n      }\n\n      this.cell.translate(x - data.x, y - data.y, {\n        ui: true\n      });\n      this.setEventData(e, {\n        x: x,\n        y: y\n      });\n      this.notify('edge:moving', {\n        e: e,\n        x: x,\n        y: y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n  }, {\n    key: \"stopEdgeDragging\",\n    value: function stopEdgeDragging(e, x, y) {\n      var data = this.getEventData(e);\n\n      if (data.moving) {\n        this.removeClass('edge-moving');\n        this.notify('edge:moved', {\n          e: e,\n          x: x,\n          y: y,\n          view: this,\n          cell: this.cell,\n          edge: this.cell\n        });\n      }\n\n      data.moving = false;\n    } // #endregion\n    // #region drag arrowhead\n\n  }, {\n    key: \"prepareArrowheadDragging\",\n    value: function prepareArrowheadDragging(type, options) {\n      var magnet = this.getTerminalMagnet(type);\n      var data = {\n        action: 'drag-arrowhead',\n        x: options.x,\n        y: options.y,\n        isNewEdge: options.isNewEdge === true,\n        terminalType: type,\n        initialMagnet: magnet,\n        initialTerminal: ObjectExt.clone(this.cell[type]),\n        fallbackAction: options.fallbackAction || 'revert',\n        getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n        options: options.options\n      };\n      this.beforeArrowheadDragging(data);\n      return data;\n    }\n  }, {\n    key: \"createValidateConnectionArgs\",\n    value: function createValidateConnectionArgs(type) {\n      var args = [];\n      args[4] = type;\n      args[5] = this;\n      var opposite;\n      var i = 0;\n      var j = 0;\n\n      if (type === 'source') {\n        i = 2;\n        opposite = 'target';\n      } else {\n        j = 2;\n        opposite = 'source';\n      }\n\n      var terminal = this.cell[opposite];\n      var cellId = terminal.cell;\n\n      if (cellId) {\n        var magnet;\n        var view = args[i] = this.graph.renderer.findViewByCell(cellId);\n\n        if (view) {\n          magnet = view.getMagnetFromEdgeTerminal(terminal);\n\n          if (magnet === view.container) {\n            magnet = undefined;\n          }\n        }\n\n        args[i + 1] = magnet;\n      }\n\n      return function (cellView, magnet) {\n        args[j] = cellView;\n        args[j + 1] = cellView.container === magnet ? undefined : magnet;\n        return args;\n      };\n    }\n  }, {\n    key: \"beforeArrowheadDragging\",\n    value: function beforeArrowheadDragging(data) {\n      data.zIndex = this.cell.zIndex;\n      this.cell.toFront();\n      var style = this.container.style;\n      data.pointerEvents = style.pointerEvents;\n      style.pointerEvents = 'none';\n\n      if (this.graph.options.connecting.highlight) {\n        this.highlightAvailableMagnets(data);\n      }\n    }\n  }, {\n    key: \"afterArrowheadDragging\",\n    value: function afterArrowheadDragging(data) {\n      if (data.zIndex != null) {\n        this.cell.setZIndex(data.zIndex, {\n          ui: true\n        });\n        data.zIndex = null;\n      }\n\n      var container = this.container;\n      container.style.pointerEvents = data.pointerEvents || '';\n\n      if (this.graph.options.connecting.highlight) {\n        this.unhighlightAvailableMagnets(data);\n      }\n    }\n  }, {\n    key: \"arrowheadDragging\",\n    value: function arrowheadDragging(target, x, y, data) {\n      data.x = x;\n      data.y = y; // Checking views right under the pointer\n\n      if (data.currentTarget !== target) {\n        // Unhighlight the previous view under pointer if there was one.\n        if (data.currentMagnet && data.currentView) {\n          data.currentView.unhighlight(data.currentMagnet, {\n            type: 'magnetAdsorbed'\n          });\n        }\n\n        data.currentView = this.graph.renderer.findViewByElem(target);\n\n        if (data.currentView) {\n          var _this$graph$hook;\n\n          // If we found a view that is under the pointer, we need to find\n          // the closest magnet based on the real target element of the event.\n          data.currentMagnet = data.currentView.findMagnet(target);\n\n          if (data.currentMagnet && (_this$graph$hook = this.graph.hook).validateConnection.apply(_this$graph$hook, _toConsumableArray(data.getValidateConnectionArgs(data.currentView, data.currentMagnet)).concat([data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType)]))) {\n            data.currentView.highlight(data.currentMagnet, {\n              type: 'magnetAdsorbed'\n            });\n          } else {\n            // This type of connection is not valid. Disregard this magnet.\n            data.currentMagnet = null;\n          }\n        } else {\n          // Make sure we'll unset previous magnet.\n          data.currentMagnet = null;\n        }\n      }\n\n      data.currentTarget = target;\n      this.cell.prop(data.terminalType, {\n        x: x,\n        y: y\n      }, Object.assign(Object.assign({}, data.options), {\n        ui: true\n      }));\n    }\n  }, {\n    key: \"arrowheadDragged\",\n    value: function arrowheadDragged(data, x, y) {\n      var view = data.currentView;\n      var magnet = data.currentMagnet;\n\n      if (!magnet || !view) {\n        return;\n      }\n\n      view.unhighlight(magnet, {\n        type: 'magnetAdsorbed'\n      });\n      var type = data.terminalType;\n      var terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);\n      this.cell.setTerminal(type, terminal, {\n        ui: true\n      });\n    }\n  }, {\n    key: \"snapArrowhead\",\n    value: function snapArrowhead(x, y, data) {\n      var _this4 = this;\n\n      var graph = this.graph;\n      var snap = graph.options.connecting.snap;\n      var radius = typeof snap === 'object' && snap.radius || 50;\n      var views = graph.renderer.findViewsInArea({\n        x: x - radius,\n        y: y - radius,\n        width: 2 * radius,\n        height: 2 * radius\n      });\n      var prevView = data.closestView || null;\n      var prevMagnet = data.closestMagnet || null;\n      data.closestView = null;\n      data.closestMagnet = null;\n      var distance;\n      var minDistance = Number.MAX_SAFE_INTEGER;\n      var pos = new Point(x, y);\n      views.forEach(function (view) {\n        if (view.container.getAttribute('magnet') !== 'false') {\n          // Find distance from the center of the cell to pointer coordinates\n          distance = view.cell.getBBox().getCenter().distance(pos); // the connection is looked up in a circle area by `distance < r`\n\n          if (distance < radius && distance < minDistance) {\n            var _graph$hook;\n\n            if (prevMagnet === view.container || (_graph$hook = graph.hook).validateConnection.apply(_graph$hook, _toConsumableArray(data.getValidateConnectionArgs(view, null)).concat([view.getEdgeTerminal(view.container, x, y, _this4.cell, data.terminalType)]))) {\n              minDistance = distance;\n              data.closestView = view;\n              data.closestMagnet = view.container;\n            }\n          }\n        }\n\n        view.container.querySelectorAll('[magnet]').forEach(function (magnet) {\n          if (magnet.getAttribute('magnet') !== 'false') {\n            var bbox = view.getBBoxOfElement(magnet);\n            distance = pos.distance(bbox.getCenter());\n\n            if (distance < radius && distance < minDistance) {\n              var _graph$hook2;\n\n              if (prevMagnet === magnet || (_graph$hook2 = graph.hook).validateConnection.apply(_graph$hook2, _toConsumableArray(data.getValidateConnectionArgs(view, magnet)).concat([view.getEdgeTerminal(magnet, x, y, _this4.cell, data.terminalType)]))) {\n                minDistance = distance;\n                data.closestView = view;\n                data.closestMagnet = magnet;\n              }\n            }\n          }\n        });\n      });\n      var terminal;\n      var type = data.terminalType;\n      var closestView = data.closestView;\n      var closestMagnet = data.closestMagnet;\n      var changed = prevMagnet !== closestMagnet;\n\n      if (prevView && changed) {\n        prevView.unhighlight(prevMagnet, {\n          type: 'magnetAdsorbed'\n        });\n      }\n\n      if (closestView) {\n        if (!changed) {\n          return;\n        }\n\n        closestView.highlight(closestMagnet, {\n          type: 'magnetAdsorbed'\n        });\n        terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);\n      } else {\n        terminal = {\n          x: x,\n          y: y\n        };\n      }\n\n      this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), {\n        ui: true\n      }));\n    }\n  }, {\n    key: \"snapArrowheadEnd\",\n    value: function snapArrowheadEnd(data) {\n      // Finish off link snapping.\n      // Everything except view unhighlighting was already done on pointermove.\n      var closestView = data.closestView;\n      var closestMagnet = data.closestMagnet;\n\n      if (closestView && closestMagnet) {\n        closestView.unhighlight(closestMagnet, {\n          type: 'magnetAdsorbed'\n        });\n        data.currentMagnet = closestView.findMagnet(closestMagnet);\n      }\n\n      data.closestView = null;\n      data.closestMagnet = null;\n    }\n  }, {\n    key: \"finishEmbedding\",\n    value: function finishEmbedding(data) {\n      // Resets parent of the edge if embedding is enabled\n      if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n        // Make sure we don't reverse to the original 'z' index\n        data.zIndex = null;\n      }\n    }\n  }, {\n    key: \"fallbackConnection\",\n    value: function fallbackConnection(data) {\n      switch (data.fallbackAction) {\n        case 'remove':\n          this.cell.remove({\n            ui: true\n          });\n          break;\n\n        case 'revert':\n        default:\n          this.cell.prop(data.terminalType, data.initialTerminal, {\n            ui: true\n          });\n          break;\n      }\n    }\n  }, {\n    key: \"notifyConnectionEvent\",\n    value: function notifyConnectionEvent(data, e) {\n      var terminalType = data.terminalType;\n      var initialTerminal = data.initialTerminal;\n      var currentTerminal = this.cell[terminalType];\n      var changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);\n\n      if (changed) {\n        var graph = this.graph;\n        var previous = initialTerminal;\n        var previousCell = previous.cell ? graph.getCellById(previous.cell) : null;\n        var previousPort = previous.port;\n        var previousView = previousCell ? graph.findViewByCell(previousCell) : null;\n        var previousPoint = previousCell || data.isNewEdge ? null : Point.create(initialTerminal).toJSON();\n        var current = currentTerminal;\n        var currentCell = current.cell ? graph.getCellById(current.cell) : null;\n        var currentPort = current.port;\n        var currentView = currentCell ? graph.findViewByCell(currentCell) : null;\n        var currentPoint = currentCell ? null : Point.create(currentTerminal).toJSON();\n        this.notify('edge:connected', {\n          e: e,\n          previousCell: previousCell,\n          previousPort: previousPort,\n          previousView: previousView,\n          previousPoint: previousPoint,\n          currentCell: currentCell,\n          currentView: currentView,\n          currentPort: currentPort,\n          currentPoint: currentPoint,\n          previousMagnet: data.initialMagnet,\n          currentMagnet: data.currentMagnet,\n          edge: this.cell,\n          view: this,\n          type: terminalType,\n          isNew: data.isNewEdge\n        });\n      }\n    }\n  }, {\n    key: \"highlightAvailableMagnets\",\n    value: function highlightAvailableMagnets(data) {\n      var _this5 = this;\n\n      var graph = this.graph;\n      var cells = graph.model.getCells();\n      data.marked = {};\n\n      var _loop = function _loop(i, ii) {\n        var view = graph.renderer.findViewByCell(cells[i]);\n\n        if (!view) {\n          return \"continue\";\n        }\n\n        var magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));\n\n        if (view.container.getAttribute('magnet') !== 'false') {\n          magnets.push(view.container);\n        }\n\n        var availableMagnets = magnets.filter(function (magnet) {\n          var _graph$hook3;\n\n          return (_graph$hook3 = graph.hook).validateConnection.apply(_graph$hook3, _toConsumableArray(data.getValidateConnectionArgs(view, magnet)).concat([view.getEdgeTerminal(magnet, data.x, data.y, _this5.cell, data.terminalType)]));\n        });\n\n        if (availableMagnets.length > 0) {\n          // highlight all available magnets\n          for (var j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n            view.highlight(availableMagnets[j], {\n              type: 'magnetAvailable'\n            });\n          } // highlight the entire view\n\n\n          view.highlight(null, {\n            type: 'nodeAvailable'\n          });\n          data.marked[view.cell.id] = availableMagnets;\n        }\n      };\n\n      for (var i = 0, ii = cells.length; i < ii; i += 1) {\n        var _ret = _loop(i, ii);\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  }, {\n    key: \"unhighlightAvailableMagnets\",\n    value: function unhighlightAvailableMagnets(data) {\n      var _this6 = this;\n\n      var marked = data.marked || {};\n      Object.keys(marked).forEach(function (id) {\n        var view = _this6.graph.renderer.findViewByCell(id);\n\n        if (view) {\n          var magnets = marked[id];\n          magnets.forEach(function (magnet) {\n            view.unhighlight(magnet, {\n              type: 'magnetAvailable'\n            });\n          });\n          view.unhighlight(null, {\n            type: 'nodeAvailable'\n          });\n        }\n      });\n      data.marked = null;\n    }\n  }, {\n    key: \"startArrowheadDragging\",\n    value: function startArrowheadDragging(e, x, y) {\n      if (!this.can('arrowheadMovable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      }\n\n      var elem = e.target;\n      var type = elem.getAttribute('data-terminal');\n      var data = this.prepareArrowheadDragging(type, {\n        x: x,\n        y: y\n      });\n      this.setEventData(e, data);\n    }\n  }, {\n    key: \"dragArrowhead\",\n    value: function dragArrowhead(e, x, y) {\n      var data = this.getEventData(e);\n\n      if (this.graph.options.connecting.snap) {\n        this.snapArrowhead(x, y, data);\n      } else {\n        this.arrowheadDragging(this.getEventTarget(e), x, y, data);\n      }\n    }\n  }, {\n    key: \"stopArrowheadDragging\",\n    value: function stopArrowheadDragging(e, x, y) {\n      var graph = this.graph;\n      var data = this.getEventData(e);\n\n      if (graph.options.connecting.snap) {\n        this.snapArrowheadEnd(data);\n      } else {\n        this.arrowheadDragged(data, x, y);\n      }\n\n      var valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);\n\n      if (valid) {\n        this.finishEmbedding(data);\n        this.notifyConnectionEvent(data, e);\n      } else {\n        // If the changed edge is not allowed, revert to its previous state.\n        this.fallbackConnection(data);\n      }\n\n      this.afterArrowheadDragging(data);\n    } // #endregion\n    // #region drag lable\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"startLabelDragging\",\n    value: function startLabelDragging(e, x, y) {\n      if (this.can('edgeLabelMovable')) {\n        var target = e.currentTarget;\n        var index = parseInt(target.getAttribute('data-index'), 10);\n        var positionAngle = this.getLabelPositionAngle(index);\n        var labelPositionArgs = this.getLabelPositionArgs(index);\n        var defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n        var positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n        this.setEventData(e, {\n          index: index,\n          positionAngle: positionAngle,\n          positionArgs: positionArgs,\n          stopPropagation: true,\n          action: 'drag-label'\n        });\n      } else {\n        // If labels can't be dragged no default action is triggered.\n        this.setEventData(e, {\n          stopPropagation: true\n        });\n      }\n\n      this.graph.view.delegateDragEvents(e, this);\n    }\n  }, {\n    key: \"dragLabel\",\n    value: function dragLabel(e, x, y) {\n      var data = this.getEventData(e);\n      var originLabel = this.cell.getLabelAt(data.index);\n      var label = ObjectExt.merge({}, originLabel, {\n        position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)\n      });\n      this.cell.setLabelAt(data.index, label);\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"stopLabelDragging\",\n    value: function stopLabelDragging(e, x, y) {} // #endregion\n    // #region drag vertex\n\n  }, {\n    key: \"handleVertexAdding\",\n    value: function handleVertexAdding(e, x, y) {\n      if (!this.can('vertexAddable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      } // Store the index at which the new vertex has just been placed.\n      // We'll be update the very same vertex position in `pointermove()`.\n\n\n      var index = this.addVertex({\n        x: x,\n        y: y\n      }, {\n        ui: true\n      });\n      this.setEventData(e, {\n        index: index,\n        action: 'drag-vertex'\n      });\n    }\n  }, {\n    key: \"handleVertexRemoving\",\n    value: function handleVertexRemoving(e, x, y) {\n      if (!this.can('vertexDeletable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      }\n\n      var target = e.target;\n      var index = parseInt(target.getAttribute('idx'), 10);\n      this.cell.removeVertexAt(index);\n    }\n  }, {\n    key: \"startVertexDragging\",\n    value: function startVertexDragging(e, x, y) {\n      if (!this.can('vertexMovable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      }\n\n      var target = e.target;\n      var index = parseInt(target.getAttribute('idx'), 10);\n      this.setEventData(e, {\n        index: index,\n        action: 'drag-vertex'\n      });\n    }\n  }, {\n    key: \"dragVertex\",\n    value: function dragVertex(e, x, y) {\n      var data = this.getEventData(e);\n      this.cell.setVertexAt(data.index, {\n        x: x,\n        y: y\n      }, {\n        ui: true\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"stopVertexDragging\",\n    value: function stopVertexDragging(e, x, y) {}\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return EdgeView.toStringTag;\n    }\n  }, {\n    key: \"sourceBBox\",\n    get: function get() {\n      var sourceView = this.sourceView;\n\n      if (!sourceView) {\n        var sourceDef = this.cell.getSource();\n        return new Rectangle(sourceDef.x, sourceDef.y);\n      }\n\n      var sourceMagnet = this.sourceMagnet;\n\n      if (sourceView.isEdgeElement(sourceMagnet)) {\n        return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);\n      }\n\n      return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);\n    }\n  }, {\n    key: \"targetBBox\",\n    get: function get() {\n      var targetView = this.targetView;\n\n      if (!targetView) {\n        var targetDef = this.cell.getTarget();\n        return new Rectangle(targetDef.x, targetDef.y);\n      }\n\n      var targetMagnet = this.targetMagnet;\n\n      if (targetView.isEdgeElement(targetMagnet)) {\n        return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);\n      }\n\n      return targetView.getBBoxOfElement(targetMagnet || targetView.container);\n    }\n  }]);\n\n  return EdgeView;\n}(CellView);\n\n(function (EdgeView) {\n  EdgeView.toStringTag = \"X6.\".concat(EdgeView.name);\n\n  function isEdgeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof EdgeView) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var view = instance;\n\n    if ((tag == null || tag === EdgeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.getConnection === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  EdgeView.isEdgeView = isEdgeView;\n})(EdgeView || (EdgeView = {}));\n\nEdgeView.config({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    vertices: ['vertices', 'update'],\n    vertexMarkup: ['vertices'],\n    toolMarkup: ['tools'],\n    tools: ['widget']\n  },\n  shortLength: 105,\n  longLength: 155,\n  toolsOffset: 40,\n  doubleTools: false,\n  doubleToolsOffset: 65,\n  sampleInterval: 50\n});\nEdgeView.registry.register('edge', EdgeView, true);","map":null,"metadata":{},"sourceType":"module"}