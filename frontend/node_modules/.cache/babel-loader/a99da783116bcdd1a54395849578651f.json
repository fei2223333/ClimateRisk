{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { ArrayExt } from '../util';\nimport { Basecoat } from '../common';\nexport var Collection = /*#__PURE__*/function (_Basecoat) {\n  _inherits(Collection, _Basecoat);\n\n  function Collection(cells) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Collection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this));\n    _this.length = 0;\n    _this.comparator = options.comparator || 'zIndex';\n\n    _this.clean();\n\n    if (cells) {\n      _this.reset(cells, {\n        silent: true\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.cells.map(function (cell) {\n        return cell.toJSON();\n      });\n    }\n  }, {\n    key: \"add\",\n    value: function add(cells, index, options) {\n      var _this2 = this;\n\n      var localIndex;\n      var localOptions;\n\n      if (typeof index === 'number') {\n        localIndex = index;\n        localOptions = Object.assign({\n          merge: false\n        }, options);\n      } else {\n        localIndex = this.length;\n        localOptions = Object.assign({\n          merge: false\n        }, index);\n      }\n\n      if (localIndex > this.length) {\n        localIndex = this.length;\n      }\n\n      if (localIndex < 0) {\n        localIndex += this.length + 1;\n      }\n\n      var entities = Array.isArray(cells) ? cells : [cells];\n      var sortable = this.comparator && typeof index !== 'number' && localOptions.sort !== false;\n      var sortAttr = this.comparator || null;\n      var sort = false;\n      var added = [];\n      var merged = [];\n      entities.forEach(function (cell) {\n        var existing = _this2.get(cell);\n\n        if (existing) {\n          if (localOptions.merge && !cell.isSameStore(existing)) {\n            existing.setProp(cell.getProp(), options); // merge\n\n            merged.push(existing);\n\n            if (sortable && !sort) {\n              if (sortAttr == null || typeof sortAttr === 'function') {\n                sort = existing.hasChanged();\n              } else if (typeof sortAttr === 'string') {\n                sort = existing.hasChanged(sortAttr);\n              } else {\n                sort = sortAttr.some(function (key) {\n                  return existing.hasChanged(key);\n                });\n              }\n            }\n          }\n        } else {\n          added.push(cell);\n\n          _this2.reference(cell);\n        }\n      });\n\n      if (added.length) {\n        var _this$cells;\n\n        if (sortable) {\n          sort = true;\n        }\n\n        (_this$cells = this.cells).splice.apply(_this$cells, [localIndex, 0].concat(added));\n\n        this.length = this.cells.length;\n      }\n\n      if (sort) {\n        this.sort({\n          silent: true\n        });\n      }\n\n      if (!localOptions.silent) {\n        added.forEach(function (cell, i) {\n          var args = {\n            cell: cell,\n            index: localIndex + i,\n            options: localOptions\n          };\n\n          _this2.trigger('added', args);\n\n          if (!localOptions.dryrun) {\n            cell.notify('added', Object.assign({}, args));\n          }\n        });\n\n        if (sort) {\n          this.trigger('sorted');\n        }\n\n        if (added.length || merged.length) {\n          this.trigger('updated', {\n            added: added,\n            merged: merged,\n            removed: [],\n            options: localOptions\n          });\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var arr = Array.isArray(cells) ? cells : [cells];\n      var removed = this.removeCells(arr, options);\n\n      if (!options.silent && removed.length > 0) {\n        this.trigger('updated', {\n          options: options,\n          removed: removed,\n          added: [],\n          merged: []\n        });\n      }\n\n      return Array.isArray(cells) ? removed : removed[0];\n    }\n  }, {\n    key: \"removeCells\",\n    value: function removeCells(cells, options) {\n      var removed = [];\n\n      for (var i = 0; i < cells.length; i += 1) {\n        var cell = this.get(cells[i]);\n\n        if (cell == null) {\n          continue;\n        }\n\n        var index = this.cells.indexOf(cell);\n        this.cells.splice(index, 1);\n        this.length -= 1;\n        delete this.map[cell.id];\n        removed.push(cell);\n        this.unreference(cell);\n\n        if (!options.dryrun) {\n          cell.remove();\n        }\n\n        if (!options.silent) {\n          this.trigger('removed', {\n            cell: cell,\n            index: index,\n            options: options\n          });\n\n          if (!options.dryrun) {\n            cell.notify('removed', {\n              cell: cell,\n              index: index,\n              options: options\n            });\n          }\n        }\n      }\n\n      return removed;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(cells) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var previous = this.cells.slice();\n      previous.forEach(function (cell) {\n        return _this3.unreference(cell);\n      });\n      this.clean();\n      this.add(cells, Object.assign({\n        silent: true\n      }, options));\n\n      if (!options.silent) {\n        var current = this.cells.slice();\n        this.trigger('reseted', {\n          options: options,\n          previous: previous,\n          current: current\n        });\n        var added = [];\n        var removed = [];\n        current.forEach(function (a) {\n          var exist = previous.some(function (b) {\n            return b.id === a.id;\n          });\n\n          if (!exist) {\n            added.push(a);\n          }\n        });\n        previous.forEach(function (a) {\n          var exist = current.some(function (b) {\n            return b.id === a.id;\n          });\n\n          if (!exist) {\n            removed.push(a);\n          }\n        });\n        this.trigger('updated', {\n          options: options,\n          added: added,\n          removed: removed,\n          merged: []\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"push\",\n    value: function push(cell, options) {\n      return this.add(cell, this.length, options);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(options) {\n      var cell = this.at(this.length - 1);\n      return this.remove(cell, options);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(cell, options) {\n      return this.add(cell, 0, options);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift(options) {\n      var cell = this.at(0);\n      return this.remove(cell, options);\n    }\n  }, {\n    key: \"get\",\n    value: function get(cell) {\n      if (cell == null) {\n        return null;\n      }\n\n      var id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;\n      return this.map[id] || null;\n    }\n  }, {\n    key: \"has\",\n    value: function has(cell) {\n      return this.get(cell) != null;\n    }\n  }, {\n    key: \"at\",\n    value: function at(index) {\n      if (index < 0) {\n        index += this.length; // eslint-disable-line\n      }\n\n      return this.cells[index] || null;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.at(0);\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.at(-1);\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(cell) {\n      return this.cells.indexOf(cell);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return this.cells.slice();\n    }\n  }, {\n    key: \"sort\",\n    value: function sort() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.comparator != null) {\n        this.cells = ArrayExt.sortBy(this.cells, this.comparator);\n\n        if (!options.silent) {\n          this.trigger('sorted');\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var constructor = this.constructor;\n      return new constructor(this.cells.slice(), {\n        comparator: this.comparator\n      });\n    }\n  }, {\n    key: \"reference\",\n    value: function reference(cell) {\n      this.map[cell.id] = cell;\n      cell.on('*', this.notifyCellEvent, this);\n    }\n  }, {\n    key: \"unreference\",\n    value: function unreference(cell) {\n      cell.off('*', this.notifyCellEvent, this);\n      delete this.map[cell.id];\n    }\n  }, {\n    key: \"notifyCellEvent\",\n    value: function notifyCellEvent(name, args) {\n      var cell = args.cell;\n      this.trigger(\"cell:\".concat(name), args);\n\n      if (cell) {\n        if (cell.isNode()) {\n          this.trigger(\"node:\".concat(name), Object.assign(Object.assign({}, args), {\n            node: cell\n          }));\n        } else if (cell.isEdge()) {\n          this.trigger(\"edge:\".concat(name), Object.assign(Object.assign({}, args), {\n            edge: cell\n          }));\n        }\n      }\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this.length = 0;\n      this.cells = [];\n      this.map = {};\n    }\n  }]);\n\n  return Collection;\n}(Basecoat);","map":null,"metadata":{},"sourceType":"module"}