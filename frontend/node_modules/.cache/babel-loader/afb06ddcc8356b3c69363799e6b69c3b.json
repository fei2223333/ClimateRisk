{"ast":null,"code":"import util from './util';\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\n\nvar run = function run(g) {\n  g.graph().dummyChains = [];\n  g.edges().forEach(function (edge) {\n    return normalizeEdge(g, edge);\n  });\n};\n\nvar normalizeEdge = function normalizeEdge(g, e) {\n  var _a, _b;\n\n  var v = e.v;\n  var vRank = g.node(v).rank;\n  var w = e.w;\n  var wRank = g.node(w).rank;\n  var name = e.name;\n  var edgeLabel = g.edge(e);\n  var labelRank = edgeLabel.labelRank;\n  if (wRank === vRank + 1) return;\n  g.removeEdge(e);\n  var dummy;\n  var attrs;\n  var i;\n\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      edgeLabel: edgeLabel,\n      width: 0,\n      height: 0,\n      edgeObj: e,\n      rank: vRank\n    };\n    dummy = util.addDummyNode(g, \"edge\", attrs, \"_d\");\n\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = \"edge-label\";\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n\n    g.setEdge(v, dummy, {\n      weight: edgeLabel.weight\n    }, name);\n\n    if (i === 0) {\n      if (!g.graph().dummyChains) g.graph().dummyChains = [];\n      (_b = (_a = g.graph()) === null || _a === void 0 ? void 0 : _a.dummyChains) === null || _b === void 0 ? void 0 : _b.push(dummy);\n    }\n\n    v = dummy;\n  }\n\n  g.setEdge(v, w, {\n    weight: edgeLabel.weight\n  }, name);\n};\n\nvar undo = function undo(g) {\n  var _a;\n\n  (_a = g.graph().dummyChains) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n    var _a;\n\n    var node = g.node(v);\n    var origLabel = node.edgeLabel;\n    var w;\n    node.edgeObj && g.setEdge(node.edgeObj, origLabel);\n    var currentV = v;\n\n    while (node.dummy) {\n      w = (_a = g.successors(currentV)) === null || _a === void 0 ? void 0 : _a[0];\n      g.removeNode(currentV);\n      origLabel.points.push({\n        x: node.x,\n        y: node.y\n      });\n\n      if (node.dummy === \"edge-label\") {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n\n      currentV = w;\n      node = g.node(currentV);\n    }\n  });\n};\n\nexport default {\n  run: run,\n  undo: undo\n};","map":null,"metadata":{},"sourceType":"module"}