{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { isString, isArray, isNumber, getDegree, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 同心圆布局\n */\n\nexport var ConcentricLayout = /*#__PURE__*/function (_Base) {\n  _inherits(ConcentricLayout, _Base);\n\n  function ConcentricLayout(options) {\n    var _this;\n\n    _classCallCheck(this, ConcentricLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConcentricLayout).call(this));\n    _this.nodeSize = 30;\n    /** min spacing between outside of nodes (used for radius adjustment) */\n\n    _this.minNodeSpacing = 10;\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = false;\n    /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n\n    _this.equidistant = false;\n    /** where nodes start in radians */\n\n    _this.startAngle = 3 / 2 * Math.PI;\n    /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n\n    _this.clockwise = true;\n    /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n\n    _this.sortBy = \"degree\";\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(ConcentricLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        nodeSize: 30,\n        minNodeSpacing: 10,\n        preventOverlap: false,\n        sweep: undefined,\n        equidistant: false,\n        startAngle: 3 / 2 * Math.PI,\n        clockwise: true,\n        maxLevelDiff: undefined,\n        sortBy: \"degree\"\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges;\n      var n = nodes.length;\n\n      if (n === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      var center = self.center;\n\n      if (n === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      var layoutNodes = [];\n      var maxNodeSize;\n\n      if (isArray(self.nodeSize)) {\n        maxNodeSize = Math.max(self.nodeSize[0], self.nodeSize[1]);\n      } else {\n        maxNodeSize = self.nodeSize;\n      }\n\n      nodes.forEach(function (node) {\n        layoutNodes.push(node);\n        var nodeSize = maxNodeSize;\n\n        if (isArray(node.size)) {\n          nodeSize = Math.max(node.size[0], node.size[1]);\n        } else if (isNumber(node.size)) {\n          nodeSize = node.size;\n        } else if (isObject(node.size)) {\n          nodeSize = Math.max(node.size.width, node.size.height);\n        }\n\n        maxNodeSize = Math.max(maxNodeSize, nodeSize);\n      });\n      self.clockwise = self.counterclockwise !== undefined ? !self.counterclockwise : self.clockwise; // layout\n\n      var nodeMap = {};\n      var indexMap = {};\n      layoutNodes.forEach(function (node, i) {\n        nodeMap[node.id] = node;\n        indexMap[node.id] = i;\n      }); // get the node degrees\n\n      if (self.sortBy === \"degree\" || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n        self.sortBy = \"degree\";\n\n        if (!isNumber(nodes[0].degree)) {\n          var values = getDegree(nodes.length, indexMap, edges);\n          layoutNodes.forEach(function (node, i) {\n            node.degree = values[i];\n          });\n        }\n      } // sort nodes by value\n\n\n      layoutNodes.sort(function (n1, n2) {\n        return n2[self.sortBy] - n1[self.sortBy];\n      });\n      self.maxValueNode = layoutNodes[0];\n      self.maxLevelDiff = self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4; // put the values into levels\n\n      var levels = [[]];\n      var currentLevel = levels[0];\n      layoutNodes.forEach(function (node) {\n        if (currentLevel.length > 0) {\n          var diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n\n          if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n            currentLevel = [];\n            levels.push(currentLevel);\n          }\n        }\n\n        currentLevel.push(node);\n      }); // create positions for levels\n\n      var minDist = maxNodeSize + self.minNodeSpacing; // min dist between nodes\n\n      if (!self.preventOverlap) {\n        // then strictly constrain to bb\n        var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n        var maxR = Math.min(self.width, self.height) / 2 - minDist;\n        var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n        minDist = Math.min(minDist, rStep);\n      } // find the metrics for each level\n\n\n      var r = 0;\n      levels.forEach(function (level) {\n        var sweep = self.sweep;\n\n        if (sweep === undefined) {\n          sweep = 2 * Math.PI - 2 * Math.PI / level.length;\n        }\n\n        var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n        if (level.length > 1 && self.preventOverlap) {\n          // but only if more than one node (can't overlap)\n          var dcos = Math.cos(dTheta) - Math.cos(0);\n          var dsin = Math.sin(dTheta) - Math.sin(0);\n          var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n          r = Math.max(rMin, r);\n        }\n\n        level.r = r;\n        r += minDist;\n      });\n\n      if (self.equidistant) {\n        var rDeltaMax = 0;\n        var rr = 0;\n\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var rDelta = level.r - rr;\n          rDeltaMax = Math.max(rDeltaMax, rDelta);\n        }\n\n        rr = 0;\n        levels.forEach(function (level, i) {\n          if (i === 0) {\n            rr = level.r;\n          }\n\n          level.r = rr;\n          rr += rDeltaMax;\n        });\n      } // calculate the node positions\n\n\n      levels.forEach(function (level) {\n        var dTheta = level.dTheta;\n        var rr = level.r;\n        level.forEach(function (node, j) {\n          var theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n          node.x = center[0] + rr * Math.cos(theta);\n          node.y = center[1] + rr * Math.sin(theta);\n        });\n      });\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"concentric\";\n    }\n  }]);\n\n  return ConcentricLayout;\n}(Base);","map":null,"metadata":{},"sourceType":"module"}