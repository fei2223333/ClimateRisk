{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { clamp, squaredLength } from '../util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nimport * as Util from './util';\nexport var Path = /*#__PURE__*/function (_Geometry) {\n  _inherits(Path, _Geometry);\n\n  function Path(args) {\n    var _this;\n\n    _classCallCheck(this, Path);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this));\n    _this.PRECISION = 3;\n    _this.segments = [];\n\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        var previousObj = null;\n        var arr = args;\n        arr.forEach(function (o, i) {\n          if (i === 0) {\n            _this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            _this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (Line.isLine(o)) {\n            _this.appendSegment(Path.createSegment('L', o.end));\n          } else if (Curve.isCurve(o)) {\n            _this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n          }\n\n          previousObj = o;\n        });\n      } else {\n        var _arr = args;\n\n        _arr.forEach(function (s) {\n          if (s.isSegment) {\n            _this.appendSegment(s);\n          }\n        });\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        _this.appendSegment(Path.createSegment('M', args.start));\n\n        _this.appendSegment(Path.createSegment('L', args.end));\n      } else if (Curve.isCurve(args)) {\n        _this.appendSegment(Path.createSegment('M', args.start));\n\n        _this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach(function (point, index) {\n            var segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);\n\n            _this.appendSegment(segment);\n          });\n        }\n      } else if (args.isSegment) {\n        _this.appendSegment(args);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(Path, [{\n    key: \"moveTo\",\n    value: function moveTo() {\n      var _MoveTo$create;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.appendSegment((_MoveTo$create = MoveTo.create).call.apply(_MoveTo$create, [null].concat(args)));\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo() {\n      var _LineTo$create;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.appendSegment((_LineTo$create = LineTo.create).call.apply(_LineTo$create, [null].concat(args)));\n    }\n  }, {\n    key: \"curveTo\",\n    value: function curveTo() {\n      var _CurveTo$create;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.appendSegment((_CurveTo$create = CurveTo.create).call.apply(_CurveTo$create, [null].concat(args)));\n    }\n  }, {\n    key: \"arcTo\",\n    value: function arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n      var start = this.end || new Point();\n      var points = typeof endX === 'number' ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n\n      if (points != null) {\n        for (var i = 0, ii = points.length; i < ii; i += 6) {\n          this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"quadTo\",\n    value: function quadTo(x1, y1, x, y) {\n      var start = this.end || new Point();\n      var data = ['M', start.x, start.y];\n\n      if (typeof x1 === 'number') {\n        data.push('Q', x1, y1, x, y);\n      } else {\n        var p = y1;\n        data.push(\"Q\", x1.x, x1.y, p.x, p.y);\n      }\n\n      var path = Path.parse(data.join(' '));\n      this.appendSegment(path.segments.slice(1));\n      return this;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return this.appendSegment(Close.create());\n    }\n  }, {\n    key: \"drawPoints\",\n    value: function drawPoints(points) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var raw = Util.drawPoints(points, options);\n      var sub = Path.parse(raw);\n\n      if (sub && sub.segments) {\n        this.appendSegment(sub.segments);\n      }\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var segments = this.segments;\n      var count = segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      var bbox;\n\n      for (var i = 0; i < count; i += 1) {\n        var segment = segments[i];\n\n        if (segment.isVisible) {\n          var segmentBBox = segment.bbox();\n\n          if (segmentBBox != null) {\n            bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n          }\n        }\n      }\n\n      if (bbox != null) {\n        return bbox;\n      } // if the path has only invisible elements, return end point of last segment\n\n\n      var lastSegment = segments[count - 1];\n      return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    }\n  }, {\n    key: \"appendSegment\",\n    value: function appendSegment(seg) {\n      var count = this.segments.length;\n      var previousSegment = count !== 0 ? this.segments[count - 1] : null;\n      var currentSegment;\n      var nextSegment = null;\n\n      if (Array.isArray(seg)) {\n        for (var i = 0, ii = seg.length; i < ii; i += 1) {\n          var segment = seg[i];\n          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n          this.segments.push(currentSegment);\n          previousSegment = currentSegment;\n        }\n      } else if (seg != null && seg.isSegment) {\n        currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n        this.segments.push(currentSegment);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"insertSegment\",\n    value: function insertSegment(index, seg) {\n      var count = this.segments.length;\n\n      if (index < 0) {\n        index = count + index + 1; // eslint-disable-line\n      }\n\n      if (index > count || index < 0) {\n        throw new Error('Index out of range.');\n      }\n\n      var currentSegment;\n      var previousSegment = null;\n      var nextSegment = null;\n\n      if (count !== 0) {\n        if (index >= 1) {\n          previousSegment = this.segments[index - 1];\n          nextSegment = previousSegment.nextSegment;\n        } else {\n          previousSegment = null;\n          nextSegment = this.segments[0];\n        }\n      }\n\n      if (!Array.isArray(seg)) {\n        currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n        this.segments.splice(index, 0, currentSegment);\n      } else {\n        for (var i = 0, ii = seg.length; i < ii; i += 1) {\n          var segment = seg[i];\n          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n          this.segments.splice(index + i, 0, currentSegment);\n          previousSegment = currentSegment;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeSegment\",\n    value: function removeSegment(index) {\n      var idx = this.fixIndex(index);\n      var removedSegment = this.segments.splice(idx, 1)[0];\n      var previousSegment = removedSegment.previousSegment;\n      var nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)\n\n      if (previousSegment) {\n        previousSegment.nextSegment = nextSegment;\n      }\n\n      if (nextSegment) {\n        nextSegment.previousSegment = previousSegment;\n      }\n\n      if (removedSegment.isSubpathStart && nextSegment) {\n        this.updateSubpathStartSegment(nextSegment);\n      }\n\n      return removedSegment;\n    }\n  }, {\n    key: \"replaceSegment\",\n    value: function replaceSegment(index, seg) {\n      var idx = this.fixIndex(index);\n      var currentSegment;\n      var replacedSegment = this.segments[idx];\n      var previousSegment = replacedSegment.previousSegment;\n      var nextSegment = replacedSegment.nextSegment;\n      var updateSubpathStart = replacedSegment.isSubpathStart;\n\n      if (!Array.isArray(seg)) {\n        currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n        this.segments.splice(idx, 1, currentSegment);\n\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          // already updated by `prepareSegment`\n          updateSubpathStart = false;\n        }\n      } else {\n        this.segments.splice(index, 1);\n\n        for (var i = 0, ii = seg.length; i < ii; i += 1) {\n          var segment = seg[i];\n          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n          this.segments.splice(index + i, 0, currentSegment);\n          previousSegment = currentSegment;\n\n          if (updateSubpathStart && currentSegment.isSubpathStart) {\n            updateSubpathStart = false;\n          }\n        }\n      }\n\n      if (updateSubpathStart && nextSegment) {\n        this.updateSubpathStartSegment(nextSegment);\n      }\n    }\n  }, {\n    key: \"getSegment\",\n    value: function getSegment(index) {\n      var idx = this.fixIndex(index);\n      return this.segments[idx];\n    }\n  }, {\n    key: \"fixIndex\",\n    value: function fixIndex(index) {\n      var length = this.segments.length;\n\n      if (length === 0) {\n        throw new Error('Path has no segments.');\n      }\n\n      var i = index;\n\n      while (i < 0) {\n        i = length + i;\n      }\n\n      if (i >= length || i < 0) {\n        throw new Error('Index out of range.');\n      }\n\n      return i;\n    }\n  }, {\n    key: \"segmentAt\",\n    value: function segmentAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = this.segmentIndexAt(ratio, options);\n\n      if (!index) {\n        return null;\n      }\n\n      return this.getSegment(index);\n    }\n  }, {\n    key: \"segmentAtLength\",\n    value: function segmentAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = this.segmentIndexAtLength(length, options);\n      if (!index) return null;\n      return this.getSegment(index);\n    }\n  }, {\n    key: \"segmentIndexAt\",\n    value: function segmentIndexAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var rate = clamp(ratio, 0, 1);\n      var opt = this.getOptions(options);\n      var len = this.length(opt);\n      var length = len * rate;\n      return this.segmentIndexAtLength(length, opt);\n    }\n  }, {\n    key: \"segmentIndexAtLength\",\n    value: function segmentIndexAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var count = this.segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var memo = 0;\n      var lastVisibleIndex = null;\n\n      for (var i = 0; i < count; i += 1) {\n        var index = fromStart ? i : count - 1 - i;\n        var segment = this.segments[index];\n        var subdivisions = segmentSubdivisions[index];\n        var len = segment.length({\n          precision: precision,\n          subdivisions: subdivisions\n        });\n\n        if (segment.isVisible) {\n          if (length <= memo + len) {\n            return index;\n          }\n\n          lastVisibleIndex = index;\n        }\n\n        memo += len;\n      } // If length requested is higher than the length of the path, return\n      // last visible segment index. If no visible segment, return null.\n\n\n      return lastVisibleIndex;\n    }\n  }, {\n    key: \"getSegmentSubdivisions\",\n    value: function getSegmentSubdivisions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = [];\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n        var subdivisions = segment.getSubdivisions({\n          precision: precision\n        });\n        segmentSubdivisions.push(subdivisions);\n      }\n\n      return segmentSubdivisions;\n    }\n  }, {\n    key: \"updateSubpathStartSegment\",\n    value: function updateSubpathStartSegment(segment) {\n      var previous = segment.previousSegment;\n      var current = segment;\n\n      while (current && !current.isSubpathStart) {\n        // assign previous segment's subpath start segment to this segment\n        if (previous != null) {\n          current.subpathStartSegment = previous.subpathStartSegment;\n        } else {\n          current.subpathStartSegment = null;\n        }\n\n        previous = current;\n        current = current.nextSegment;\n      }\n    }\n  }, {\n    key: \"prepareSegment\",\n    value: function prepareSegment(segment, previousSegment, nextSegment) {\n      segment.previousSegment = previousSegment;\n      segment.nextSegment = nextSegment;\n\n      if (previousSegment != null) {\n        previousSegment.nextSegment = segment;\n      }\n\n      if (nextSegment != null) {\n        nextSegment.previousSegment = segment;\n      }\n\n      var updateSubpathStart = segment;\n\n      if (segment.isSubpathStart) {\n        // move to\n        segment.subpathStartSegment = segment;\n        updateSubpathStart = nextSegment;\n      } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\n\n      if (updateSubpathStart != null) {\n        this.updateSubpathStartSegment(updateSubpathStart);\n      }\n\n      return segment;\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var t = this.closestPointT(p, options);\n\n      if (!t) {\n        return null;\n      }\n\n      return this.pointAtT(t);\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var opts = this.getOptions(options);\n      var t = this.closestPointT(p, opts);\n\n      if (!t) {\n        return 0;\n      }\n\n      return this.lengthAtT(t, opts);\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var opts = this.getOptions(options);\n      var cpLength = this.closestPointLength(p, opts);\n\n      if (cpLength === 0) {\n        return 0;\n      }\n\n      var length = this.length(opts);\n\n      if (length === 0) {\n        return 0;\n      }\n\n      return cpLength / length;\n    }\n  }, {\n    key: \"closestPointT\",\n    value: function closestPointT(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var closestPointT;\n      var minSquaredDistance = Infinity;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n        var subdivisions = segmentSubdivisions[i];\n\n        if (segment.isVisible) {\n          var segmentClosestPointT = segment.closestPointT(p, {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n          var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n          var squaredDistance = squaredLength(segmentClosestPoint, p);\n\n          if (squaredDistance < minSquaredDistance) {\n            closestPointT = {\n              segmentIndex: i,\n              value: segmentClosestPointT\n            };\n            minSquaredDistance = squaredDistance;\n          }\n        }\n      }\n\n      if (closestPointT) {\n        return closestPointT;\n      }\n\n      return {\n        segmentIndex: this.segments.length - 1,\n        value: 1\n      };\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var closestPointTangent;\n      var minSquaredDistance = Infinity;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n        var subdivisions = segmentSubdivisions[i];\n\n        if (segment.isDifferentiable()) {\n          var segmentClosestPointT = segment.closestPointT(p, {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n          var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n          var squaredDistance = squaredLength(segmentClosestPoint, p);\n\n          if (squaredDistance < minSquaredDistance) {\n            closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n            minSquaredDistance = squaredDistance;\n          }\n        }\n      }\n\n      if (closestPointTangent) {\n        return closestPointTangent;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var polylines = this.toPolylines(options);\n\n      if (!polylines) {\n        return false;\n      }\n\n      var numIntersections = 0;\n\n      for (var i = 0, ii = polylines.length; i < ii; i += 1) {\n        var polyline = polylines[i];\n\n        if (polyline.containsPoint(p)) {\n          numIntersections += 1;\n        }\n      } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n      return numIntersections % 2 === 1;\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      if (ratio <= 0) {\n        return this.start.clone();\n      }\n\n      if (ratio >= 1) {\n        return this.end.clone();\n      }\n\n      var opts = this.getOptions(options);\n      var pathLength = this.length(opts);\n      var length = pathLength * ratio;\n      return this.pointAtLength(length, opts);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      if (length === 0) {\n        return this.start.clone();\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var lastVisibleSegment;\n      var memo = 0;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var index = fromStart ? i : ii - 1 - i;\n        var segment = this.segments[index];\n        var subdivisions = segmentSubdivisions[index];\n        var d = segment.length({\n          precision: precision,\n          subdivisions: subdivisions\n        });\n\n        if (segment.isVisible) {\n          if (length <= memo + d) {\n            return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n              precision: precision,\n              subdivisions: subdivisions\n            });\n          }\n\n          lastVisibleSegment = segment;\n        }\n\n        memo += d;\n      } // if length requested is higher than the length of the path,\n      // return last visible segment endpoint\n\n\n      if (lastVisibleSegment) {\n        return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n      } // if no visible segment, return last segment end point\n\n\n      var lastSegment = this.segments[this.segments.length - 1];\n      return lastSegment.end.clone();\n    }\n  }, {\n    key: \"pointAtT\",\n    value: function pointAtT(t) {\n      var segments = this.segments;\n      var numSegments = segments.length;\n      if (numSegments === 0) return null; // if segments is an empty array\n\n      var segmentIndex = t.segmentIndex;\n      if (segmentIndex < 0) return segments[0].pointAtT(0);\n\n      if (segmentIndex >= numSegments) {\n        return segments[numSegments - 1].pointAtT(1);\n      }\n\n      var tValue = clamp(t.value, 0, 1);\n      return segments[segmentIndex].pointAtT(tValue);\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var rate = clamp(ratio, 0, 1);\n      var opts = this.getOptions(options);\n      var len = this.length(opts);\n      var length = len * rate;\n      return this.divideAtLength(length, opts);\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var memo = 0;\n      var divided;\n      var dividedSegmentIndex;\n      var lastValidSegment;\n      var lastValidSegmentIndex;\n      var t;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var _index = fromStart ? i : ii - 1 - i;\n\n        var segment = this.getSegment(_index);\n        var subdivisions = segmentSubdivisions[_index];\n        var opts = {\n          precision: precision,\n          subdivisions: subdivisions\n        };\n        var len = segment.length(opts);\n\n        if (segment.isDifferentiable()) {\n          lastValidSegment = segment;\n          lastValidSegmentIndex = _index;\n\n          if (length <= memo + len) {\n            dividedSegmentIndex = _index;\n            divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n            break;\n          }\n        }\n\n        memo += len;\n      }\n\n      if (!lastValidSegment) {\n        return null;\n      }\n\n      if (!divided) {\n        dividedSegmentIndex = lastValidSegmentIndex;\n        t = fromStart ? 1 : 0;\n        divided = lastValidSegment.divideAtT(t);\n      } // create a copy of this path and replace the identified segment with its two divided parts:\n\n\n      var pathCopy = this.clone();\n      var index = dividedSegmentIndex;\n      pathCopy.replaceSegment(index, divided);\n      var divisionStartIndex = index;\n      var divisionMidIndex = index + 1;\n      var divisionEndIndex = index + 2; // do not insert the part if it looks like a point\n\n      if (!divided[0].isDifferentiable()) {\n        pathCopy.removeSegment(divisionStartIndex);\n        divisionMidIndex -= 1;\n        divisionEndIndex -= 1;\n      } // insert a Moveto segment to ensure secondPath will be valid:\n\n\n      var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n      pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n      divisionEndIndex += 1; // do not insert the part if it looks like a point\n\n      if (!divided[1].isDifferentiable()) {\n        pathCopy.removeSegment(divisionEndIndex - 1);\n        divisionEndIndex -= 1;\n      } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\n      var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\n      for (var _i = divisionEndIndex, _ii = pathCopy.segments.length; _i < _ii; _i += 1) {\n        var originalSegment = this.getSegment(_i - secondPathSegmentIndexConversion);\n\n        var _segment = pathCopy.getSegment(_i);\n\n        if (_segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(_segment.subpathStartSegment.end)) {\n          // pathCopy segment's subpathStartSegment is different from original segment's one\n          // convert this Closepath segment to a Lineto and replace it in pathCopy\n          var convertedSegment = Path.createSegment('L', originalSegment.end);\n          pathCopy.replaceSegment(_i, convertedSegment);\n        }\n      } // distribute pathCopy segments into two paths and return those:\n\n\n      var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n      var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n      return [firstPath, secondPath];\n    }\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var polylines = this.toPolylines(options);\n\n      if (polylines == null) {\n        return null;\n      }\n\n      var intersections = null;\n\n      for (var i = 0, ii = polylines.length; i < ii; i += 1) {\n        var polyline = polylines[i];\n        var intersection = line.intersect(polyline);\n\n        if (intersection) {\n          if (intersections == null) {\n            intersections = [];\n          }\n\n          if (Array.isArray(intersection)) {\n            var _intersections;\n\n            (_intersections = intersections).push.apply(_intersections, _toConsumableArray(intersection));\n          } else {\n            intersections.push(intersection);\n          }\n        }\n      }\n\n      return intersections;\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n\n        if (segment.isDifferentiable()) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      var segments = this.segments;\n      var isValid = segments.length === 0 || segments[0].type === 'M';\n      return isValid;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.segments.length === 0) {\n        return 0;\n      }\n\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var length = 0;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n        var subdivisions = segmentSubdivisions[i];\n        length += segment.length({\n          subdivisions: subdivisions\n        });\n      }\n\n      return length;\n    }\n  }, {\n    key: \"lengthAtT\",\n    value: function lengthAtT(t) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var count = this.segments.length;\n\n      if (count === 0) {\n        return 0;\n      }\n\n      var segmentIndex = t.segmentIndex;\n\n      if (segmentIndex < 0) {\n        return 0;\n      }\n\n      var tValue = clamp(t.value, 0, 1);\n\n      if (segmentIndex >= count) {\n        segmentIndex = count - 1;\n        tValue = 1;\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var length = 0;\n\n      for (var i = 0; i < segmentIndex; i += 1) {\n        var _segment2 = this.segments[i];\n        var _subdivisions = segmentSubdivisions[i];\n        length += _segment2.length({\n          precision: precision,\n          subdivisions: _subdivisions\n        });\n      }\n\n      var segment = this.segments[segmentIndex];\n      var subdivisions = segmentSubdivisions[segmentIndex];\n      length += segment.lengthAtT(tValue, {\n        precision: precision,\n        subdivisions: subdivisions\n      });\n      return length;\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var rate = clamp(ratio, 0, 1);\n      var opts = this.getOptions(options);\n      var len = this.length(opts);\n      var length = len * rate;\n      return this.tangentAtLength(length, opts);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var lastValidSegment;\n      var memo = 0;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var index = fromStart ? i : ii - 1 - i;\n        var segment = this.segments[index];\n        var subdivisions = segmentSubdivisions[index];\n        var len = segment.length({\n          precision: precision,\n          subdivisions: subdivisions\n        });\n\n        if (segment.isDifferentiable()) {\n          if (length <= memo + len) {\n            return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n              precision: precision,\n              subdivisions: subdivisions\n            });\n          }\n\n          lastValidSegment = segment;\n        }\n\n        memo += len;\n      } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\n\n      if (lastValidSegment) {\n        var t = fromStart ? 1 : 0;\n        return lastValidSegment.tangentAtT(t);\n      } // if no valid segment, return null\n\n\n      return null;\n    }\n  }, {\n    key: \"tangentAtT\",\n    value: function tangentAtT(t) {\n      var count = this.segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      var segmentIndex = t.segmentIndex;\n\n      if (segmentIndex < 0) {\n        return this.segments[0].tangentAtT(0);\n      }\n\n      if (segmentIndex >= count) {\n        return this.segments[count - 1].tangentAtT(1);\n      }\n\n      var tValue = clamp(t.value, 0, 1);\n      return this.segments[segmentIndex].tangentAtT(tValue);\n    }\n  }, {\n    key: \"getPrecision\",\n    value: function getPrecision() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return options.precision == null ? this.PRECISION : options.precision;\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.segmentSubdivisions == null) {\n        var precision = this.getPrecision(options);\n        return this.getSegmentSubdivisions({\n          precision: precision\n        });\n      }\n\n      return options.segmentSubdivisions;\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      return {\n        precision: precision,\n        segmentSubdivisions: segmentSubdivisions\n      };\n    }\n  }, {\n    key: \"toPoints\",\n    value: function toPoints() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var segments = this.segments;\n      var count = segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var points = [];\n      var partialPoints = [];\n\n      for (var i = 0; i < count; i += 1) {\n        var segment = segments[i];\n\n        if (segment.isVisible) {\n          var divisions = segmentSubdivisions[i];\n\n          if (divisions.length > 0) {\n            // eslint-disable-next-line no-loop-func\n            divisions.forEach(function (c) {\n              return partialPoints.push(c.start);\n            });\n          } else {\n            partialPoints.push(segment.start);\n          }\n        } else if (partialPoints.length > 0) {\n          partialPoints.push(segments[i - 1].end);\n          points.push(partialPoints);\n          partialPoints = [];\n        }\n      }\n\n      if (partialPoints.length > 0) {\n        partialPoints.push(this.end);\n        points.push(partialPoints);\n      }\n\n      return points;\n    }\n  }, {\n    key: \"toPolylines\",\n    value: function toPolylines() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var points = this.toPoints(options);\n\n      if (!points) {\n        return null;\n      }\n\n      return points.map(function (arr) {\n        return new Polyline(arr);\n      });\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.segments.forEach(function (s) {\n        return s.scale(sx, sy, origin);\n      });\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.segments.forEach(function (segment) {\n        return segment.rotate(angle, origin);\n      });\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.segments.forEach(function (s) {\n          return s.translate(tx, ty);\n        });\n      } else {\n        this.segments.forEach(function (s) {\n          return s.translate(tx);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var path = new Path();\n      this.segments.forEach(function (s) {\n        return path.appendSegment(s.clone());\n      });\n      return path;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      if (p == null) {\n        return false;\n      }\n\n      var segments = this.segments;\n      var otherSegments = p.segments;\n      var count = segments.length;\n\n      if (otherSegments.length !== count) {\n        return false;\n      }\n\n      for (var i = 0; i < count; i += 1) {\n        var a = segments[i];\n        var b = otherSegments[i];\n\n        if (a.type !== b.type || !a.equals(b)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.segments.map(function (s) {\n        return s.toJSON();\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      if (!this.isValid()) {\n        throw new Error('Invalid path segments.');\n      }\n\n      return this.segments.map(function (s) {\n        return s.serialize();\n      }).join(' ');\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.serialize();\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Path.toStringTag;\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      var segments = this.segments;\n      var count = segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      for (var i = 0; i < count; i += 1) {\n        var segment = segments[i];\n\n        if (segment.isVisible) {\n          return segment.start;\n        }\n      } // if no visible segment, return last segment end point\n\n\n      return segments[count - 1].end;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      var segments = this.segments;\n      var count = segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      for (var i = count - 1; i >= 0; i -= 1) {\n        var segment = segments[i];\n\n        if (segment.isVisible) {\n          return segment.end;\n        }\n      } // if no visible segment, return last segment end point\n\n\n      return segments[count - 1].end;\n    }\n  }]);\n\n  return Path;\n}(Geometry);\n\n(function (Path) {\n  Path.toStringTag = \"X6.Geometry.\".concat(Path.name);\n\n  function isPath(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Path) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var path = instance;\n\n    if ((tag == null || tag === Path.toStringTag) && Array.isArray(path.segments) && typeof path.moveTo === 'function' && typeof path.lineTo === 'function' && typeof path.curveTo === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Path.isPath = isPath;\n})(Path || (Path = {}));\n\n(function (Path) {\n  function parse(pathData) {\n    if (!pathData) {\n      return new Path();\n    }\n\n    var path = new Path();\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = Path.normalize(pathData).match(commandRe);\n\n    if (commands != null) {\n      for (var i = 0, ii = commands.length; i < ii; i += 1) {\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g; // args = [type, coordinate1, coordinate2...]\n\n        var args = command.match(argRe);\n\n        if (args != null) {\n          var type = args[0];\n          var coords = args.slice(1).map(function (a) {\n            return +a;\n          });\n          var segment = createSegment.call.apply(createSegment, [null, type].concat(_toConsumableArray(coords)));\n          path.appendSegment(segment);\n        }\n      }\n    }\n\n    return path;\n  }\n\n  Path.parse = parse;\n\n  function createSegment(type) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    if (type === 'M') {\n      var _MoveTo$create2;\n\n      return (_MoveTo$create2 = MoveTo.create).call.apply(_MoveTo$create2, [null].concat(args));\n    }\n\n    if (type === 'L') {\n      var _LineTo$create2;\n\n      return (_LineTo$create2 = LineTo.create).call.apply(_LineTo$create2, [null].concat(args));\n    }\n\n    if (type === 'C') {\n      var _CurveTo$create2;\n\n      return (_CurveTo$create2 = CurveTo.create).call.apply(_CurveTo$create2, [null].concat(args));\n    }\n\n    if (type === 'z' || type === 'Z') {\n      return Close.create();\n    }\n\n    throw new Error(\"Invalid path segment type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  Path.createSegment = createSegment;\n})(Path || (Path = {}));\n\n(function (Path) {\n  Path.normalize = normalizePathData;\n  Path.isValid = Util.isValid;\n  Path.drawArc = Util.drawArc;\n  Path.drawPoints = Util.drawPoints;\n  Path.arcToCurves = Util.arcToCurves;\n})(Path || (Path = {}));","map":null,"metadata":{},"sourceType":"module"}