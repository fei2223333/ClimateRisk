{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nvar initOrder = function initOrder(g) {\n  var visited = {};\n  var simpleNodes = g.nodes().filter(function (v) {\n    var _a;\n\n    return !((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length);\n  });\n  var nodeRanks = simpleNodes.map(function (v) {\n    return g.node(v).rank;\n  });\n  var maxRank = Math.max.apply(Math, _toConsumableArray(nodeRanks));\n  var layers = [];\n\n  for (var i = 0; i < maxRank + 1; i++) {\n    layers.push([]);\n  } // const layers = _.map(_.range(maxRank + 1), function() { return []; });\n\n\n  var dfs = function dfs(v) {\n    var _a;\n\n    if (visited.hasOwnProperty(v)) return;\n    visited[v] = true;\n    var node = g.node(v);\n\n    if (!isNaN(node.rank)) {\n      layers[node.rank].push(v);\n    }\n\n    (_a = g.successors(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      return dfs(child);\n    });\n  };\n\n  var orderedVs = simpleNodes.sort(function (a, b) {\n    return g.node(a).rank - g.node(b).rank;\n  }); // const orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v).rank; });\n  // 有fixOrder的，直接排序好放进去\n\n  var beforeSort = orderedVs.filter(function (n) {\n    return g.node(n).fixorder !== undefined;\n  });\n  var fixOrderNodes = beforeSort.sort(function (a, b) {\n    return g.node(a).fixorder - g.node(b).fixorder;\n  });\n  fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach(function (n) {\n    if (!isNaN(g.node(n).rank)) {\n      layers[g.node(n).rank].push(n);\n    }\n\n    visited[n] = true;\n  });\n  orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach(dfs);\n  return layers;\n};\n\nexport default initOrder;","map":null,"metadata":{},"sourceType":"module"}