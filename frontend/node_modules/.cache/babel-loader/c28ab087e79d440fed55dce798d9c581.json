{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\n/* eslint-disable no-underscore-dangle */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Basecoat } from '../common';\nimport { Attr } from '../registry';\nimport { Animation } from './animation';\nimport { Store } from './store';\nexport var Cell = /*#__PURE__*/function (_Basecoat) {\n  _inherits(Cell, _Basecoat);\n\n  function Cell() {\n    var _this;\n\n    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Cell);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Cell).call(this));\n    var ctor = _this.constructor;\n    var defaults = ctor.getDefaults(true);\n    var props = ObjectExt.merge({}, _this.preprocess(defaults), _this.preprocess(metadata));\n    _this.id = props.id || StringExt.uuid();\n    _this.store = new Store(props);\n    _this.animation = new Animation(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    _this.setup();\n\n    _this.init();\n\n    _this.postprocess(metadata);\n\n    return _this;\n  }\n\n  _createClass(Cell, [{\n    key: \"init\",\n    value: function init() {} // #region model\n\n  }, {\n    key: \"preprocess\",\n    // #endregion\n    value: function preprocess(metadata, ignoreIdCheck) {\n      var id = metadata.id;\n      var ctor = this.constructor;\n      var props = ctor.applyPropHooks(this, metadata);\n\n      if (id == null && ignoreIdCheck !== true) {\n        props.id = StringExt.uuid();\n      }\n\n      return props;\n    }\n  }, {\n    key: \"postprocess\",\n    value: function postprocess(metadata) {} // eslint-disable-line\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this2 = this;\n\n      this.store.on('change:*', function (metadata) {\n        var key = metadata.key,\n            current = metadata.current,\n            previous = metadata.previous,\n            options = metadata.options;\n\n        _this2.notify('change:*', {\n          key: key,\n          options: options,\n          current: current,\n          previous: previous,\n          cell: _this2\n        });\n\n        _this2.notify(\"change:\".concat(key), {\n          options: options,\n          current: current,\n          previous: previous,\n          cell: _this2\n        });\n\n        var type = key;\n\n        if (type === 'source' || type === 'target') {\n          _this2.notify(\"change:terminal\", {\n            type: type,\n            current: current,\n            previous: previous,\n            options: options,\n            cell: _this2\n          });\n        }\n      });\n      this.store.on('changed', function (_ref) {\n        var options = _ref.options;\n        return _this2.notify('changed', {\n          options: options,\n          cell: _this2\n        });\n      });\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(name, args) {\n      this.trigger(name, args);\n      var model = this.model;\n\n      if (model) {\n        model.notify(\"cell:\".concat(name), args);\n\n        if (this.isNode()) {\n          model.notify(\"node:\".concat(name), Object.assign(Object.assign({}, args), {\n            node: this\n          }));\n        } else if (this.isEdge()) {\n          model.notify(\"edge:\".concat(name), Object.assign(Object.assign({}, args), {\n            edge: this\n          }));\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"isNode\",\n    value: function isNode() {\n      return false;\n    }\n  }, {\n    key: \"isEdge\",\n    value: function isEdge() {\n      return false;\n    }\n  }, {\n    key: \"isSameStore\",\n    value: function isSameStore(cell) {\n      return this.store === cell.store;\n    }\n  }, {\n    key: \"getProp\",\n    value: function getProp(key, defaultValue) {\n      if (key == null) {\n        return this.store.get();\n      }\n\n      return this.store.get(key, defaultValue);\n    }\n  }, {\n    key: \"setProp\",\n    value: function setProp(key, value, options) {\n      if (typeof key === 'string') {\n        this.store.set(key, value, options);\n      } else {\n        var props = this.preprocess(key, true);\n        this.store.set(ObjectExt.merge({}, this.getProp(), props), value);\n        this.postprocess(key);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeProp\",\n    value: function removeProp(key, options) {\n      if (typeof key === 'string' || Array.isArray(key)) {\n        this.store.removeByPath(key, options);\n      } else {\n        this.store.remove(options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hasChanged\",\n    value: function hasChanged(key) {\n      return key == null ? this.store.hasChanged() : this.store.hasChanged(key);\n    }\n  }, {\n    key: \"getPropByPath\",\n    value: function getPropByPath(path) {\n      return this.store.getByPath(path);\n    }\n  }, {\n    key: \"setPropByPath\",\n    value: function setPropByPath(path, value) {\n      var _this3 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this.model) {\n        // update inner reference\n        if (path === 'children') {\n          this._children = value ? value.map(function (id) {\n            return _this3.model.getCell(id);\n          }).filter(function (child) {\n            return child != null;\n          }) : null;\n        } else if (path === 'parent') {\n          this._parent = value ? this.model.getCell(value) : null;\n        }\n      }\n\n      this.store.setByPath(path, value, options);\n      return this;\n    }\n  }, {\n    key: \"removePropByPath\",\n    value: function removePropByPath(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var paths = Array.isArray(path) ? path : path.split('/'); // Once a property is removed from the `attrs` the CellView will\n      // recognize a `dirty` flag and re-render itself in order to remove\n      // the attribute from SVGElement.\n\n      if (paths[0] === 'attrs') {\n        options.dirty = true;\n      }\n\n      this.store.removeByPath(paths, options);\n      return this;\n    }\n  }, {\n    key: \"prop\",\n    value: function prop(key, value, options) {\n      if (key == null) {\n        return this.getProp();\n      }\n\n      if (typeof key === 'string' || Array.isArray(key)) {\n        if (arguments.length === 1) {\n          return this.getPropByPath(key);\n        }\n\n        if (value == null) {\n          return this.removePropByPath(key, options || {});\n        }\n\n        return this.setPropByPath(key, value, options || {});\n      }\n\n      return this.setProp(key, value || {});\n    }\n  }, {\n    key: \"previous\",\n    value: function previous(name) {\n      return this.store.getPrevious(name);\n    } // #endregion\n    // #region zIndex\n\n  }, {\n    key: \"getZIndex\",\n    value: function getZIndex() {\n      return this.store.get('zIndex');\n    }\n  }, {\n    key: \"setZIndex\",\n    value: function setZIndex(z) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('zIndex', z, options);\n      return this;\n    }\n  }, {\n    key: \"removeZIndex\",\n    value: function removeZIndex() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('zIndex', options);\n      return this;\n    }\n  }, {\n    key: \"toFront\",\n    value: function toFront() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.model;\n\n      if (model) {\n        var z = model.getMaxZIndex();\n        var cells;\n\n        if (options.deep) {\n          cells = this.getDescendants({\n            deep: true,\n            breadthFirst: true\n          });\n          cells.unshift(this);\n        } else {\n          cells = [this];\n        }\n\n        z = z - cells.length + 1;\n        var count = model.total();\n        var changed = model.indexOf(this) !== count - cells.length;\n\n        if (!changed) {\n          changed = cells.some(function (cell, index) {\n            return cell.getZIndex() !== z + index;\n          });\n        }\n\n        if (changed) {\n          this.batchUpdate('to-front', function () {\n            z += cells.length;\n            cells.forEach(function (cell, index) {\n              cell.setZIndex(z + index, options);\n            });\n          });\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"toBack\",\n    value: function toBack() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.model;\n\n      if (model) {\n        var z = model.getMinZIndex();\n        var cells;\n\n        if (options.deep) {\n          cells = this.getDescendants({\n            deep: true,\n            breadthFirst: true\n          });\n          cells.unshift(this);\n        } else {\n          cells = [this];\n        }\n\n        var changed = model.indexOf(this) !== 0;\n\n        if (!changed) {\n          changed = cells.some(function (cell, index) {\n            return cell.getZIndex() !== z + index;\n          });\n        }\n\n        if (changed) {\n          this.batchUpdate('to-back', function () {\n            z -= cells.length;\n            cells.forEach(function (cell, index) {\n              cell.setZIndex(z + index, options);\n            });\n          });\n        }\n      }\n\n      return this;\n    } // #endregion\n    // #region markup\n\n  }, {\n    key: \"getMarkup\",\n    value: function getMarkup() {\n      var markup = this.store.get('markup');\n\n      if (markup == null) {\n        var ctor = this.constructor;\n        markup = ctor.getMarkup();\n      }\n\n      return markup;\n    }\n  }, {\n    key: \"setMarkup\",\n    value: function setMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('markup', markup, options);\n      return this;\n    }\n  }, {\n    key: \"removeMarkup\",\n    value: function removeMarkup() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('markup', options);\n      return this;\n    } // #endregion\n    // #region attrs\n\n  }, {\n    key: \"getAttrs\",\n    value: function getAttrs() {\n      var result = this.store.get('attrs');\n      return result ? Object.assign({}, result) : {};\n    }\n  }, {\n    key: \"setAttrs\",\n    value: function setAttrs(attrs) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (attrs == null) {\n        this.removeAttrs(options);\n      } else {\n        var set = function set(attrs) {\n          return _this4.store.set('attrs', attrs, options);\n        };\n\n        if (options.overwrite === true) {\n          set(attrs);\n        } else {\n          var prev = this.getAttrs();\n\n          if (options.deep === false) {\n            set(Object.assign(Object.assign({}, prev), attrs));\n          } else {\n            set(ObjectExt.merge({}, prev, attrs));\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"replaceAttrs\",\n    value: function replaceAttrs(attrs) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n        overwrite: true\n      }));\n    }\n  }, {\n    key: \"updateAttrs\",\n    value: function updateAttrs(attrs) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n        deep: false\n      }));\n    }\n  }, {\n    key: \"removeAttrs\",\n    value: function removeAttrs() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('attrs', options);\n      return this;\n    }\n  }, {\n    key: \"getAttrDefinition\",\n    value: function getAttrDefinition(attrName) {\n      if (!attrName) {\n        return null;\n      }\n\n      var ctor = this.constructor;\n      var hooks = ctor.getAttrHooks() || {};\n      var definition = hooks[attrName] || Attr.registry.get(attrName);\n\n      if (!definition) {\n        var name = StringExt.camelCase(attrName);\n        definition = hooks[name] || Attr.registry.get(name);\n      }\n\n      return definition || null;\n    }\n  }, {\n    key: \"getAttrByPath\",\n    value: function getAttrByPath(path) {\n      if (path == null || path === '') {\n        return this.getAttrs();\n      }\n\n      return this.getPropByPath(this.prefixAttrPath(path));\n    }\n  }, {\n    key: \"setAttrByPath\",\n    value: function setAttrByPath(path, value) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.setPropByPath(this.prefixAttrPath(path), value, options);\n      return this;\n    }\n  }, {\n    key: \"removeAttrByPath\",\n    value: function removeAttrByPath(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.removePropByPath(this.prefixAttrPath(path), options);\n      return this;\n    }\n  }, {\n    key: \"prefixAttrPath\",\n    value: function prefixAttrPath(path) {\n      return Array.isArray(path) ? ['attrs'].concat(path) : \"attrs/\".concat(path);\n    }\n  }, {\n    key: \"attr\",\n    value: function attr(path, value, options) {\n      if (path == null) {\n        return this.getAttrByPath();\n      }\n\n      if (typeof path === 'string' || Array.isArray(path)) {\n        if (arguments.length === 1) {\n          return this.getAttrByPath(path);\n        }\n\n        if (value == null) {\n          return this.removeAttrByPath(path, options || {});\n        }\n\n        return this.setAttrByPath(path, value, options || {});\n      }\n\n      return this.setAttrs(path, value || {});\n    } // #endregion\n    // #region visible\n\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('visible', visible, options);\n      return this;\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this.store.get('visible') !== false;\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.isVisible()) {\n        this.setVisible(true, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.isVisible()) {\n        this.setVisible(false, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"toggleVisible\",\n    value: function toggleVisible(isVisible) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();\n      var localOptions = typeof isVisible === 'boolean' ? options : isVisible;\n\n      if (visible) {\n        this.show(localOptions);\n      } else {\n        this.hide(localOptions);\n      }\n\n      return this;\n    } // #endregion\n    // #region data\n\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.store.get('data');\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      var _this5 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (data == null) {\n        this.removeData(options);\n      } else {\n        var set = function set(data) {\n          return _this5.store.set('data', data, options);\n        };\n\n        if (options.overwrite === true) {\n          set(data);\n        } else {\n          var prev = this.getData();\n\n          if (options.deep === false) {\n            set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);\n          } else {\n            set(ObjectExt.merge({}, prev, data));\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"replaceData\",\n    value: function replaceData(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setData(data, Object.assign(Object.assign({}, options), {\n        overwrite: true\n      }));\n    }\n  }, {\n    key: \"updateData\",\n    value: function updateData(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setData(data, Object.assign(Object.assign({}, options), {\n        deep: false\n      }));\n    }\n  }, {\n    key: \"removeData\",\n    value: function removeData() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('data', options);\n      return this;\n    } // #endregion\n    // #region parent children\n\n  }, {\n    key: \"getParentId\",\n    value: function getParentId() {\n      return this.store.get('parent');\n    }\n  }, {\n    key: \"getParent\",\n    value: function getParent() {\n      var parentId = this.getParentId();\n\n      if (parentId && this.model) {\n        var parent = this.model.getCell(parentId);\n        this._parent = parent;\n        return parent;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var _this6 = this;\n\n      var childrenIds = this.store.get('children');\n\n      if (childrenIds && childrenIds.length && this.model) {\n        var children = childrenIds.map(function (id) {\n          var _a;\n\n          return (_a = _this6.model) === null || _a === void 0 ? void 0 : _a.getCell(id);\n        }).filter(function (cell) {\n          return cell != null;\n        });\n        this._children = children;\n        return _toConsumableArray(children);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"hasParent\",\n    value: function hasParent() {\n      return this.parent != null;\n    }\n  }, {\n    key: \"isParentOf\",\n    value: function isParentOf(child) {\n      return child != null && child.getParent() === this;\n    }\n  }, {\n    key: \"isChildOf\",\n    value: function isChildOf(parent) {\n      return parent != null && this.getParent() === parent;\n    }\n  }, {\n    key: \"eachChild\",\n    value: function eachChild(iterator, context) {\n      if (this.children) {\n        this.children.forEach(iterator, context);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"filterChild\",\n    value: function filterChild(filter, context) {\n      return this.children ? this.children.filter(filter, context) : [];\n    }\n  }, {\n    key: \"getChildCount\",\n    value: function getChildCount() {\n      return this.children == null ? 0 : this.children.length;\n    }\n  }, {\n    key: \"getChildIndex\",\n    value: function getChildIndex(child) {\n      return this.children == null ? -1 : this.children.indexOf(child);\n    }\n  }, {\n    key: \"getChildAt\",\n    value: function getChildAt(index) {\n      return this.children != null && index >= 0 ? this.children[index] : null;\n    }\n  }, {\n    key: \"getAncestors\",\n    value: function getAncestors() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var ancestors = [];\n      var parent = this.getParent();\n\n      while (parent) {\n        ancestors.push(parent);\n        parent = options.deep !== false ? parent.getParent() : null;\n      }\n\n      return ancestors;\n    }\n  }, {\n    key: \"getDescendants\",\n    value: function getDescendants() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.deep !== false) {\n        // breadth first\n        if (options.breadthFirst) {\n          var cells = [];\n          var queue = this.getChildren() || [];\n\n          while (queue.length > 0) {\n            var parent = queue.shift();\n            var children = parent.getChildren();\n            cells.push(parent);\n\n            if (children) {\n              queue.push.apply(queue, _toConsumableArray(children));\n            }\n          }\n\n          return cells;\n        } // depth first\n\n\n        {\n          var _cells = this.getChildren() || [];\n\n          _cells.forEach(function (cell) {\n            _cells.push.apply(_cells, _toConsumableArray(cell.getDescendants(options)));\n          });\n\n          return _cells;\n        }\n      }\n\n      return this.getChildren() || [];\n    }\n  }, {\n    key: \"isDescendantOf\",\n    value: function isDescendantOf(ancestor) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (ancestor == null) {\n        return false;\n      }\n\n      if (options.deep !== false) {\n        var current = this.getParent();\n\n        while (current) {\n          if (current === ancestor) {\n            return true;\n          }\n\n          current = current.getParent();\n        }\n\n        return false;\n      }\n\n      return this.isChildOf(ancestor);\n    }\n  }, {\n    key: \"isAncestorOf\",\n    value: function isAncestorOf(descendant) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (descendant == null) {\n        return false;\n      }\n\n      return descendant.isDescendantOf(this, options);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(cell) {\n      return this.isAncestorOf(cell);\n    }\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor() {\n      for (var _len = arguments.length, cells = new Array(_len), _key = 0; _key < _len; _key++) {\n        cells[_key] = arguments[_key];\n      }\n\n      return Cell.getCommonAncestor.apply(Cell, [this].concat(cells));\n    }\n  }, {\n    key: \"setParent\",\n    value: function setParent(parent) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this._parent = parent;\n\n      if (parent) {\n        this.store.set('parent', parent.id, options);\n      } else {\n        this.store.remove('parent', options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setChildren\",\n    value: function setChildren(children) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this._children = children;\n\n      if (children != null) {\n        this.store.set('children', children.map(function (child) {\n          return child.id;\n        }), options);\n      } else {\n        this.store.remove('children', options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"unembed\",\n    value: function unembed(child) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var children = this.children;\n\n      if (children != null && child != null) {\n        var index = this.getChildIndex(child);\n\n        if (index !== -1) {\n          children.splice(index, 1);\n          child.setParent(null, options);\n          this.setChildren(children, options);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"embed\",\n    value: function embed(child) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      child.addTo(this, options);\n      return this;\n    }\n  }, {\n    key: \"addTo\",\n    value: function addTo(target) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Cell.isCell(target)) {\n        target.addChild(this, options);\n      } else {\n        target.addCell(this, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"insertTo\",\n    value: function insertTo(parent, index) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      parent.insertChild(this, index, options);\n      return this;\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(child) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.insertChild(child, undefined, options);\n    }\n  }, {\n    key: \"insertChild\",\n    value: function insertChild(child, index) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (child != null && child !== this) {\n        var oldParent = child.getParent();\n        var changed = this !== oldParent;\n        var pos = index;\n\n        if (pos == null) {\n          pos = this.getChildCount();\n\n          if (!changed) {\n            pos -= 1;\n          }\n        } // remove from old parent\n\n\n        if (oldParent) {\n          var _children = oldParent.getChildren();\n\n          if (_children) {\n            var _index = _children.indexOf(child);\n\n            if (_index >= 0) {\n              child.setParent(null, options);\n\n              _children.splice(_index, 1);\n\n              oldParent.setChildren(_children, options);\n            }\n          }\n        }\n\n        var children = this.children;\n\n        if (children == null) {\n          children = [];\n          children.push(child);\n        } else {\n          children.splice(pos, 0, child);\n        }\n\n        child.setParent(this, options);\n        this.setChildren(children, options);\n\n        if (changed && this.model) {\n          var incomings = this.model.getIncomingEdges(this);\n          var outgoings = this.model.getOutgoingEdges(this);\n\n          if (incomings) {\n            incomings.forEach(function (edge) {\n              return edge.updateParent(options);\n            });\n          }\n\n          if (outgoings) {\n            outgoings.forEach(function (edge) {\n              return edge.updateParent(options);\n            });\n          }\n        }\n\n        if (this.model) {\n          this.model.addCell(child, options);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeFromParent\",\n    value: function removeFromParent() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var parent = this.getParent();\n\n      if (parent != null) {\n        var index = parent.getChildIndex(this);\n        parent.removeChildAt(index, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = this.getChildIndex(child);\n      return this.removeChildAt(index, options);\n    }\n  }, {\n    key: \"removeChildAt\",\n    value: function removeChildAt(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var child = this.getChildAt(index);\n      var children = this.children;\n\n      if (children != null && child != null) {\n        this.unembed(child, options);\n        child.remove(options);\n      }\n\n      return child;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this7 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.batchUpdate('remove', function () {\n        var parent = _this7.getParent();\n\n        if (parent) {\n          parent.removeChild(_this7, options);\n        }\n\n        if (options.deep !== false) {\n          _this7.eachChild(function (child) {\n            return child.remove(options);\n          });\n        }\n\n        if (_this7.model) {\n          _this7.model.removeCell(_this7, options);\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"transition\",\n    value: function transition(path, target) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var delim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n      return this.animation.start(path, target, options, delim);\n    }\n  }, {\n    key: \"stopTransition\",\n    value: function stopTransition(path, options) {\n      var delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';\n      this.animation.stop(path, options, delim);\n      return this;\n    }\n  }, {\n    key: \"getTransitions\",\n    value: function getTransitions() {\n      return this.animation.get();\n    } // #endregion\n    // #region transform\n    // eslint-disable-next-line\n\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty, options) {\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, // eslint-disable-line\n    sy, // eslint-disable-line\n    origin, // eslint-disable-line\n    options) {\n      return this;\n    }\n  }, {\n    key: \"addTools\",\n    value: function addTools(items, obj, options) {\n      var toolItems = Array.isArray(items) ? items : [items];\n      var name = typeof obj === 'string' ? obj : null;\n      var config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};\n\n      if (config.reset) {\n        return this.setTools({\n          name: name,\n          items: toolItems,\n          local: config.local\n        }, config);\n      }\n\n      var tools = ObjectExt.cloneDeep(this.getTools());\n\n      if (tools == null || name == null || tools.name === name) {\n        if (tools == null) {\n          tools = {};\n        }\n\n        if (!tools.items) {\n          tools.items = [];\n        }\n\n        tools.name = name;\n        tools.items = [].concat(_toConsumableArray(tools.items), _toConsumableArray(toolItems));\n        return this.setTools(Object.assign({}, tools), config);\n      }\n    }\n  }, {\n    key: \"setTools\",\n    value: function setTools(tools) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (tools == null) {\n        this.removeTools();\n      } else {\n        this.store.set('tools', Cell.normalizeTools(tools), options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getTools\",\n    value: function getTools() {\n      return this.store.get('tools');\n    }\n  }, {\n    key: \"removeTools\",\n    value: function removeTools() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('tools', options);\n      return this;\n    }\n  }, {\n    key: \"hasTools\",\n    value: function hasTools(name) {\n      var tools = this.getTools();\n\n      if (tools == null) {\n        return false;\n      }\n\n      if (name == null) {\n        return true;\n      }\n\n      return tools.name === name;\n    }\n  }, {\n    key: \"hasTool\",\n    value: function hasTool(name) {\n      var tools = this.getTools();\n\n      if (tools == null) {\n        return false;\n      }\n\n      return tools.items.some(function (item) {\n        return typeof item === 'string' ? item === name : item.name === name;\n      });\n    }\n  }, {\n    key: \"removeTool\",\n    value: function removeTool(nameOrIndex) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var tools = ObjectExt.cloneDeep(this.getTools());\n\n      if (tools) {\n        var updated = false;\n        var items = tools.items.slice();\n\n        var remove = function remove(index) {\n          items.splice(index, 1);\n          updated = true;\n        };\n\n        if (typeof nameOrIndex === 'number') {\n          remove(nameOrIndex);\n        } else {\n          for (var i = items.length - 1; i >= 0; i -= 1) {\n            var item = items[i];\n            var exist = typeof item === 'string' ? item === nameOrIndex : item.name === nameOrIndex;\n\n            if (exist) {\n              remove(i);\n            }\n          }\n        }\n\n        if (updated) {\n          tools.items = items;\n          this.setTools(tools, options);\n        }\n      }\n\n      return this;\n    } // #endregion\n    // #region common\n    // eslint-disable-next-line\n\n  }, {\n    key: \"getBBox\",\n    value: function getBBox(options) {\n      return new Rectangle();\n    } // eslint-disable-next-line\n\n  }, {\n    key: \"getConnectionPoint\",\n    value: function getConnectionPoint(edge, type) {\n      return new Point();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this8 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var props = Object.assign({}, this.store.get());\n      var toString = Object.prototype.toString;\n      var cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';\n\n      if (!props.shape) {\n        var _ctor = this.constructor;\n        throw new Error(\"Unable to serialize \".concat(cellType, \" missing \\\"shape\\\" prop, check the \").concat(cellType, \" \\\"\").concat(_ctor.name || toString.call(_ctor), \"\\\"\"));\n      }\n\n      var ctor = this.constructor;\n      var diff = options.diff === true;\n      var attrs = props.attrs || {};\n      var presets = ctor.getDefaults(true); // When `options.diff` is `true`, we should process the custom options,\n      // such as `width`, `height` etc. to ensure the comparing work correctly.\n\n      var defaults = diff ? this.preprocess(presets, true) : presets;\n      var defaultAttrs = defaults.attrs || {};\n      var finalAttrs = {};\n      Object.keys(props).forEach(function (key) {\n        var val = props[key];\n\n        if (val != null && !Array.isArray(val) && typeof val === 'object' && !ObjectExt.isPlainObject(val)) {\n          throw new Error(\"Can only serialize \".concat(cellType, \" with plain-object props, but got a \\\"\").concat(toString.call(val), \"\\\" type of key \\\"\").concat(key, \"\\\" on \").concat(cellType, \" \\\"\").concat(_this8.id, \"\\\"\"));\n        }\n\n        if (key !== 'attrs' && key !== 'shape' && diff) {\n          var preset = defaults[key];\n\n          if (ObjectExt.isEqual(val, preset)) {\n            delete props[key];\n          }\n        }\n      });\n      Object.keys(attrs).forEach(function (key) {\n        var attr = attrs[key];\n        var defaultAttr = defaultAttrs[key];\n        Object.keys(attr).forEach(function (name) {\n          var value = attr[name];\n          var defaultValue = defaultAttr ? defaultAttr[name] : null;\n\n          if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n            Object.keys(value).forEach(function (subName) {\n              var subValue = value[subName];\n\n              if (defaultAttr == null || defaultValue == null || !ObjectExt.isObject(defaultValue) || !ObjectExt.isEqual(defaultValue[subName], subValue)) {\n                if (finalAttrs[key] == null) {\n                  finalAttrs[key] = {};\n                }\n\n                if (finalAttrs[key][name] == null) {\n                  finalAttrs[key][name] = {};\n                }\n\n                var tmp = finalAttrs[key][name];\n                tmp[subName] = subValue;\n              }\n            });\n          } else if (defaultAttr == null || !ObjectExt.isEqual(defaultValue, value)) {\n            // `value` is not an object, default attribute with `key` does not\n            // exist or it is different than the attribute value set on the cell.\n            if (finalAttrs[key] == null) {\n              finalAttrs[key] = {};\n            }\n\n            finalAttrs[key][name] = value;\n          }\n        });\n      });\n      var finalProps = Object.assign(Object.assign({}, props), {\n        attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs\n      });\n\n      if (finalProps.attrs == null) {\n        delete finalProps.attrs;\n      }\n\n      var ret = finalProps;\n\n      if (ret.angle === 0) {\n        delete ret.angle;\n      }\n\n      return ObjectExt.cloneDeep(ret);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!options.deep) {\n        var data = Object.assign({}, this.store.get());\n\n        if (!options.keepId) {\n          delete data.id;\n        }\n\n        delete data.parent;\n        delete data.children;\n        var ctor = this.constructor;\n        return new ctor(data); // eslint-disable-line new-cap\n      } // Deep cloning. Clone the cell itself and all its children.\n\n\n      var map = Cell.deepClone(this);\n      return map[this.id];\n    }\n  }, {\n    key: \"findView\",\n    value: function findView(graph) {\n      return graph.renderer.findViewByCell(this);\n    } // #endregion\n    // #region batch\n\n  }, {\n    key: \"startBatch\",\n    value: function startBatch(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;\n      this.notify('batch:start', {\n        name: name,\n        data: data,\n        cell: this\n      });\n\n      if (model) {\n        model.startBatch(name, Object.assign(Object.assign({}, data), {\n          cell: this\n        }));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"stopBatch\",\n    value: function stopBatch(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;\n\n      if (model) {\n        model.stopBatch(name, Object.assign(Object.assign({}, data), {\n          cell: this\n        }));\n      }\n\n      this.notify('batch:stop', {\n        name: name,\n        data: data,\n        cell: this\n      });\n      return this;\n    }\n  }, {\n    key: \"batchUpdate\",\n    value: function batchUpdate(name, execute, data) {\n      // The model is null after cell was removed(remove batch).\n      // So we should temp save model to trigger pairing batch event.\n      var model = this.model;\n      this.startBatch(name, data, model);\n      var result = execute();\n      this.stopBatch(name, data, model);\n      return result;\n    } // #endregion\n    // #region IDisposable\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.removeFromParent();\n      this.store.dispose();\n    }\n  }, {\n    key: Symbol.toStringTag,\n    // #endregion\n    get: function get() {\n      return Cell.toStringTag;\n    }\n  }, {\n    key: \"model\",\n    get: function get() {\n      return this._model;\n    },\n    set: function set(model) {\n      if (this._model !== model) {\n        this._model = model;\n      }\n    }\n  }, {\n    key: \"view\",\n    get: function get() {\n      return this.store.get('view');\n    }\n  }, {\n    key: \"shape\",\n    get: function get() {\n      return this.store.get('shape', '');\n    }\n  }, {\n    key: \"zIndex\",\n    get: function get() {\n      return this.getZIndex();\n    },\n    set: function set(z) {\n      if (z == null) {\n        this.removeZIndex();\n      } else {\n        this.setZIndex(z);\n      }\n    }\n  }, {\n    key: \"markup\",\n    get: function get() {\n      return this.getMarkup();\n    },\n    set: function set(value) {\n      if (value == null) {\n        this.removeMarkup();\n      } else {\n        this.setMarkup(value);\n      }\n    }\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this.getAttrs();\n    },\n    set: function set(value) {\n      if (value == null) {\n        this.removeAttrs();\n      } else {\n        this.setAttrs(value);\n      }\n    }\n  }, {\n    key: \"visible\",\n    get: function get() {\n      return this.isVisible();\n    },\n    set: function set(value) {\n      this.setVisible(value);\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.getData();\n    },\n    set: function set(val) {\n      this.setData(val);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.getParent();\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this.getChildren();\n    }\n  }], [{\n    key: \"config\",\n    value: function config(presets) {\n      var _this9 = this;\n\n      var markup = presets.markup,\n          propHooks = presets.propHooks,\n          attrHooks = presets.attrHooks,\n          others = __rest(presets, [\"markup\", \"propHooks\", \"attrHooks\"]);\n\n      if (markup != null) {\n        this.markup = markup;\n      }\n\n      if (propHooks) {\n        this.propHooks = this.propHooks.slice();\n\n        if (Array.isArray(propHooks)) {\n          var _this$propHooks;\n\n          (_this$propHooks = this.propHooks).push.apply(_this$propHooks, _toConsumableArray(propHooks));\n        } else if (typeof propHooks === 'function') {\n          this.propHooks.push(propHooks);\n        } else {\n          Object.keys(propHooks).forEach(function (name) {\n            var hook = propHooks[name];\n\n            if (typeof hook === 'function') {\n              _this9.propHooks.push(hook);\n            }\n          });\n        }\n      }\n\n      if (attrHooks) {\n        this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);\n      }\n\n      this.defaults = ObjectExt.merge({}, this.defaults, others);\n    }\n  }, {\n    key: \"getMarkup\",\n    value: function getMarkup() {\n      return this.markup;\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults(raw) {\n      return raw ? this.defaults : ObjectExt.cloneDeep(this.defaults);\n    }\n  }, {\n    key: \"getAttrHooks\",\n    value: function getAttrHooks() {\n      return this.attrHooks;\n    }\n  }, {\n    key: \"applyPropHooks\",\n    value: function applyPropHooks(cell, metadata) {\n      return this.propHooks.reduce(function (memo, hook) {\n        return hook ? FunctionExt.call(hook, cell, memo) : memo;\n      }, metadata);\n    }\n  }]);\n\n  return Cell;\n}(Basecoat);\nCell.defaults = {};\nCell.attrHooks = {};\nCell.propHooks = [];\n\n__decorate([Basecoat.dispose()], Cell.prototype, \"dispose\", null);\n\n(function (Cell) {\n  function normalizeTools(raw) {\n    if (typeof raw === 'string') {\n      return {\n        items: [raw]\n      };\n    }\n\n    if (Array.isArray(raw)) {\n      return {\n        items: raw\n      };\n    }\n\n    if (raw.items) {\n      return raw;\n    }\n\n    return {\n      items: [raw]\n    };\n  }\n\n  Cell.normalizeTools = normalizeTools;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  Cell.toStringTag = \"X6.\".concat(Cell.name);\n\n  function isCell(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Cell) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var cell = instance;\n\n    if ((tag == null || tag === Cell.toStringTag) && typeof cell.isNode === 'function' && typeof cell.isEdge === 'function' && typeof cell.prop === 'function' && typeof cell.attr === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Cell.isCell = isCell;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  function getCommonAncestor() {\n    for (var _len2 = arguments.length, cells = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      cells[_key2] = arguments[_key2];\n    }\n\n    var ancestors = cells.filter(function (cell) {\n      return cell != null;\n    }).map(function (cell) {\n      return cell.getAncestors();\n    }).sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var first = ancestors.shift();\n    return first.find(function (cell) {\n      return ancestors.every(function (item) {\n        return item.includes(cell);\n      });\n    }) || null;\n  }\n\n  Cell.getCommonAncestor = getCommonAncestor;\n\n  function getCellsBBox(cells) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var bbox = null;\n\n    for (var i = 0, ii = cells.length; i < ii; i += 1) {\n      var cell = cells[i];\n      var rect = cell.getBBox(options);\n\n      if (rect) {\n        if (cell.isNode()) {\n          var angle = cell.getAngle();\n\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle);\n          }\n        }\n\n        bbox = bbox == null ? rect : bbox.union(rect);\n      }\n    }\n\n    return bbox;\n  }\n\n  Cell.getCellsBBox = getCellsBBox;\n\n  function deepClone(cell) {\n    var cells = [cell].concat(_toConsumableArray(cell.getDescendants({\n      deep: true\n    })));\n    return Cell.cloneCells(cells);\n  }\n\n  Cell.deepClone = deepClone;\n\n  function cloneCells(cells) {\n    var inputs = ArrayExt.uniq(cells);\n    var cloneMap = inputs.reduce(function (map, cell) {\n      map[cell.id] = cell.clone();\n      return map;\n    }, {});\n    inputs.forEach(function (cell) {\n      var clone = cloneMap[cell.id];\n\n      if (clone.isEdge()) {\n        var sourceId = clone.getSourceCellId();\n        var targetId = clone.getTargetCellId();\n\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), {\n            cell: cloneMap[sourceId].id\n          }));\n        }\n\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), {\n            cell: cloneMap[targetId].id\n          }));\n        }\n      } // Find the parent of the original cell\n\n\n      var parent = cell.getParent();\n\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id]);\n      } // Find the children of the original cell\n\n\n      var children = cell.getChildren();\n\n      if (children && children.length) {\n        var embeds = children.reduce(function (memo, child) {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id]);\n          }\n\n          return memo;\n        }, []);\n\n        if (embeds.length > 0) {\n          clone.setChildren(embeds);\n        }\n      }\n    });\n    return cloneMap;\n  }\n\n  Cell.cloneCells = cloneCells;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  Cell.config({\n    propHooks: function propHooks(_a) {\n      var tools = _a.tools,\n          metadata = __rest(_a, [\"tools\"]);\n\n      if (tools) {\n        metadata.tools = Cell.normalizeTools(tools);\n      }\n\n      return metadata;\n    }\n  });\n})(Cell || (Cell = {}));","map":null,"metadata":{},"sourceType":"module"}