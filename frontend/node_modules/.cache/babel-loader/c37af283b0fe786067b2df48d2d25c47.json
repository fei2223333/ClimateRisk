{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nexport var er = function er(vertices, options, edgeView) {\n  var offsetRaw = options.offset || 32;\n  var min = options.min == null ? 16 : options.min;\n  var offset = 0;\n  var direction = options.direction;\n  var sourceBBox = edgeView.sourceBBox;\n  var targetBBox = edgeView.targetBBox;\n  var sourcePoint = sourceBBox.getCenter();\n  var targetPoint = targetBBox.getCenter();\n\n  if (typeof offsetRaw === 'number') {\n    offset = offsetRaw;\n  }\n\n  if (direction == null) {\n    var dx = targetBBox.left - sourceBBox.right;\n    var dy = targetBBox.top - sourceBBox.bottom;\n\n    if (dx >= 0 && dy >= 0) {\n      direction = dx >= dy ? 'L' : 'T';\n    } else if (dx <= 0 && dy >= 0) {\n      dx = sourceBBox.left - targetBBox.right;\n\n      if (dx >= 0) {\n        direction = dx >= dy ? 'R' : 'T';\n      } else {\n        direction = 'T';\n      }\n    } else if (dx >= 0 && dy <= 0) {\n      dy = sourceBBox.top - targetBBox.bottom;\n\n      if (dy >= 0) {\n        direction = dx >= dy ? 'L' : 'B';\n      } else {\n        direction = 'L';\n      }\n    } else {\n      dx = sourceBBox.left - targetBBox.right;\n      dy = sourceBBox.top - targetBBox.bottom;\n\n      if (dx >= 0 && dy >= 0) {\n        direction = dx >= dy ? 'R' : 'B';\n      } else if (dx <= 0 && dy >= 0) {\n        direction = 'B';\n      } else if (dx >= 0 && dy <= 0) {\n        direction = 'R';\n      } else {\n        direction = Math.abs(dx) > Math.abs(dy) ? 'R' : 'B';\n      }\n    }\n  }\n\n  if (direction === 'H') {\n    direction = targetPoint.x - sourcePoint.x >= 0 ? 'L' : 'R';\n  } else if (direction === 'V') {\n    direction = targetPoint.y - sourcePoint.y >= 0 ? 'T' : 'B';\n  }\n\n  if (offsetRaw === 'center') {\n    if (direction === 'L') {\n      offset = (targetBBox.left - sourceBBox.right) / 2;\n    } else if (direction === 'R') {\n      offset = (sourceBBox.left - targetBBox.right) / 2;\n    } else if (direction === 'T') {\n      offset = (targetBBox.top - sourceBBox.bottom) / 2;\n    } else if (direction === 'B') {\n      offset = (sourceBBox.top - targetBBox.bottom) / 2;\n    }\n  }\n\n  var coord;\n  var dim;\n  var factor;\n  var horizontal = direction === 'L' || direction === 'R';\n\n  if (horizontal) {\n    if (targetPoint.y === sourcePoint.y) {\n      return _toConsumableArray(vertices);\n    }\n\n    factor = direction === 'L' ? 1 : -1;\n    coord = 'x';\n    dim = 'width';\n  } else {\n    if (targetPoint.x === sourcePoint.x) {\n      return _toConsumableArray(vertices);\n    }\n\n    factor = direction === 'T' ? 1 : -1;\n    coord = 'y';\n    dim = 'height';\n  }\n\n  var source = sourcePoint.clone();\n  var target = targetPoint.clone();\n  source[coord] += factor * (sourceBBox[dim] / 2 + offset);\n  target[coord] -= factor * (targetBBox[dim] / 2 + offset);\n\n  if (horizontal) {\n    var sourceX = source.x;\n    var targetX = target.x;\n    var sourceDelta = sourceBBox.width / 2 + min;\n    var targetDelta = targetBBox.width / 2 + min;\n\n    if (targetPoint.x > sourcePoint.x) {\n      if (targetX <= sourceX) {\n        source.x = Math.max(targetX, sourcePoint.x + sourceDelta);\n        target.x = Math.min(sourceX, targetPoint.x - targetDelta);\n      }\n    } else if (targetX >= sourceX) {\n      source.x = Math.min(targetX, sourcePoint.x - sourceDelta);\n      target.x = Math.max(sourceX, targetPoint.x + targetDelta);\n    }\n  } else {\n    var sourceY = source.y;\n    var targetY = target.y;\n\n    var _sourceDelta = sourceBBox.height / 2 + min;\n\n    var _targetDelta = targetBBox.height / 2 + min;\n\n    if (targetPoint.y > sourcePoint.y) {\n      if (targetY <= sourceY) {\n        source.y = Math.max(targetY, sourcePoint.y + _sourceDelta);\n        target.y = Math.min(sourceY, targetPoint.y - _targetDelta);\n      }\n    } else if (targetY >= sourceY) {\n      source.y = Math.min(targetY, sourcePoint.y - _sourceDelta);\n      target.y = Math.max(sourceY, targetPoint.y + _targetDelta);\n    }\n  }\n\n  return [source.toJSON()].concat(_toConsumableArray(vertices), [target.toJSON()]);\n};","map":null,"metadata":{},"sourceType":"module"}