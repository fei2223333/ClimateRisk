{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Line } from './line';\nimport { Geometry } from './geometry';\nexport var Polyline = /*#__PURE__*/function (_Geometry) {\n  _inherits(Polyline, _Geometry);\n\n  function Polyline(points) {\n    var _this;\n\n    _classCallCheck(this, Polyline);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this));\n\n    if (points != null) {\n      if (typeof points === 'string') {\n        return _possibleConstructorReturn(_this, Polyline.parse(points));\n      }\n\n      _this.points = points.map(function (p) {\n        return Point.create(p);\n      });\n    } else {\n      _this.points = [];\n    }\n\n    return _this;\n  }\n\n  _createClass(Polyline, [{\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n      this.points.forEach(function (p) {\n        return p.scale(sx, sy, origin);\n      });\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.points.forEach(function (p) {\n        return p.rotate(angle, origin);\n      });\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(dx, dy) {\n      var t = Point.create(dx, dy);\n      this.points.forEach(function (p) {\n        return p.translate(t.x, t.y);\n      });\n      return this;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      if (this.points.length === 0) {\n        return new Rectangle();\n      }\n\n      var x1 = Infinity;\n      var x2 = -Infinity;\n      var y1 = Infinity;\n      var y2 = -Infinity;\n      var points = this.points;\n\n      for (var i = 0, ii = points.length; i < ii; i += 1) {\n        var point = points[i];\n        var x = point.x;\n        var y = point.y;\n        if (x < x1) x1 = x;\n        if (x > x2) x2 = x;\n        if (y < y1) y1 = y;\n        if (y > y2) y2 = y;\n      }\n\n      return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      var cpLength = this.closestPointLength(p);\n      return this.pointAtLength(cpLength);\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0 || count === 1) {\n        return 0;\n      }\n\n      var length = 0;\n      var cpLength = 0;\n      var minSqrDistance = Infinity;\n\n      for (var i = 0, ii = count - 1; i < ii; i += 1) {\n        var line = new Line(points[i], points[i + 1]);\n        var lineLength = line.length();\n        var cpNormalizedLength = line.closestPointNormalizedLength(p);\n        var cp = line.pointAt(cpNormalizedLength);\n        var sqrDistance = cp.squaredDistance(p);\n\n        if (sqrDistance < minSqrDistance) {\n          minSqrDistance = sqrDistance;\n          cpLength = length + cpNormalizedLength * lineLength;\n        }\n\n        length += lineLength;\n      }\n\n      return cpLength;\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      var cpLength = this.closestPointLength(p);\n\n      if (cpLength === 0) {\n        return 0;\n      }\n\n      var length = this.length();\n\n      if (length === 0) {\n        return 0;\n      }\n\n      return cpLength / length;\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      var cpLength = this.closestPointLength(p);\n      return this.tangentAtLength(cpLength);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      if (this.points.length === 0) {\n        return false;\n      }\n\n      var ref = Point.clone(p);\n      var x = ref.x;\n      var y = ref.y;\n      var points = this.points;\n      var count = points.length;\n      var startIndex = count - 1;\n      var intersectionCount = 0;\n\n      for (var endIndex = 0; endIndex < count; endIndex += 1) {\n        var start = points[startIndex];\n        var end = points[endIndex];\n\n        if (ref.equals(start)) {\n          return true;\n        }\n\n        var segment = new Line(start, end);\n\n        if (segment.containsPoint(p)) {\n          return true;\n        } // do we have an intersection?\n\n\n        if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n          // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n          // (when `y === start.y === end.y`)\n          // this conditional branch IS entered when `segment` touches `ray` at only one point\n          // (e.g. when `y === start.y !== end.y`)\n          // since this branch is entered again for the following segment, the two touches cancel out\n          var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\n          if (xDifference >= 0) {\n            // segment lies at least partially to the right of `p`\n            var rayEnd = new Point(x + xDifference, y); // right\n\n            var ray = new Line(p, rayEnd);\n\n            if (segment.intersectsWithLine(ray)) {\n              // an intersection was detected to the right of `p`\n              intersectionCount += 1;\n            }\n          } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\n        } // move to check the next polyline segment\n\n\n        startIndex = endIndex;\n      } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n      return intersectionCount % 2 === 1;\n    }\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var intersections = [];\n\n      for (var i = 0, n = this.points.length - 1; i < n; i += 1) {\n        var a = this.points[i];\n        var b = this.points[i + 1];\n        var int = line.intersectsWithLine(new Line(a, b));\n\n        if (int) {\n          intersections.push(int);\n        }\n      }\n\n      return intersections.length > 0 ? intersections : null;\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      for (var i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n        var a = this.points[i];\n        var b = this.points[i + 1];\n        var line = new Line(a, b);\n\n        if (line.isDifferentiable()) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var len = 0;\n\n      for (var i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n        var a = this.points[i];\n        var b = this.points[i + 1];\n        len += a.distance(b);\n      }\n\n      return len;\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      if (count === 1) {\n        return points[0].clone();\n      }\n\n      if (ratio <= 0) {\n        return points[0].clone();\n      }\n\n      if (ratio >= 1) {\n        return points[count - 1].clone();\n      }\n\n      var total = this.length();\n      var length = total * ratio;\n      return this.pointAtLength(length);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      if (count === 1) {\n        return points[0].clone();\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var tmp = 0;\n\n      for (var i = 0, ii = count - 1; i < ii; i += 1) {\n        var index = fromStart ? i : ii - 1 - i;\n        var a = points[index];\n        var b = points[index + 1];\n        var l = new Line(a, b);\n        var d = a.distance(b);\n\n        if (length <= tmp + d) {\n          return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));\n        }\n\n        tmp += d;\n      }\n\n      var lastPoint = fromStart ? points[count - 1] : points[0];\n      return lastPoint.clone();\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0 || count === 1) {\n        return null;\n      }\n\n      if (ratio < 0) {\n        ratio = 0; // eslint-disable-line\n      }\n\n      if (ratio > 1) {\n        ratio = 1; // eslint-disable-line\n      }\n\n      var total = this.length();\n      var length = total * ratio;\n      return this.tangentAtLength(length);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0 || count === 1) {\n        return null;\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var lastValidLine;\n      var tmp = 0;\n\n      for (var i = 0, ii = count - 1; i < ii; i += 1) {\n        var index = fromStart ? i : ii - 1 - i;\n        var a = points[index];\n        var b = points[index + 1];\n        var l = new Line(a, b);\n        var d = a.distance(b);\n\n        if (l.isDifferentiable()) {\n          // has a tangent line (line length is not 0)\n          if (length <= tmp + d) {\n            return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));\n          }\n\n          lastValidLine = l;\n        }\n\n        tmp += d;\n      }\n\n      if (lastValidLine) {\n        var ratio = fromStart ? 1 : 0;\n        return lastValidLine.tangentAt(ratio);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"simplify\",\n    value: function simplify() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var points = this.points; // we need at least 3 points\n\n      if (points.length < 3) {\n        return this;\n      }\n\n      var threshold = options.threshold || 0; // start at the beginning of the polyline and go forward\n\n      var currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration\n      // as soon as that stops being true, we know we reached the end of the polyline\n\n      while (points[currentIndex + 2]) {\n        var firstIndex = currentIndex;\n        var middleIndex = currentIndex + 1;\n        var lastIndex = currentIndex + 2;\n        var firstPoint = points[firstIndex];\n        var middlePoint = points[middleIndex];\n        var lastPoint = points[lastIndex];\n        var chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\n        var closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\n        var closestPointDistance = closestPoint.distance(middlePoint);\n\n        if (closestPointDistance <= threshold) {\n          // middle point is close enough to the chord = simplify\n          // 1) remove middle point:\n          points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points\n          //    - do not change `currentIndex`\n          //    = (first point stays, point after removed point becomes middle point)\n        } else {\n          // middle point is far from the chord\n          // 1) preserve middle point\n          // 2) in next iteration, move `currentIndex` by one step:\n          currentIndex += 1; //    = (point after first point becomes first point)\n        }\n      } // `points` array was modified in-place\n\n\n      return this;\n    }\n  }, {\n    key: \"toHull\",\n    value: function toHull() {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0) {\n        return new Polyline();\n      } // Step 1: find the starting point -- point with\n      // the lowest y (if equality, highest x).\n\n\n      var startPoint = points[0];\n\n      for (var i = 1; i < count; i += 1) {\n        if (points[i].y < startPoint.y) {\n          startPoint = points[i];\n        } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n          startPoint = points[i];\n        }\n      } // Step 2: sort the list of points by angle between line\n      // from start point to current point and the x-axis (theta).\n      // Step 2a: create the point records = [point, originalIndex, angle]\n\n\n      var sortedRecords = [];\n\n      for (var _i = 0; _i < count; _i += 1) {\n        var angle = startPoint.theta(points[_i]);\n\n        if (angle === 0) {\n          // Give highest angle to start point.\n          // The start point will end up at end of sorted list.\n          // The start point will end up at beginning of hull points list.\n          angle = 360;\n        }\n\n        sortedRecords.push([points[_i], _i, angle]);\n      } // Step 2b: sort the list in place\n\n\n      sortedRecords.sort(function (record1, record2) {\n        var ret = record1[2] - record2[2];\n\n        if (ret === 0) {\n          ret = record2[1] - record1[1];\n        }\n\n        return ret;\n      }); // Step 2c: duplicate start record from the top of\n      // the stack to the bottom of the stack.\n\n      if (sortedRecords.length > 2) {\n        var _startPoint = sortedRecords[sortedRecords.length - 1];\n        sortedRecords.unshift(_startPoint);\n      } // Step 3\n      // ------\n      // Step 3a: go through sorted points in order and find those with\n      // right turns, and we want to get our results in clockwise order.\n      // Dictionary of points with left turns - cannot be on the hull.\n\n\n      var insidePoints = {}; // Stack of records with right turns - hull point candidates.\n\n      var hullRecords = [];\n\n      var getKey = function getKey(record) {\n        return \"\".concat(record[0].toString(), \"@\").concat(record[1]);\n      };\n\n      while (sortedRecords.length !== 0) {\n        var currentRecord = sortedRecords.pop();\n        var currentPoint = currentRecord[0]; // Check if point has already been discarded.\n\n        if (insidePoints[getKey(currentRecord)]) {\n          continue;\n        }\n\n        var correctTurnFound = false;\n\n        while (!correctTurnFound) {\n          if (hullRecords.length < 2) {\n            // Not enough points for comparison, just add current point.\n            hullRecords.push(currentRecord);\n            correctTurnFound = true;\n          } else {\n            var lastHullRecord = hullRecords.pop();\n            var lastHullPoint = lastHullRecord[0];\n            var secondLastHullRecord = hullRecords.pop();\n            var secondLastHullPoint = secondLastHullRecord[0];\n            var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n            if (crossProduct < 0) {\n              // Found a right turn.\n              hullRecords.push(secondLastHullRecord);\n              hullRecords.push(lastHullRecord);\n              hullRecords.push(currentRecord);\n              correctTurnFound = true;\n            } else if (crossProduct === 0) {\n              // the three points are collinear\n              // three options:\n              // there may be a 180 or 0 degree angle at lastHullPoint\n              // or two of the three points are coincident\n              // we have to take rounding errors into account\n              var THRESHOLD = 1e-10;\n              var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\n              if (Math.abs(angleBetween - 180) < THRESHOLD) {\n                // rouding around 180 to 180\n                // if the cross product is 0 because the angle is 180 degrees\n                // discard last hull point (add to insidePoints)\n                // insidePoints.unshift(lastHullPoint);\n                insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n                hullRecords.push(secondLastHullRecord); // do not do anything with current point\n                // correct turn not found\n              } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                // if the cross product is 0 because two points are the same\n                // discard last hull point (add to insidePoints)\n                // insidePoints.unshift(lastHullPoint);\n                insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n                hullRecords.push(secondLastHullRecord); // do not do anything with current point\n                // correct turn not found\n              } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n                // rounding around 0 and 360 to 0\n                // if the cross product is 0 because the angle is 0 degrees\n                // remove last hull point from hull BUT do not discard it\n                // reenter second-to-last hull point (will be last at next iter)\n                hullRecords.push(secondLastHullRecord); // put last hull point back into the sorted point records list\n\n                sortedRecords.push(lastHullRecord); // we are switching the order of the 0deg and 180deg points\n                // correct turn not found\n              }\n            } else {\n              // found a left turn\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)\n\n              hullRecords.push(secondLastHullRecord); // do not do anything with current point\n              // correct turn not found\n            }\n          }\n        }\n      } // At this point, hullPointRecords contains the output points in clockwise order\n      // the points start with lowest-y,highest-x startPoint, and end at the same point\n      // Step 3b: remove duplicated startPointRecord from the end of the array\n\n\n      if (hullRecords.length > 2) {\n        hullRecords.pop();\n      } // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n\n\n      var lowestHullIndex; // the lowest originalIndex on the hull\n\n      var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\n      for (var _i2 = 0, n = hullRecords.length; _i2 < n; _i2 += 1) {\n        var currentHullIndex = hullRecords[_i2][1];\n\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n          lowestHullIndex = currentHullIndex;\n          indexOfLowestHullIndexRecord = _i2;\n        }\n      }\n\n      var hullPointRecordsReordered = [];\n\n      if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n      } else {\n        hullPointRecordsReordered = hullRecords;\n      }\n\n      var hullPoints = [];\n\n      for (var _i3 = 0, _n = hullPointRecordsReordered.length; _i3 < _n; _i3 += 1) {\n        hullPoints.push(hullPointRecordsReordered[_i3][0]);\n      }\n\n      return new Polyline(hullPoints);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      var _this2 = this;\n\n      if (p == null) {\n        return false;\n      }\n\n      if (p.points.length !== this.points.length) {\n        return false;\n      }\n\n      return p.points.every(function (a, i) {\n        return a.equals(_this2.points[i]);\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Polyline(this.points.map(function (p) {\n        return p.clone();\n      }));\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.points.map(function (p) {\n        return p.toJSON();\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return this.points.map(function (p) {\n        return \"\".concat(p.x, \", \").concat(p.y);\n      }).join(' ');\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Polyline.toStringTag;\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      if (this.points.length === 0) {\n        return null;\n      }\n\n      return this.points[0];\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      if (this.points.length === 0) {\n        return null;\n      }\n\n      return this.points[this.points.length - 1];\n    }\n  }]);\n\n  return Polyline;\n}(Geometry);\n\n(function (Polyline) {\n  Polyline.toStringTag = \"X6.Geometry.\".concat(Polyline.name);\n\n  function isPolyline(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Polyline) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var polyline = instance;\n\n    if ((tag == null || tag === Polyline.toStringTag) && typeof polyline.toHull === 'function' && typeof polyline.simplify === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Polyline.isPolyline = isPolyline;\n})(Polyline || (Polyline = {}));\n\n(function (Polyline) {\n  function parse(svgString) {\n    var str = svgString.trim();\n\n    if (str === '') {\n      return new Polyline();\n    }\n\n    var points = [];\n    var coords = str.split(/\\s*,\\s*|\\s+/);\n\n    for (var i = 0, ii = coords.length; i < ii; i += 2) {\n      points.push({\n        x: +coords[i],\n        y: +coords[i + 1]\n      });\n    }\n\n    return new Polyline(points);\n  }\n\n  Polyline.parse = parse;\n})(Polyline || (Polyline = {}));","map":null,"metadata":{},"sourceType":"module"}