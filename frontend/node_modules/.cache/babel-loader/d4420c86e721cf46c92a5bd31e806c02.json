{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { FunctionExt } from '../util';\nimport { Basecoat, Dijkstra } from '../common';\nimport { Rectangle } from '../geometry';\nimport { Cell } from './cell';\nimport { Edge } from './edge';\nimport { Node } from './node';\nimport { Collection } from './collection';\nexport var Model = /*#__PURE__*/function (_Basecoat) {\n  _inherits(Model, _Basecoat);\n\n  function Model() {\n    var _this;\n\n    var cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Model);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Model).call(this));\n    _this.batches = {};\n    _this.addings = new WeakMap();\n    _this.nodes = {};\n    _this.edges = {};\n    _this.outgoings = {};\n    _this.incomings = {};\n    _this.collection = new Collection(cells);\n\n    _this.setup();\n\n    return _this;\n  }\n\n  _createClass(Model, [{\n    key: \"notify\",\n    value: function notify(name, args) {\n      this.trigger(name, args);\n      var graph = this.graph;\n\n      if (graph) {\n        if (name === 'sorted' || name === 'reseted' || name === 'updated') {\n          graph.trigger(\"model:\".concat(name), args);\n        } else {\n          graph.trigger(name, args);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this2 = this;\n\n      var collection = this.collection;\n      collection.on('sorted', function () {\n        return _this2.notify('sorted', null);\n      });\n      collection.on('updated', function (args) {\n        return _this2.notify('updated', args);\n      });\n      collection.on('cell:change:zIndex', function () {\n        return _this2.sortOnChangeZ();\n      });\n      collection.on('added', function (_ref) {\n        var cell = _ref.cell;\n\n        _this2.onCellAdded(cell);\n      });\n      collection.on('removed', function (args) {\n        var cell = args.cell;\n\n        _this2.onCellRemoved(cell, args.options); // Should trigger remove-event manually after cell was removed.\n\n\n        _this2.notify('cell:removed', args);\n\n        if (cell.isNode()) {\n          _this2.notify('node:removed', Object.assign(Object.assign({}, args), {\n            node: cell\n          }));\n        } else if (cell.isEdge()) {\n          _this2.notify('edge:removed', Object.assign(Object.assign({}, args), {\n            edge: cell\n          }));\n        }\n      });\n      collection.on('reseted', function (args) {\n        _this2.onReset(args.current);\n\n        _this2.notify('reseted', args);\n      });\n      collection.on('edge:change:source', function (_ref2) {\n        var edge = _ref2.edge;\n        return _this2.onEdgeTerminalChanged(edge, 'source');\n      });\n      collection.on('edge:change:target', function (_ref3) {\n        var edge = _ref3.edge;\n\n        _this2.onEdgeTerminalChanged(edge, 'target');\n      });\n    }\n  }, {\n    key: \"sortOnChangeZ\",\n    value: function sortOnChangeZ() {\n      this.collection.sort();\n    }\n  }, {\n    key: \"onCellAdded\",\n    value: function onCellAdded(cell) {\n      var cellId = cell.id;\n\n      if (cell.isEdge()) {\n        // Auto update edge's parent\n        cell.updateParent();\n        this.edges[cellId] = true;\n        this.onEdgeTerminalChanged(cell, 'source');\n        this.onEdgeTerminalChanged(cell, 'target');\n      } else {\n        this.nodes[cellId] = true;\n      }\n    }\n  }, {\n    key: \"onCellRemoved\",\n    value: function onCellRemoved(cell, options) {\n      var cellId = cell.id;\n\n      if (cell.isEdge()) {\n        delete this.edges[cellId];\n        var source = cell.getSource();\n        var target = cell.getTarget();\n\n        if (source && source.cell) {\n          var cache = this.outgoings[source.cell];\n          var index = cache ? cache.indexOf(cellId) : -1;\n\n          if (index >= 0) {\n            cache.splice(index, 1);\n\n            if (cache.length === 0) {\n              delete this.outgoings[source.cell];\n            }\n          }\n        }\n\n        if (target && target.cell) {\n          var _cache = this.incomings[target.cell];\n\n          var _index = _cache ? _cache.indexOf(cellId) : -1;\n\n          if (_index >= 0) {\n            _cache.splice(_index, 1);\n\n            if (_cache.length === 0) {\n              delete this.incomings[target.cell];\n            }\n          }\n        }\n      } else {\n        delete this.nodes[cellId];\n      }\n\n      if (!options.clear) {\n        if (options.disconnectEdges) {\n          this.disconnectConnectedEdges(cell, options);\n        } else {\n          this.removeConnectedEdges(cell, options);\n        }\n      }\n\n      if (cell.model === this) {\n        cell.model = null;\n      }\n    }\n  }, {\n    key: \"onReset\",\n    value: function onReset(cells) {\n      var _this3 = this;\n\n      this.nodes = {};\n      this.edges = {};\n      this.outgoings = {};\n      this.incomings = {};\n      cells.forEach(function (cell) {\n        return _this3.onCellAdded(cell);\n      });\n    }\n  }, {\n    key: \"onEdgeTerminalChanged\",\n    value: function onEdgeTerminalChanged(edge, type) {\n      var ref = type === 'source' ? this.outgoings : this.incomings;\n      var prev = edge.previous(type);\n\n      if (prev && prev.cell) {\n        var cache = ref[prev.cell];\n        var index = cache ? cache.indexOf(edge.id) : -1;\n\n        if (index >= 0) {\n          cache.splice(index, 1);\n\n          if (cache.length === 0) {\n            delete ref[prev.cell];\n          }\n        }\n      }\n\n      var terminal = edge.getTerminal(type);\n\n      if (terminal && terminal.cell) {\n        var _cache2 = ref[terminal.cell] || [];\n\n        var _index2 = _cache2.indexOf(edge.id);\n\n        if (_index2 === -1) {\n          _cache2.push(edge.id);\n        }\n\n        ref[terminal.cell] = _cache2;\n      }\n    }\n  }, {\n    key: \"prepareCell\",\n    value: function prepareCell(cell, options) {\n      if (!cell.model && (!options || !options.dryrun)) {\n        cell.model = this;\n      }\n\n      if (cell.zIndex == null) {\n        cell.setZIndex(this.getMaxZIndex() + 1, {\n          silent: true\n        });\n      }\n\n      return cell;\n    }\n  }, {\n    key: \"resetCells\",\n    value: function resetCells(cells) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Do not update model at this time. Because if we just update the graph\n      // with the same json-data, the edge will reference to the old nodes.\n      cells.map(function (cell) {\n        return _this4.prepareCell(cell, Object.assign(Object.assign({}, options), {\n          dryrun: true\n        }));\n      });\n      this.collection.reset(cells, options); // Update model and trigger edge update it's references\n\n      cells.map(function (cell) {\n        return _this4.prepareCell(cell, {\n          options: options\n        });\n      });\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var raw = this.getCells();\n\n      if (raw.length === 0) {\n        return this;\n      }\n\n      var localOptions = Object.assign(Object.assign({}, options), {\n        clear: true\n      });\n      this.batchUpdate('clear', function () {\n        // The nodes come after the edges.\n        var cells = raw.sort(function (a, b) {\n          var v1 = a.isEdge() ? 1 : 2;\n          var v2 = b.isEdge() ? 1 : 2;\n          return v1 - v2;\n        });\n\n        while (cells.length > 0) {\n          // Note that all the edges are removed first, so it's safe to\n          // remove the nodes without removing the connected edges first.\n          var cell = cells.shift();\n\n          if (cell) {\n            cell.remove(localOptions);\n          }\n        }\n      }, localOptions);\n      return this;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(metadata) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var node = Node.isNode(metadata) ? metadata : this.createNode(metadata);\n      this.addCell(node, options);\n      return node;\n    }\n  }, {\n    key: \"createNode\",\n    value: function createNode(metadata) {\n      return Node.create(metadata);\n    }\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(metadata) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);\n      this.addCell(edge, options);\n      return edge;\n    }\n  }, {\n    key: \"createEdge\",\n    value: function createEdge(metadata) {\n      return Edge.create(metadata);\n    }\n  }, {\n    key: \"addCell\",\n    value: function addCell(cell) {\n      var _this5 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Array.isArray(cell)) {\n        return this.addCells(cell, options);\n      }\n\n      if (!this.collection.has(cell) && !this.addings.has(cell)) {\n        this.addings.set(cell, true);\n        this.collection.add(this.prepareCell(cell, options), options);\n        cell.eachChild(function (child) {\n          return _this5.addCell(child, options);\n        });\n        this.addings.delete(cell);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addCells\",\n    value: function addCells(cells) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var count = cells.length;\n\n      if (count === 0) {\n        return this;\n      }\n\n      var localOptions = Object.assign(Object.assign({}, options), {\n        position: count - 1,\n        maxPosition: count - 1\n      });\n      this.startBatch('add', Object.assign(Object.assign({}, localOptions), {\n        cells: cells\n      }));\n      cells.forEach(function (cell) {\n        _this6.addCell(cell, localOptions);\n\n        localOptions.position -= 1;\n      });\n      this.stopBatch('add', Object.assign(Object.assign({}, localOptions), {\n        cells: cells\n      }));\n      return this;\n    }\n  }, {\n    key: \"removeCell\",\n    value: function removeCell(obj) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cell = typeof obj === 'string' ? this.getCell(obj) : obj;\n\n      if (cell && this.has(cell)) {\n        return this.collection.remove(cell, options);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"updateCellId\",\n    value: function updateCellId(cell, newId) {\n      this.startBatch('update', {\n        id: newId\n      });\n      cell.prop('id', newId);\n      var newCell = cell.clone({\n        keepId: true\n      });\n      this.addCell(newCell); // update connected edge terminal\n\n      var edges = this.getConnectedEdges(cell);\n      edges.forEach(function (edge) {\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (sourceCell === cell) {\n          edge.setSource(Object.assign(Object.assign({}, edge.getSource()), {\n            cell: newId\n          }));\n        }\n\n        if (targetCell === cell) {\n          edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {\n            cell: newId\n          }));\n        }\n      });\n      this.removeCell(cell);\n      this.stopBatch('update', {\n        id: newId\n      });\n      return newCell;\n    }\n  }, {\n    key: \"removeCells\",\n    value: function removeCells(cells) {\n      var _this7 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (cells.length) {\n        return this.batchUpdate('remove', function () {\n          return cells.map(function (cell) {\n            return _this7.removeCell(cell, options);\n          });\n        });\n      }\n\n      return [];\n    }\n  }, {\n    key: \"removeConnectedEdges\",\n    value: function removeConnectedEdges(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var edges = this.getConnectedEdges(cell);\n      edges.forEach(function (edge) {\n        edge.remove(options);\n      });\n      return edges;\n    }\n  }, {\n    key: \"disconnectConnectedEdges\",\n    value: function disconnectConnectedEdges(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cellId = typeof cell === 'string' ? cell : cell.id;\n      this.getConnectedEdges(cell).forEach(function (edge) {\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (sourceCell && sourceCell.id === cellId) {\n          edge.setSource({\n            x: 0,\n            y: 0\n          }, options);\n        }\n\n        if (targetCell && targetCell.id === cellId) {\n          edge.setTarget({\n            x: 0,\n            y: 0\n          }, options);\n        }\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(obj) {\n      return this.collection.has(obj);\n    }\n  }, {\n    key: \"total\",\n    value: function total() {\n      return this.collection.length;\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(cell) {\n      return this.collection.indexOf(cell);\n    }\n    /**\n     * Returns a cell from the graph by its id.\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(id) {\n      return this.collection.get(id);\n    }\n    /**\n     * Returns all the nodes and edges in the graph.\n     */\n\n  }, {\n    key: \"getCells\",\n    value: function getCells() {\n      return this.collection.toArray();\n    }\n    /**\n     * Returns the first cell (node or edge) in the graph. The first cell is\n     * defined as the cell with the lowest `zIndex`.\n     */\n\n  }, {\n    key: \"getFirstCell\",\n    value: function getFirstCell() {\n      return this.collection.first();\n    }\n    /**\n     * Returns the last cell (node or edge) in the graph. The last cell is\n     * defined as the cell with the highest `zIndex`.\n     */\n\n  }, {\n    key: \"getLastCell\",\n    value: function getLastCell() {\n      return this.collection.last();\n    }\n    /**\n     * Returns the lowest `zIndex` value in the graph.\n     */\n\n  }, {\n    key: \"getMinZIndex\",\n    value: function getMinZIndex() {\n      var first = this.collection.first();\n      return first ? first.getZIndex() || 0 : 0;\n    }\n    /**\n     * Returns the highest `zIndex` value in the graph.\n     */\n\n  }, {\n    key: \"getMaxZIndex\",\n    value: function getMaxZIndex() {\n      var last = this.collection.last();\n      return last ? last.getZIndex() || 0 : 0;\n    }\n  }, {\n    key: \"getCellsFromCache\",\n    value: function getCellsFromCache(cache) {\n      var _this8 = this;\n\n      return cache ? Object.keys(cache).map(function (id) {\n        return _this8.getCell(id);\n      }).filter(function (cell) {\n        return cell != null;\n      }) : [];\n    }\n    /**\n     * Returns all the nodes in the graph.\n     */\n\n  }, {\n    key: \"getNodes\",\n    value: function getNodes() {\n      return this.getCellsFromCache(this.nodes);\n    }\n    /**\n     * Returns all the edges in the graph.\n     */\n\n  }, {\n    key: \"getEdges\",\n    value: function getEdges() {\n      return this.getCellsFromCache(this.edges);\n    }\n    /**\n     * Returns all outgoing edges for the node.\n     */\n\n  }, {\n    key: \"getOutgoingEdges\",\n    value: function getOutgoingEdges(cell) {\n      var _this9 = this;\n\n      var cellId = typeof cell === 'string' ? cell : cell.id;\n      var cellIds = this.outgoings[cellId];\n      return cellIds ? cellIds.map(function (id) {\n        return _this9.getCell(id);\n      }).filter(function (cell) {\n        return cell && cell.isEdge();\n      }) : null;\n    }\n    /**\n     * Returns all incoming edges for the node.\n     */\n\n  }, {\n    key: \"getIncomingEdges\",\n    value: function getIncomingEdges(cell) {\n      var _this10 = this;\n\n      var cellId = typeof cell === 'string' ? cell : cell.id;\n      var cellIds = this.incomings[cellId];\n      return cellIds ? cellIds.map(function (id) {\n        return _this10.getCell(id);\n      }).filter(function (cell) {\n        return cell && cell.isEdge();\n      }) : null;\n    }\n    /**\n     * Returns edges connected with cell.\n     */\n\n  }, {\n    key: \"getConnectedEdges\",\n    value: function getConnectedEdges(cell) {\n      var _this11 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var result = [];\n      var node = typeof cell === 'string' ? this.getCell(cell) : cell;\n\n      if (node == null) {\n        return result;\n      }\n\n      var cache = {};\n      var indirect = options.indirect;\n      var incoming = options.incoming;\n      var outgoing = options.outgoing;\n\n      if (incoming == null && outgoing == null) {\n        incoming = outgoing = true;\n      }\n\n      var collect = function collect(cell, isOutgoing) {\n        var edges = isOutgoing ? _this11.getOutgoingEdges(cell) : _this11.getIncomingEdges(cell);\n\n        if (edges != null) {\n          edges.forEach(function (edge) {\n            if (cache[edge.id]) {\n              return;\n            }\n\n            result.push(edge);\n            cache[edge.id] = true;\n\n            if (indirect) {\n              if (incoming) {\n                collect(edge, false);\n              }\n\n              if (outgoing) {\n                collect(edge, true);\n              }\n            }\n          });\n        }\n\n        if (indirect && cell.isEdge()) {\n          var terminal = isOutgoing ? cell.getTargetCell() : cell.getSourceCell();\n\n          if (terminal && terminal.isEdge()) {\n            if (!cache[terminal.id]) {\n              result.push(terminal);\n              collect(terminal, isOutgoing);\n            }\n          }\n        }\n      };\n\n      if (outgoing) {\n        collect(node, true);\n      }\n\n      if (incoming) {\n        collect(node, false);\n      }\n\n      if (options.deep) {\n        var descendants = node.getDescendants({\n          deep: true\n        });\n        var embedsCache = {};\n        descendants.forEach(function (cell) {\n          if (cell.isNode()) {\n            embedsCache[cell.id] = true;\n          }\n        });\n\n        var collectSub = function collectSub(cell, isOutgoing) {\n          var edges = isOutgoing ? _this11.getOutgoingEdges(cell.id) : _this11.getIncomingEdges(cell.id);\n\n          if (edges != null) {\n            edges.forEach(function (edge) {\n              if (!cache[edge.id]) {\n                var sourceCell = edge.getSourceCell();\n                var targetCell = edge.getTargetCell();\n\n                if (!options.enclosed && sourceCell && embedsCache[sourceCell.id] && targetCell && embedsCache[targetCell.id]) {\n                  return;\n                }\n\n                result.push(edge);\n                cache[edge.id] = true;\n              }\n            });\n          }\n        };\n\n        descendants.forEach(function (cell) {\n          if (cell.isEdge()) {\n            return;\n          }\n\n          if (outgoing) {\n            collectSub(cell, true);\n          }\n\n          if (incoming) {\n            collectSub(cell, false);\n          }\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"isBoundary\",\n    value: function isBoundary(cell, isOrigin) {\n      var node = typeof cell === 'string' ? this.getCell(cell) : cell;\n      var arr = isOrigin ? this.getIncomingEdges(node) : this.getOutgoingEdges(node);\n      return arr == null || arr.length === 0;\n    }\n  }, {\n    key: \"getBoundaryNodes\",\n    value: function getBoundaryNodes(isOrigin) {\n      var _this12 = this;\n\n      var result = [];\n      Object.keys(this.nodes).forEach(function (nodeId) {\n        if (_this12.isBoundary(nodeId, isOrigin)) {\n          var node = _this12.getCell(nodeId);\n\n          if (node) {\n            result.push(node);\n          }\n        }\n      });\n      return result;\n    }\n    /**\n     * Returns an array of all the roots of the graph.\n     */\n\n  }, {\n    key: \"getRoots\",\n    value: function getRoots() {\n      return this.getBoundaryNodes(true);\n    }\n    /**\n     * Returns an array of all the leafs of the graph.\n     */\n\n  }, {\n    key: \"getLeafs\",\n    value: function getLeafs() {\n      return this.getBoundaryNodes(false);\n    }\n    /**\n     * Returns `true` if the node is a root node, i.e. there is no edges\n     * coming to the node.\n     */\n\n  }, {\n    key: \"isRoot\",\n    value: function isRoot(cell) {\n      return this.isBoundary(cell, true);\n    }\n    /**\n     * Returns `true` if the node is a leaf node, i.e. there is no edges\n     * going out from the node.\n     */\n\n  }, {\n    key: \"isLeaf\",\n    value: function isLeaf(cell) {\n      return this.isBoundary(cell, false);\n    }\n    /**\n     * Returns all the neighbors of node in the graph. Neighbors are all\n     * the nodes connected to node via either incoming or outgoing edge.\n     */\n\n  }, {\n    key: \"getNeighbors\",\n    value: function getNeighbors(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var incoming = options.incoming;\n      var outgoing = options.outgoing;\n\n      if (incoming == null && outgoing == null) {\n        incoming = outgoing = true;\n      }\n\n      var edges = this.getConnectedEdges(cell, options);\n      var map = edges.reduce(function (memo, edge) {\n        var hasLoop = edge.hasLoop(options);\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (incoming && sourceCell && sourceCell.isNode() && !memo[sourceCell.id]) {\n          if (hasLoop || sourceCell !== cell && (!options.deep || !sourceCell.isDescendantOf(cell))) {\n            memo[sourceCell.id] = sourceCell;\n          }\n        }\n\n        if (outgoing && targetCell && targetCell.isNode() && !memo[targetCell.id]) {\n          if (hasLoop || targetCell !== cell && (!options.deep || !targetCell.isDescendantOf(cell))) {\n            memo[targetCell.id] = targetCell;\n          }\n        }\n\n        return memo;\n      }, {});\n\n      if (cell.isEdge()) {\n        if (incoming) {\n          var sourceCell = cell.getSourceCell();\n\n          if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {\n            map[sourceCell.id] = sourceCell;\n          }\n        }\n\n        if (outgoing) {\n          var targetCell = cell.getTargetCell();\n\n          if (targetCell && targetCell.isNode() && !map[targetCell.id]) {\n            map[targetCell.id] = targetCell;\n          }\n        }\n      }\n\n      return Object.keys(map).map(function (id) {\n        return map[id];\n      });\n    }\n    /**\n     * Returns `true` if `cell2` is a neighbor of `cell1`.\n     */\n\n  }, {\n    key: \"isNeighbor\",\n    value: function isNeighbor(cell1, cell2) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var incoming = options.incoming;\n      var outgoing = options.outgoing;\n\n      if (incoming == null && outgoing == null) {\n        incoming = outgoing = true;\n      }\n\n      return this.getConnectedEdges(cell1, options).some(function (edge) {\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (incoming && sourceCell && sourceCell.id === cell2.id) {\n          return true;\n        }\n\n        if (outgoing && targetCell && targetCell.id === cell2.id) {\n          return true;\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"getSuccessors\",\n    value: function getSuccessors(cell) {\n      var _this13 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successors = [];\n      this.search(cell, function (curr, distance) {\n        if (curr !== cell && _this13.matchDistance(distance, options.distance)) {\n          successors.push(curr);\n        }\n      }, Object.assign(Object.assign({}, options), {\n        outgoing: true\n      }));\n      return successors;\n    }\n    /**\n     * Returns `true` if `cell2` is a successor of `cell1`.\n     */\n\n  }, {\n    key: \"isSuccessor\",\n    value: function isSuccessor(cell1, cell2) {\n      var _this14 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var result = false;\n      this.search(cell1, function (curr, distance) {\n        if (curr === cell2 && curr !== cell1 && _this14.matchDistance(distance, options.distance)) {\n          result = true;\n          return false;\n        }\n      }, Object.assign(Object.assign({}, options), {\n        outgoing: true\n      }));\n      return result;\n    }\n  }, {\n    key: \"getPredecessors\",\n    value: function getPredecessors(cell) {\n      var _this15 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var predecessors = [];\n      this.search(cell, function (curr, distance) {\n        if (curr !== cell && _this15.matchDistance(distance, options.distance)) {\n          predecessors.push(curr);\n        }\n      }, Object.assign(Object.assign({}, options), {\n        incoming: true\n      }));\n      return predecessors;\n    }\n    /**\n     * Returns `true` if `cell2` is a predecessor of `cell1`.\n     */\n\n  }, {\n    key: \"isPredecessor\",\n    value: function isPredecessor(cell1, cell2) {\n      var _this16 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var result = false;\n      this.search(cell1, function (curr, distance) {\n        if (curr === cell2 && curr !== cell1 && _this16.matchDistance(distance, options.distance)) {\n          result = true;\n          return false;\n        }\n      }, Object.assign(Object.assign({}, options), {\n        incoming: true\n      }));\n      return result;\n    }\n  }, {\n    key: \"matchDistance\",\n    value: function matchDistance(distance, preset) {\n      if (preset == null) {\n        return true;\n      }\n\n      if (typeof preset === 'function') {\n        return preset(distance);\n      }\n\n      if (Array.isArray(preset) && preset.includes(distance)) {\n        return true;\n      }\n\n      return distance === preset;\n    }\n    /**\n     * Returns the common ancestor of the passed cells.\n     */\n\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor() {\n      var arr = [];\n\n      for (var _len = arguments.length, cells = new Array(_len), _key = 0; _key < _len; _key++) {\n        cells[_key] = arguments[_key];\n      }\n\n      cells.forEach(function (item) {\n        if (item) {\n          if (Array.isArray(item)) {\n            arr.push.apply(arr, _toConsumableArray(item));\n          } else {\n            arr.push(item);\n          }\n        }\n      });\n      return Cell.getCommonAncestor.apply(Cell, arr);\n    }\n    /**\n     * Returns an array of cells that result from finding nodes/edges that\n     * are connected to any of the cells in the cells array. This function\n     * loops over cells and if the current cell is a edge, it collects its\n     * source/target nodes; if it is an node, it collects its incoming and\n     * outgoing edges if both the edge terminal (source/target) are in the\n     * cells array.\n     */\n\n  }, {\n    key: \"getSubGraph\",\n    value: function getSubGraph(cells) {\n      var _this17 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var subgraph = [];\n      var cache = {};\n      var nodes = [];\n      var edges = [];\n\n      var collect = function collect(cell) {\n        if (!cache[cell.id]) {\n          subgraph.push(cell);\n          cache[cell.id] = cell;\n\n          if (cell.isEdge()) {\n            edges.push(cell);\n          }\n\n          if (cell.isNode()) {\n            nodes.push(cell);\n          }\n        }\n      };\n\n      cells.forEach(function (cell) {\n        collect(cell);\n\n        if (options.deep) {\n          var descendants = cell.getDescendants({\n            deep: true\n          });\n          descendants.forEach(function (descendant) {\n            return collect(descendant);\n          });\n        }\n      });\n      edges.forEach(function (edge) {\n        // For edges, include their source & target\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (sourceCell && !cache[sourceCell.id]) {\n          subgraph.push(sourceCell);\n          cache[sourceCell.id] = sourceCell;\n\n          if (sourceCell.isNode()) {\n            nodes.push(sourceCell);\n          }\n        }\n\n        if (targetCell && !cache[targetCell.id]) {\n          subgraph.push(targetCell);\n          cache[targetCell.id] = targetCell;\n\n          if (targetCell.isNode()) {\n            nodes.push(targetCell);\n          }\n        }\n      });\n      nodes.forEach(function (node) {\n        // For nodes, include their connected edges if their source/target\n        // is in the subgraph.\n        var edges = _this17.getConnectedEdges(node, options);\n\n        edges.forEach(function (edge) {\n          var sourceCell = edge.getSourceCell();\n          var targetCell = edge.getTargetCell();\n\n          if (!cache[edge.id] && sourceCell && cache[sourceCell.id] && targetCell && cache[targetCell.id]) {\n            subgraph.push(edge);\n            cache[edge.id] = edge;\n          }\n        });\n      });\n      return subgraph;\n    }\n    /**\n     * Clones the whole subgraph (including all the connected links whose\n     * source/target is in the subgraph). If `options.deep` is `true`, also\n     * take into account all the embedded cells of all the subgraph cells.\n     *\n     * Returns a map of the form: { [original cell ID]: [clone] }.\n     */\n\n  }, {\n    key: \"cloneSubGraph\",\n    value: function cloneSubGraph(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var subgraph = this.getSubGraph(cells, options);\n      return this.cloneCells(subgraph);\n    }\n  }, {\n    key: \"cloneCells\",\n    value: function cloneCells(cells) {\n      return Cell.cloneCells(cells);\n    }\n  }, {\n    key: \"getNodesFromPoint\",\n    value: function getNodesFromPoint(x, y) {\n      var p = typeof x === 'number' ? {\n        x: x,\n        y: y || 0\n      } : x;\n      return this.getNodes().filter(function (node) {\n        return node.getBBox().containsPoint(p);\n      });\n    }\n  }, {\n    key: \"getNodesInArea\",\n    value: function getNodesInArea(x, y, w, h, options) {\n      var rect = typeof x === 'number' ? new Rectangle(x, y, w, h) : Rectangle.create(x);\n      var opts = typeof x === 'number' ? options : y;\n      var strict = opts && opts.strict;\n      return this.getNodes().filter(function (node) {\n        var bbox = node.getBBox();\n        return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n      });\n    }\n  }, {\n    key: \"getEdgesInArea\",\n    value: function getEdgesInArea(x, y, w, h, options) {\n      var rect = typeof x === 'number' ? new Rectangle(x, y, w, h) : Rectangle.create(x);\n      var opts = typeof x === 'number' ? options : y;\n      var strict = opts && opts.strict;\n      return this.getEdges().filter(function (edge) {\n        var bbox = edge.getBBox();\n\n        if (bbox.width === 0) {\n          bbox.inflate(1, 0);\n        } else if (bbox.height === 0) {\n          bbox.inflate(0, 1);\n        }\n\n        return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n      });\n    }\n  }, {\n    key: \"getNodesUnderNode\",\n    value: function getNodesUnderNode(node) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var bbox = node.getBBox();\n      var nodes = options.by == null || options.by === 'bbox' ? this.getNodesInArea(bbox) : this.getNodesFromPoint(bbox[options.by]);\n      return nodes.filter(function (curr) {\n        return node.id !== curr.id && !curr.isDescendantOf(node);\n      });\n    }\n    /**\n     * Returns the bounding box that surrounds all cells in the graph.\n     */\n\n  }, {\n    key: \"getAllCellsBBox\",\n    value: function getAllCellsBBox() {\n      return this.getCellsBBox(this.getCells());\n    }\n    /**\n     * Returns the bounding box that surrounds all the given cells.\n     */\n\n  }, {\n    key: \"getCellsBBox\",\n    value: function getCellsBBox(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return Cell.getCellsBBox(cells, options);\n    } // #region search\n\n  }, {\n    key: \"search\",\n    value: function search(cell, iterator) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (options.breadthFirst) {\n        this.breadthFirstSearch(cell, iterator, options);\n      } else {\n        this.depthFirstSearch(cell, iterator, options);\n      }\n    }\n  }, {\n    key: \"breadthFirstSearch\",\n    value: function breadthFirstSearch(cell, iterator) {\n      var _this18 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var queue = [];\n      var visited = {};\n      var distance = {};\n      queue.push(cell);\n      distance[cell.id] = 0;\n\n      var _loop = function _loop() {\n        var next = queue.shift();\n\n        if (next == null || visited[next.id]) {\n          return \"continue\";\n        }\n\n        visited[next.id] = true;\n\n        if (FunctionExt.call(iterator, _this18, next, distance[next.id]) === false) {\n          return \"continue\";\n        }\n\n        var neighbors = _this18.getNeighbors(next, options);\n\n        neighbors.forEach(function (neighbor) {\n          distance[neighbor.id] = distance[next.id] + 1;\n          queue.push(neighbor);\n        });\n      };\n\n      while (queue.length > 0) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  }, {\n    key: \"depthFirstSearch\",\n    value: function depthFirstSearch(cell, iterator) {\n      var _this19 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var queue = [];\n      var visited = {};\n      var distance = {};\n      queue.push(cell);\n      distance[cell.id] = 0;\n\n      var _loop2 = function _loop2() {\n        var next = queue.pop();\n\n        if (next == null || visited[next.id]) {\n          return \"continue\";\n        }\n\n        visited[next.id] = true;\n\n        if (FunctionExt.call(iterator, _this19, next, distance[next.id]) === false) {\n          return \"continue\";\n        }\n\n        var neighbors = _this19.getNeighbors(next, options);\n\n        var lastIndex = queue.length;\n        neighbors.forEach(function (neighbor) {\n          distance[neighbor.id] = distance[next.id] + 1;\n          queue.splice(lastIndex, 0, neighbor);\n        });\n      };\n\n      while (queue.length > 0) {\n        var _ret2 = _loop2();\n\n        if (_ret2 === \"continue\") continue;\n      }\n    } // #endregion\n    // #region shortest path\n\n    /** *\n     * Returns an array of IDs of nodes on the shortest\n     * path between source and target.\n     */\n\n  }, {\n    key: \"getShortestPath\",\n    value: function getShortestPath(source, target) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var adjacencyList = {};\n      this.getEdges().forEach(function (edge) {\n        var sourceId = edge.getSourceCellId();\n        var targetId = edge.getTargetCellId();\n\n        if (sourceId && targetId) {\n          if (!adjacencyList[sourceId]) {\n            adjacencyList[sourceId] = [];\n          }\n\n          if (!adjacencyList[targetId]) {\n            adjacencyList[targetId] = [];\n          }\n\n          adjacencyList[sourceId].push(targetId);\n\n          if (!options.directed) {\n            adjacencyList[targetId].push(sourceId);\n          }\n        }\n      });\n      var sourceId = typeof source === 'string' ? source : source.id;\n      var previous = Dijkstra.run(adjacencyList, sourceId, options.weight);\n      var path = [];\n      var targetId = typeof target === 'string' ? target : target.id;\n\n      if (previous[targetId]) {\n        path.push(targetId);\n      }\n\n      while (targetId = previous[targetId]) {\n        path.unshift(targetId);\n      }\n\n      return path;\n    } // #endregion\n    // #region transform\n\n    /**\n     * Translate all cells in the graph by `tx` and `ty` pixels.\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty, options) {\n      this.getCells().filter(function (cell) {\n        return !cell.hasParent();\n      }).forEach(function (cell) {\n        return cell.translate(tx, ty, options);\n      });\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(width, height, options) {\n      return this.resizeCells(width, height, this.getCells(), options);\n    }\n  }, {\n    key: \"resizeCells\",\n    value: function resizeCells(width, height, cells) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var bbox = this.getCellsBBox(cells);\n\n      if (bbox) {\n        var sx = Math.max(width / bbox.width, 0);\n        var sy = Math.max(height / bbox.height, 0);\n        var origin = bbox.getOrigin();\n        cells.forEach(function (cell) {\n          return cell.scale(sx, sy, origin, options);\n        });\n      }\n\n      return this;\n    } // #endregion\n    // #region serialize/deserialize\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return Model.toJSON(this.getCells(), options);\n    }\n  }, {\n    key: \"parseJSON\",\n    value: function parseJSON(data) {\n      return Model.fromJSON(data);\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cells = this.parseJSON(data);\n      this.resetCells(cells, options);\n      return this;\n    } // #endregion\n    // #region batch\n\n  }, {\n    key: \"startBatch\",\n    value: function startBatch(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.batches[name] = (this.batches[name] || 0) + 1;\n      this.notify('batch:start', {\n        name: name,\n        data: data\n      });\n      return this;\n    }\n  }, {\n    key: \"stopBatch\",\n    value: function stopBatch(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.batches[name] = (this.batches[name] || 0) - 1;\n      this.notify('batch:stop', {\n        name: name,\n        data: data\n      });\n      return this;\n    }\n  }, {\n    key: \"batchUpdate\",\n    value: function batchUpdate(name, execute) {\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.startBatch(name, data);\n      var result = execute();\n      this.stopBatch(name, data);\n      return result;\n    }\n  }, {\n    key: \"hasActiveBatch\",\n    value: function hasActiveBatch() {\n      var _this20 = this;\n\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(this.batches);\n      var names = Array.isArray(name) ? name : [name];\n      return names.some(function (batch) {\n        return _this20.batches[batch] > 0;\n      });\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Model.toStringTag;\n    }\n  }]);\n\n  return Model;\n}(Basecoat);\n\n(function (Model) {\n  Model.toStringTag = \"X6.\".concat(Model.name);\n\n  function isModel(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Model) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var model = instance;\n\n    if ((tag == null || tag === Model.toStringTag) && typeof model.addNode === 'function' && typeof model.addEdge === 'function' && model.collection != null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  Model.isModel = isModel;\n})(Model || (Model = {}));\n\n(function (Model) {\n  function toJSON(cells) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return {\n      cells: cells.map(function (cell) {\n        return cell.toJSON(options);\n      })\n    };\n  }\n\n  Model.toJSON = toJSON;\n\n  function fromJSON(data) {\n    var cells = [];\n\n    if (Array.isArray(data)) {\n      cells.push.apply(cells, _toConsumableArray(data));\n    } else {\n      if (data.cells) {\n        cells.push.apply(cells, _toConsumableArray(data.cells));\n      }\n\n      if (data.nodes) {\n        data.nodes.forEach(function (node) {\n          if (node.shape == null) {\n            node.shape = 'rect';\n          }\n\n          cells.push(node);\n        });\n      }\n\n      if (data.edges) {\n        data.edges.forEach(function (edge) {\n          if (edge.shape == null) {\n            edge.shape = 'edge';\n          }\n\n          cells.push(edge);\n        });\n      }\n    }\n\n    return cells.map(function (cell) {\n      var type = cell.shape;\n\n      if (type) {\n        if (Node.registry.exist(type)) {\n          return Node.create(cell);\n        }\n\n        if (Edge.registry.exist(type)) {\n          return Edge.create(cell);\n        }\n      }\n\n      throw new Error('The `shape` should be specified when creating a node/edge instance');\n    });\n  }\n\n  Model.fromJSON = fromJSON;\n})(Model || (Model = {}));","map":null,"metadata":{},"sourceType":"module"}