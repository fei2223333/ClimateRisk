{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\nimport { hypotenuse } from './util';\n\nvar QrDecomposition = /*#__PURE__*/function () {\n  function QrDecomposition(value) {\n    _classCallCheck(this, QrDecomposition);\n\n    value = WrapperMatrix2D.checkMatrix(value);\n    var qr = value.clone();\n    var m = value.rows;\n    var n = value.columns;\n    var rdiag = new Float64Array(n);\n    var i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      var nrm = 0;\n\n      for (i = k; i < m; i++) {\n        nrm = hypotenuse(nrm, qr.get(i, k));\n      }\n\n      if (nrm !== 0) {\n        if (qr.get(k, k) < 0) {\n          nrm = -nrm;\n        }\n\n        for (i = k; i < m; i++) {\n          qr.set(i, k, qr.get(i, k) / nrm);\n        }\n\n        qr.set(k, k, qr.get(k, k) + 1);\n\n        for (j = k + 1; j < n; j++) {\n          s = 0;\n\n          for (i = k; i < m; i++) {\n            s += qr.get(i, k) * qr.get(i, j);\n          }\n\n          s = -s / qr.get(k, k);\n\n          for (i = k; i < m; i++) {\n            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n\n      rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n  }\n\n  _createClass(QrDecomposition, [{\n    key: \"solve\",\n    value: function solve(value) {\n      value = Matrix.checkMatrix(value);\n      var qr = this.QR;\n      var m = qr.rows;\n\n      if (value.rows !== m) {\n        throw new Error('Matrix row dimensions must agree');\n      }\n\n      if (!this.isFullRank()) {\n        throw new Error('Matrix is rank deficient');\n      }\n\n      var count = value.columns;\n      var X = value.clone();\n      var n = qr.columns;\n      var i, j, k, s;\n\n      for (k = 0; k < n; k++) {\n        for (j = 0; j < count; j++) {\n          s = 0;\n\n          for (i = k; i < m; i++) {\n            s += qr.get(i, k) * X.get(i, j);\n          }\n\n          s = -s / qr.get(k, k);\n\n          for (i = k; i < m; i++) {\n            X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n\n      for (k = n - 1; k >= 0; k--) {\n        for (j = 0; j < count; j++) {\n          X.set(k, j, X.get(k, j) / this.Rdiag[k]);\n        }\n\n        for (i = 0; i < k; i++) {\n          for (j = 0; j < count; j++) {\n            X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));\n          }\n        }\n      }\n\n      return X.subMatrix(0, n - 1, 0, count - 1);\n    }\n  }, {\n    key: \"isFullRank\",\n    value: function isFullRank() {\n      var columns = this.QR.columns;\n\n      for (var i = 0; i < columns; i++) {\n        if (this.Rdiag[i] === 0) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"upperTriangularMatrix\",\n    get: function get() {\n      var qr = this.QR;\n      var n = qr.columns;\n      var X = new Matrix(n, n);\n      var i, j;\n\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          if (i < j) {\n            X.set(i, j, qr.get(i, j));\n          } else if (i === j) {\n            X.set(i, j, this.Rdiag[i]);\n          } else {\n            X.set(i, j, 0);\n          }\n        }\n      }\n\n      return X;\n    }\n  }, {\n    key: \"orthogonalMatrix\",\n    get: function get() {\n      var qr = this.QR;\n      var rows = qr.rows;\n      var columns = qr.columns;\n      var X = new Matrix(rows, columns);\n      var i, j, k, s;\n\n      for (k = columns - 1; k >= 0; k--) {\n        for (i = 0; i < rows; i++) {\n          X.set(i, k, 0);\n        }\n\n        X.set(k, k, 1);\n\n        for (j = k; j < columns; j++) {\n          if (qr.get(k, k) !== 0) {\n            s = 0;\n\n            for (i = k; i < rows; i++) {\n              s += qr.get(i, k) * X.get(i, j);\n            }\n\n            s = -s / qr.get(k, k);\n\n            for (i = k; i < rows; i++) {\n              X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n            }\n          }\n        }\n      }\n\n      return X;\n    }\n  }]);\n\n  return QrDecomposition;\n}();\n\nexport { QrDecomposition as default };","map":null,"metadata":{},"sourceType":"module"}