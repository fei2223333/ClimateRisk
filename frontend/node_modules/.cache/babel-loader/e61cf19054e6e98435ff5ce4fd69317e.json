{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/diagpanel2/ServiceWebsite/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as Registry from '../registry';\nimport { Dom, Vector } from '../util';\nimport { Base } from './base';\nexport var GridManager = /*#__PURE__*/function (_Base) {\n  _inherits(GridManager, _Base);\n\n  function GridManager() {\n    _classCallCheck(this, GridManager);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GridManager).apply(this, arguments));\n  }\n\n  _createClass(GridManager, [{\n    key: \"init\",\n    value: function init() {\n      this.startListening();\n      this.draw(this.grid);\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      this.graph.on('scale', this.update, this);\n      this.graph.on('translate', this.update, this);\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      this.graph.off('scale', this.update, this);\n      this.graph.off('translate', this.update, this);\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      if (this.grid.visible !== visible) {\n        this.grid.visible = visible;\n        this.update();\n      }\n    }\n  }, {\n    key: \"getGridSize\",\n    value: function getGridSize() {\n      return this.grid.size;\n    }\n  }, {\n    key: \"setGridSize\",\n    value: function setGridSize(size) {\n      this.grid.size = Math.max(size, 1);\n      this.update();\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.setVisible(true);\n      this.update();\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.setVisible(false);\n      this.update();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.elem.style.backgroundImage = '';\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(options) {\n      this.clear();\n      this.instance = null;\n      Object.assign(this.grid, options);\n      this.patterns = this.resolveGrid(options);\n      this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var gridSize = this.grid.size;\n\n      if (gridSize <= 1 || !this.grid.visible) {\n        return this.clear();\n      }\n\n      var ctm = this.graph.matrix();\n      var grid = this.getInstance();\n      var items = Array.isArray(options) ? options : [options];\n      this.patterns.forEach(function (settings, index) {\n        var id = \"pattern_\".concat(index);\n        var sx = ctm.a || 1;\n        var sy = ctm.d || 1;\n\n        var update = settings.update,\n            markup = settings.markup,\n            others = __rest(settings, [\"update\", \"markup\"]);\n\n        var options = Object.assign(Object.assign(Object.assign({}, others), items[index]), {\n          sx: sx,\n          sy: sy,\n          ox: ctm.e || 0,\n          oy: ctm.f || 0,\n          width: gridSize * sx,\n          height: gridSize * sy\n        });\n\n        if (!grid.has(id)) {\n          grid.add(id, Vector.create('pattern', {\n            id: id,\n            patternUnits: 'userSpaceOnUse'\n          }, Vector.createVectors(markup)).node);\n        }\n\n        var patternElem = grid.get(id);\n\n        if (typeof update === 'function') {\n          update(patternElem.childNodes[0], options);\n        }\n\n        var x = options.ox % options.width;\n\n        if (x < 0) {\n          x += options.width;\n        }\n\n        var y = options.oy % options.height;\n\n        if (y < 0) {\n          y += options.height;\n        }\n\n        Dom.attr(patternElem, {\n          x: x,\n          y: y,\n          width: options.width,\n          height: options.height\n        });\n      });\n      var base64 = new XMLSerializer().serializeToString(grid.root);\n      var url = \"url(data:image/svg+xml;base64,\".concat(btoa(base64), \")\");\n      this.elem.style.backgroundImage = url;\n    }\n  }, {\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!this.instance) {\n        this.instance = new Registry.Grid();\n      }\n\n      return this.instance;\n    }\n  }, {\n    key: \"resolveGrid\",\n    value: function resolveGrid(options) {\n      if (!options) {\n        return [];\n      }\n\n      var type = options.type;\n\n      if (type == null) {\n        return [Object.assign(Object.assign({}, Registry.Grid.presets.dot), options.args)];\n      }\n\n      var items = Registry.Grid.registry.get(type);\n\n      if (items) {\n        var args = options.args || [];\n\n        if (!Array.isArray(args)) {\n          args = [args];\n        }\n\n        return Array.isArray(items) ? items.map(function (item, index) {\n          return Object.assign(Object.assign({}, item), args[index]);\n        }) : [Object.assign(Object.assign({}, items), args[0])];\n      }\n\n      return Registry.Grid.registry.onNotFound(type);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.stopListening();\n      this.clear();\n    }\n  }, {\n    key: \"elem\",\n    get: function get() {\n      return this.view.grid;\n    }\n  }, {\n    key: \"grid\",\n    get: function get() {\n      return this.options.grid;\n    }\n  }]);\n\n  return GridManager;\n}(Base);\n\n__decorate([Base.dispose()], GridManager.prototype, \"dispose\", null);","map":null,"metadata":{},"sourceType":"module"}