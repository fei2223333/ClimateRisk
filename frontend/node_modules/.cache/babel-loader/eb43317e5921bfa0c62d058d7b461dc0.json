{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ComboCombinedLayout = void 0;\n\nvar constants_1 = require(\"./constants\");\n\nvar base_1 = require(\"./base\");\n\nvar util_1 = require(\"../util\");\n\nvar _1 = require(\".\");\n/**\n * combined two layouts (inner and outer) for graph with combos\n */\n\n\nvar ComboCombinedLayout =\n/** @class */\nfunction (_super) {\n  __extends(ComboCombinedLayout, _super);\n\n  function ComboCombinedLayout(options) {\n    var _this = _super.call(this) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 内部计算参数 */\n\n    _this.nodes = [];\n    _this.edges = [];\n    _this.combos = [];\n    _this.comboEdges = [];\n    /** Combo 内部的 padding */\n\n    _this.comboPadding = 10;\n    _this.comboTrees = [];\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  ComboCombinedLayout.prototype.getDefaultCfg = function () {\n    return {};\n  };\n  /**\n   * 执行布局\n   */\n\n\n  ComboCombinedLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    self.initVals(); // layout\n\n    self.run();\n    if (self.onLayoutEnd) self.onLayoutEnd();\n  };\n\n  ComboCombinedLayout.prototype.run = function () {\n    var _a;\n\n    var self = this;\n    var nodes = self.nodes,\n        edges = self.edges,\n        combos = self.combos,\n        comboEdges = self.comboEdges,\n        center = self.center;\n    var innerGraphs = self.getInnerGraphs();\n    var nodeMap = {};\n    nodes.forEach(function (node) {\n      nodeMap[node.id] = node;\n    });\n    var comboMap = {};\n    combos.forEach(function (combo) {\n      comboMap[combo.id] = combo;\n    }); // 每个 innerGraph 作为一个节点，带有大小，参与 force 计算\n\n    var outerNodeIds = [];\n    var outerNodes = [];\n    var nodeAncestorIdMap = {};\n    var allHaveNoPosition = true;\n    this.comboTrees.forEach(function (cTree) {\n      var innerNode = innerGraphs[cTree.id]; // 代表 combo 的节点\n\n      var oNode = {\n        id: cTree.id,\n        x: innerNode.x || comboMap[cTree.id].x,\n        y: innerNode.y || comboMap[cTree.id].y,\n        fx: innerNode.fx || comboMap[cTree.id].fx,\n        fy: innerNode.fy || comboMap[cTree.id].fy,\n        mass: innerNode.mass || comboMap[cTree.id].mass,\n        size: innerNode.size\n      };\n      outerNodes.push(oNode);\n\n      if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {\n        allHaveNoPosition = false;\n      } else {\n        oNode.x = Math.random() * 100;\n        oNode.y = Math.random() * 100;\n      }\n\n      outerNodeIds.push(cTree.id);\n      (0, util_1.traverseTreeUp)(cTree, function (child) {\n        if (child.id !== cTree.id) nodeAncestorIdMap[child.id] = cTree.id;\n        return true;\n      });\n    });\n    nodes.forEach(function (node) {\n      if (node.comboId && comboMap[node.comboId]) return; // 代表节点的节点\n\n      var oNode = {\n        id: node.id,\n        x: node.x,\n        y: node.y,\n        fx: node.fx,\n        fy: node.fy,\n        mass: node.mass,\n        size: node.size\n      };\n      outerNodes.push(oNode);\n\n      if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {\n        allHaveNoPosition = false;\n      } else {\n        oNode.x = Math.random() * 100;\n        oNode.y = Math.random() * 100;\n      }\n\n      outerNodeIds.push(node.id);\n    });\n    var outerEdges = [];\n    edges.concat(comboEdges).forEach(function (edge) {\n      var sourceAncestorId = nodeAncestorIdMap[edge.source] || edge.source;\n      var targetAncestorId = nodeAncestorIdMap[edge.target] || edge.target; // 若两个点的祖先都在力导图的节点中，且是不同的节点，创建一条链接两个祖先的边到力导图的边中\n\n      if (sourceAncestorId !== targetAncestorId && outerNodeIds.includes(sourceAncestorId) && outerNodeIds.includes(targetAncestorId)) {\n        outerEdges.push({\n          source: sourceAncestorId,\n          target: targetAncestorId\n        });\n      }\n    }); // 若有需要最外层的 combo 或节点，则对最外层执行力导向\n\n    if (outerNodes === null || outerNodes === void 0 ? void 0 : outerNodes.length) {\n      if (outerNodes.length === 1) {\n        outerNodes[0].x = center[0];\n        outerNodes[0].y = center[1];\n      } else {\n        var outerData = {\n          nodes: outerNodes,\n          edges: outerEdges\n        }; // 需要使用一个同步的布局\n        // @ts-ignore\n\n        var outerLayout = this.outerLayout || new _1.GForceLayout({\n          gravity: 1,\n          factor: 2,\n          linkDistance: function linkDistance(edge, source, target) {\n            var _a, _b;\n\n            var nodeSize = ((((_a = source.size) === null || _a === void 0 ? void 0 : _a[0]) || 30) + (((_b = target.size) === null || _b === void 0 ? void 0 : _b[0]) || 30)) / 2;\n            return Math.min(nodeSize * 1.5, 700);\n          }\n        });\n        var outerLayoutType = (_a = outerLayout.getType) === null || _a === void 0 ? void 0 : _a.call(outerLayout);\n        outerLayout.updateCfg({\n          center: center,\n          kg: 5,\n          preventOverlap: true,\n          animate: false\n        }); // 若所有 outerNodes 都没有位置，且 outerLayout 是力导家族的布局，则先执行 preset mds 或 grid\n\n        if (allHaveNoPosition && constants_1.FORCE_LAYOUT_TYPE_MAP[outerLayoutType]) {\n          var outerLayoutPreset = outerNodes.length < 100 ? new _1.MDSLayout() : new _1.GridLayout();\n          outerLayoutPreset.layout(outerData);\n        }\n\n        outerLayout.layout(outerData);\n      } // 根据外部布局结果，平移 innerGraphs 中的节点（第一层）\n\n\n      outerNodes.forEach(function (oNode) {\n        var innerGraph = innerGraphs[oNode.id];\n\n        if (!innerGraph) {\n          var node = nodeMap[oNode.id];\n\n          if (node) {\n            node.x = oNode.x;\n            node.y = oNode.y;\n          }\n\n          return;\n        }\n\n        innerGraph.visited = true;\n        innerGraph.x = oNode.x;\n        innerGraph.y = oNode.y;\n        innerGraph.nodes.forEach(function (node) {\n          node.x += oNode.x;\n          node.y += oNode.y;\n        });\n      });\n    } // 至上而下遍历树处理下面各层节点位置\n\n\n    var innerGraphIds = Object.keys(innerGraphs);\n\n    var _loop_1 = function _loop_1(i) {\n      var id = innerGraphIds[i];\n      var innerGraph = innerGraphs[id];\n      if (!innerGraph) return \"continue\";\n      innerGraph.nodes.forEach(function (node) {\n        if (!innerGraph.visited) {\n          node.x += innerGraph.x || 0;\n          node.y += innerGraph.y || 0;\n        }\n\n        if (nodeMap[node.id]) {\n          nodeMap[node.id].x = node.x;\n          nodeMap[node.id].y = node.y;\n        }\n      });\n\n      if (comboMap[id]) {\n        comboMap[id].x = innerGraph.x;\n        comboMap[id].y = innerGraph.y;\n      }\n    };\n\n    for (var i = innerGraphIds.length - 1; i >= 0; i--) {\n      _loop_1(i);\n    }\n\n    return {\n      nodes: nodes,\n      edges: edges,\n      combos: combos,\n      comboEdges: comboEdges\n    };\n  };\n\n  ComboCombinedLayout.prototype.getInnerGraphs = function () {\n    var self = this;\n    var comboTrees = self.comboTrees,\n        nodeSize = self.nodeSize,\n        edges = self.edges,\n        comboPadding = self.comboPadding,\n        spacing = self.spacing;\n    var innerGraphs = {}; // @ts-ignore\n\n    var innerGraphLayout = this.innerLayout || new _1.ConcentricLayout({\n      sortBy: 'id'\n    });\n    innerGraphLayout.center = [0, 0];\n    innerGraphLayout.preventOverlap = true;\n    innerGraphLayout.nodeSpacing = spacing;\n    (comboTrees || []).forEach(function (ctree) {\n      (0, util_1.traverseTreeUp)(ctree, function (treeNode) {\n        var _a; // @ts-ignore\n\n\n        var padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(treeNode)) || 10; // 返回的最大值\n\n        if ((0, util_1.isArray)(padding)) padding = Math.max.apply(Math, padding);\n\n        if (!((_a = treeNode.children) === null || _a === void 0 ? void 0 : _a.length)) {\n          // 空 combo\n          if (treeNode.itemType === 'combo') {\n            var treeNodeSize = padding ? [padding * 2, padding * 2] : [30, 30];\n            innerGraphs[treeNode.id] = {\n              id: treeNode.id,\n              nodes: [],\n              size: treeNodeSize\n            };\n          }\n        } else {\n          // 非空 combo\n          var innerGraphNodes = treeNode.children.map(function (child) {\n            if (child.itemType === 'combo') return innerGraphs[child.id];\n            return __assign({}, child);\n          });\n          var innerGraphNodeIds_1 = innerGraphNodes.map(function (node) {\n            return node.id;\n          });\n          var innerGraphData = {\n            nodes: innerGraphNodes,\n            edges: edges.filter(function (edge) {\n              return innerGraphNodeIds_1.includes(edge.source) && innerGraphNodeIds_1.includes(edge.target);\n            })\n          };\n          var minNodeSize_1 = Infinity;\n          innerGraphNodes.forEach(function (node) {\n            var _a; // @ts-ignore\n\n\n            if (!node.size) node.size = ((_a = innerGraphs[node.id]) === null || _a === void 0 ? void 0 : _a.size) || (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];\n            if ((0, util_1.isNumber)(node.size)) node.size = [node.size, node.size];\n            if (minNodeSize_1 > node.size[0]) minNodeSize_1 = node.size[0];\n            if (minNodeSize_1 > node.size[1]) minNodeSize_1 = node.size[1];\n          }); // 根据节点数量、spacing，调整布局参数\n\n          innerGraphLayout.layout(innerGraphData);\n\n          var _b = (0, util_1.findMinMaxNodeXY)(innerGraphNodes),\n              minX = _b.minX,\n              minY = _b.minY,\n              maxX = _b.maxX,\n              maxY = _b.maxY;\n\n          var innerGraphSize = Math.max(maxX - minX, maxY - minY, minNodeSize_1) + padding * 2;\n          innerGraphs[treeNode.id] = {\n            id: treeNode.id,\n            nodes: innerGraphNodes,\n            size: [innerGraphSize, innerGraphSize]\n          };\n        }\n\n        return true;\n      });\n    });\n    return innerGraphs;\n  };\n\n  ComboCombinedLayout.prototype.initVals = function () {\n    var self = this;\n    var nodeSize = self.nodeSize;\n    var spacing = self.spacing;\n    var nodeSizeFunc;\n    var spacingFunc; // nodeSpacing to function\n\n    if ((0, util_1.isNumber)(spacing)) {\n      spacingFunc = function spacingFunc() {\n        return spacing;\n      };\n    } else if ((0, util_1.isFunction)(spacing)) {\n      spacingFunc = spacing;\n    } else {\n      spacingFunc = function spacingFunc() {\n        return 0;\n      };\n    }\n\n    this.spacing = spacingFunc; // nodeSize to function\n\n    if (!nodeSize) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        var spacing = spacingFunc(d);\n\n        if (d.size) {\n          if ((0, util_1.isArray)(d.size)) {\n            var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return (res + spacing) / 2;\n          }\n\n          if ((0, util_1.isObject)(d.size)) {\n            var res = d.size.width > d.size.height ? d.size.width : d.size.height;\n            return (res + spacing) / 2;\n          }\n\n          return (d.size + spacing) / 2;\n        }\n\n        return 10 + spacing / 2;\n      };\n    } else if ((0, util_1.isFunction)(nodeSize)) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        var size = nodeSize(d);\n        var spacing = spacingFunc(d);\n\n        if ((0, util_1.isArray)(d.size)) {\n          var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n          return (res + spacing) / 2;\n        }\n\n        return ((size || 10) + spacing) / 2;\n      };\n    } else if ((0, util_1.isArray)(nodeSize)) {\n      var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      var radius_1 = larger / 2;\n\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return radius_1 + spacingFunc(d) / 2;\n      };\n    } else {\n      // number type\n      var radius_2 = nodeSize / 2;\n\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return radius_2 + spacingFunc(d) / 2;\n      };\n    }\n\n    this.nodeSize = nodeSizeFunc; // comboPadding to function\n\n    var comboPadding = self.comboPadding;\n    var comboPaddingFunc;\n\n    if ((0, util_1.isNumber)(comboPadding)) {\n      comboPaddingFunc = function comboPaddingFunc() {\n        return comboPadding;\n      };\n    } else if ((0, util_1.isArray)(comboPadding)) {\n      comboPaddingFunc = function comboPaddingFunc() {\n        return Math.max.apply(null, comboPadding);\n      };\n    } else if ((0, util_1.isFunction)(comboPadding)) {\n      comboPaddingFunc = comboPadding;\n    } else {\n      // null type\n      comboPaddingFunc = function comboPaddingFunc() {\n        return 0;\n      };\n    }\n\n    this.comboPadding = comboPaddingFunc;\n  };\n\n  ComboCombinedLayout.prototype.getType = function () {\n    return \"comboCombined\";\n  };\n\n  return ComboCombinedLayout;\n}(base_1.Base);\n\nexports.ComboCombinedLayout = ComboCombinedLayout;","map":null,"metadata":{},"sourceType":"script"}