{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar init_order_1 = __importDefault(require(\"./init-order\"));\n\nvar cross_count_1 = __importDefault(require(\"./cross-count\"));\n\nvar build_layer_graph_1 = __importDefault(require(\"./build-layer-graph\"));\n\nvar add_subgraph_constraints_1 = __importDefault(require(\"./add-subgraph-constraints\"));\n\nvar sort_subgraph_1 = __importDefault(require(\"./sort-subgraph\"));\n\nvar util_1 = require(\"../../../../util\");\n\nvar graph_1 = require(\"../../graph\");\n\nvar util_2 = require(\"../util\");\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\n\n\nvar order = function order(g) {\n  var mxRank = (0, util_2.maxRank)(g);\n  var range1 = [];\n  var range2 = [];\n\n  for (var i = 1; i < mxRank + 1; i++) {\n    range1.push(i);\n  }\n\n  for (var i = mxRank - 1; i > -1; i--) {\n    range2.push(i);\n  }\n\n  var downLayerGraphs = buildLayerGraphs(g, range1, \"inEdges\");\n  var upLayerGraphs = buildLayerGraphs(g, range2, \"outEdges\");\n  var layering = (0, init_order_1.default)(g);\n  assignOrder(g, layering);\n  var bestCC = Number.POSITIVE_INFINITY;\n  var best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n    layering = (0, util_2.buildLayerMatrix)(g);\n    var cc = (0, cross_count_1.default)(g, layering);\n\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = (0, util_1.clone)(layering);\n      bestCC = cc;\n    }\n  } // consider use previous result, maybe somewhat reduendant\n\n\n  layering = (0, init_order_1.default)(g);\n  assignOrder(g, layering);\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, true);\n    layering = (0, util_2.buildLayerMatrix)(g);\n    var cc = (0, cross_count_1.default)(g, layering);\n\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = (0, util_1.clone)(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n};\n\nvar buildLayerGraphs = function buildLayerGraphs(g, ranks, relationship) {\n  return ranks.map(function (rank) {\n    return (0, build_layer_graph_1.default)(g, rank, relationship);\n  });\n};\n\nvar sweepLayerGraphs = function sweepLayerGraphs(layerGraphs, biasRight, usePrev) {\n  var cg = new graph_1.Graph();\n  layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach(function (lg) {\n    var _a;\n\n    var root = lg.graph().root;\n    var sorted = (0, sort_subgraph_1.default)(lg, root, cg, biasRight, usePrev);\n\n    for (var i = 0; i < ((_a = sorted.vs) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {\n      var lnode = lg.node(sorted.vs[i]);\n\n      if (lnode) {\n        lnode.order = i;\n      }\n    }\n\n    (0, add_subgraph_constraints_1.default)(lg, cg, sorted.vs);\n  });\n};\n\nvar assignOrder = function assignOrder(g, layering) {\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n};\n\nexports.default = order;","map":null,"metadata":{},"sourceType":"script"}