{"ast":null,"code":"import { attr } from './attr';\nimport { createSvgElement } from './elem';\nexport var KAPPA = 0.551784;\n\nfunction getNumbericAttribute(elem, attr) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;\n  var v = elem.getAttribute(attr);\n\n  if (v == null) {\n    return defaultValue;\n  }\n\n  var n = parseFloat(v);\n  return Number.isNaN(n) ? defaultValue : n;\n}\n\nexport function sample(elem) {\n  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var length = elem.getTotalLength();\n  var samples = [];\n  var distance = 0;\n  var sample;\n\n  while (distance < length) {\n    sample = elem.getPointAtLength(distance);\n    samples.push({\n      distance: distance,\n      x: sample.x,\n      y: sample.y\n    });\n    distance += interval;\n  }\n\n  return samples;\n}\nexport function lineToPathData(line) {\n  return ['M', getNumbericAttribute(line, 'x1'), getNumbericAttribute(line, 'y1'), 'L', getNumbericAttribute(line, 'x2'), getNumbericAttribute(line, 'y2')].join(' ');\n}\nexport function polygonToPathData(polygon) {\n  var points = getPointsFromSvgElement(polygon);\n\n  if (points.length === 0) {\n    return null;\n  }\n\n  return \"\".concat(svgPointsToPath(points), \" Z\");\n}\nexport function polylineToPathData(polyline) {\n  var points = getPointsFromSvgElement(polyline);\n\n  if (points.length === 0) {\n    return null;\n  }\n\n  return svgPointsToPath(points);\n}\n\nfunction svgPointsToPath(points) {\n  var arr = points.map(function (p) {\n    return \"\".concat(p.x, \" \").concat(p.y);\n  });\n  return \"M \".concat(arr.join(' L'));\n}\n\nexport function getPointsFromSvgElement(elem) {\n  var points = [];\n  var nodePoints = elem.points;\n\n  if (nodePoints) {\n    for (var i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {\n      points.push(nodePoints.getItem(i));\n    }\n  }\n\n  return points;\n}\nexport function circleToPathData(circle) {\n  var cx = getNumbericAttribute(circle, 'cx', 0);\n  var cy = getNumbericAttribute(circle, 'cy', 0);\n  var r = getNumbericAttribute(circle, 'r');\n  var cd = r * KAPPA; // Control distance.\n\n  return ['M', cx, cy - r, 'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, 'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, 'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, 'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, 'Z'].join(' ');\n}\nexport function ellipseToPathData(ellipse) {\n  var cx = getNumbericAttribute(ellipse, 'cx', 0);\n  var cy = getNumbericAttribute(ellipse, 'cy', 0);\n  var rx = getNumbericAttribute(ellipse, 'rx');\n  var ry = getNumbericAttribute(ellipse, 'ry') || rx;\n  var cdx = rx * KAPPA; // Control distance x.\n\n  var cdy = ry * KAPPA; // Control distance y.\n\n  var d = ['M', cx, cy - ry, 'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, 'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, 'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, 'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, 'Z'].join(' ');\n  return d;\n}\nexport function rectangleToPathData(rect) {\n  return rectToPathData({\n    x: getNumbericAttribute(rect, 'x', 0),\n    y: getNumbericAttribute(rect, 'y', 0),\n    width: getNumbericAttribute(rect, 'width', 0),\n    height: getNumbericAttribute(rect, 'height', 0),\n    rx: getNumbericAttribute(rect, 'rx', 0),\n    ry: getNumbericAttribute(rect, 'ry', 0)\n  });\n}\nexport function rectToPathData(r) {\n  var d;\n  var x = r.x;\n  var y = r.y;\n  var width = r.width;\n  var height = r.height;\n  var topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);\n  var bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);\n  var topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);\n  var bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n  if (topRx || bottomRx || topRy || bottomRy) {\n    d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];\n  } else {\n    d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];\n  }\n\n  return d.join(' ');\n}\nexport function toPath(elem) {\n  var path = createSvgElement('path');\n  attr(path, attr(elem));\n  var d = toPathData(elem);\n\n  if (d) {\n    path.setAttribute('d', d);\n  }\n\n  return path;\n}\nexport function toPathData(elem) {\n  var tagName = elem.tagName.toLowerCase();\n\n  switch (tagName) {\n    case 'path':\n      return elem.getAttribute('d');\n\n    case 'line':\n      return lineToPathData(elem);\n\n    case 'polygon':\n      return polygonToPathData(elem);\n\n    case 'polyline':\n      return polylineToPathData(elem);\n\n    case 'ellipse':\n      return ellipseToPathData(elem);\n\n    case 'circle':\n      return circleToPathData(elem);\n\n    case 'rect':\n      return rectangleToPathData(elem);\n\n    default:\n      break;\n  }\n\n  throw new Error(\"\\\"\".concat(tagName, \"\\\" cannot be converted to svg path element.\"));\n} // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n\nexport function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {\n  var svgArcMax = 2 * Math.PI - 1e-6;\n  var r0 = innerRadius;\n  var r1 = outerRadius;\n  var a0 = startAngle;\n  var a1 = endAngle;\n\n  if (a1 < a0) {\n    var tmp = a0;\n    a0 = a1;\n    a1 = tmp;\n  }\n\n  var da = a1 - a0;\n  var df = da < Math.PI ? '0' : '1';\n  var c0 = Math.cos(a0);\n  var s0 = Math.sin(a0);\n  var c1 = Math.cos(a1);\n  var s1 = Math.sin(a1);\n  return da >= svgArcMax ? r0 ? // eslint-disable-next-line\n  \"M0,\".concat(r1, \"A\").concat(r1, \",\").concat(r1, \" 0 1,1 0,\").concat(-r1, \"A\").concat(r1, \",\").concat(r1, \" 0 1,1 0,\").concat(r1, \"M0,\").concat(r0, \"A\").concat(r0, \",\").concat(r0, \" 0 1,0 0,\").concat(-r0, \"A\").concat(r0, \",\").concat(r0, \" 0 1,0 0,\").concat(r0, \"Z\") : // eslint-disable-next-line\n  \"M0,\".concat(r1, \"A\").concat(r1, \",\").concat(r1, \" 0 1,1 0,\").concat(-r1, \"A\").concat(r1, \",\").concat(r1, \" 0 1,1 0,\").concat(r1, \"Z\") : r0 ? // eslint-disable-next-line\n  \"M\".concat(r1 * c0, \",\").concat(r1 * s0, \"A\").concat(r1, \",\").concat(r1, \" 0 \").concat(df, \",1 \").concat(r1 * c1, \",\").concat(r1 * s1, \"L\").concat(r0 * c1, \",\").concat(r0 * s1, \"A\").concat(r0, \",\").concat(r0, \" 0 \").concat(df, \",0 \").concat(r0 * c0, \",\").concat(r0 * s0, \"Z\") : // eslint-disable-next-line\n  \"M\".concat(r1 * c0, \",\").concat(r1 * s0, \"A\").concat(r1, \",\").concat(r1, \" 0 \").concat(df, \",1 \").concat(r1 * c1, \",\").concat(r1 * s1, \"L0,0\") + \"Z\";\n}","map":null,"metadata":{},"sourceType":"module"}