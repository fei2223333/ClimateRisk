{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { getDegree, clone, getEdgeTerminal } from \"../util\";\n\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n  nodes.forEach(function (_, i) {\n    nodes[i].children = [];\n    nodes[i].parent = [];\n  });\n\n  if (directed) {\n    edges.forEach(function (e) {\n      var source = getEdgeTerminal(e, 'source');\n      var target = getEdgeTerminal(e, 'target');\n      var sourceIdx = 0;\n\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n\n      var targetIdx = 0;\n\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n\n      var child = nodes[sourceIdx].children;\n      var parent = nodes[targetIdx].parent;\n      child.push(nodes[targetIdx].id);\n      parent.push(nodes[sourceIdx].id);\n    });\n  } else {\n    edges.forEach(function (e) {\n      var source = getEdgeTerminal(e, 'source');\n      var target = getEdgeTerminal(e, 'target');\n      var sourceIdx = 0;\n\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n\n      var targetIdx = 0;\n\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n\n      var sourceChildren = nodes[sourceIdx].children;\n      var targetChildren = nodes[targetIdx].children;\n      sourceChildren.push(nodes[targetIdx].id);\n      targetChildren.push(nodes[sourceIdx].id);\n    });\n  }\n}\n\nfunction connect(a, b, edges) {\n  var m = edges.length;\n\n  for (var i = 0; i < m; i++) {\n    var source = getEdgeTerminal(edges[i], 'source');\n    var target = getEdgeTerminal(edges[i], 'target');\n\n    if (a.id === source && b.id === target || b.id === source && a.id === target) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction compareDegree(a, b) {\n  var aDegree = a.degree;\n  var bDegree = b.degree;\n\n  if (aDegree < bDegree) {\n    return -1;\n  }\n\n  if (aDegree > bDegree) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * 圆形布局\n */\n\n\nexport var CircularLayout = /*#__PURE__*/function (_Base) {\n  _inherits(CircularLayout, _Base);\n\n  function CircularLayout(options) {\n    var _this;\n\n    _classCallCheck(this, CircularLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CircularLayout).call(this));\n    /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n\n    _this.radius = null;\n    /** 起始半径 */\n\n    _this.startRadius = null;\n    /** 终止半径 */\n\n    _this.endRadius = null;\n    /** 起始角度 */\n\n    _this.startAngle = 0;\n    /** 终止角度 */\n\n    _this.endAngle = 2 * Math.PI;\n    /** 是否顺时针 */\n\n    _this.clockwise = true;\n    /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n\n    _this.divisions = 1;\n    /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n\n    _this.ordering = null;\n    /** how many 2*pi from first to last nodes */\n\n    _this.angleRatio = 1;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.nodeMap = {};\n    _this.degrees = [];\n    _this.width = 300;\n    _this.height = 300;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(CircularLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        radius: null,\n        startRadius: null,\n        endRadius: null,\n        startAngle: 0,\n        endAngle: 2 * Math.PI,\n        clockwise: true,\n        divisions: 1,\n        ordering: null,\n        angleRatio: 1\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges;\n      var n = nodes.length;\n\n      if (n === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      var center = self.center;\n\n      if (n === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      var radius = self.radius;\n      var startRadius = self.startRadius;\n      var endRadius = self.endRadius;\n      var divisions = self.divisions;\n      var startAngle = self.startAngle;\n      var endAngle = self.endAngle;\n      var angleStep = (endAngle - startAngle) / n; // layout\n\n      var nodeMap = {};\n      nodes.forEach(function (node, i) {\n        nodeMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      var degrees = getDegree(nodes.length, nodeMap, edges);\n      self.degrees = degrees;\n\n      if (!radius && !startRadius && !endRadius) {\n        radius = self.height > self.width ? self.width / 2 : self.height / 2;\n      } else if (!startRadius && endRadius) {\n        startRadius = endRadius;\n      } else if (startRadius && !endRadius) {\n        endRadius = startRadius;\n      }\n\n      var angleRatio = self.angleRatio;\n      var astep = angleStep * angleRatio;\n      var ordering = self.ordering;\n      var layoutNodes = [];\n\n      if (ordering === \"topology\") {\n        // layout according to the topology\n        layoutNodes = self.topologyOrdering();\n      } else if (ordering === \"topology-directed\") {\n        // layout according to the topology\n        layoutNodes = self.topologyOrdering(true);\n      } else if (ordering === \"degree\") {\n        // layout according to the descent order of degrees\n        layoutNodes = self.degreeOrdering();\n      } else {\n        // layout according to the original order in the data.nodes\n        layoutNodes = nodes;\n      }\n\n      var clockwise = self.clockwise;\n      var divN = Math.ceil(n / divisions); // node number in each division\n\n      for (var i = 0; i < n; ++i) {\n        var r = radius;\n\n        if (!r && startRadius !== null && endRadius !== null) {\n          r = startRadius + i * (endRadius - startRadius) / (n - 1);\n        }\n\n        if (!r) {\n          r = 10 + i * 100 / (n - 1);\n        }\n\n        var angle = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);\n\n        if (!clockwise) {\n          angle = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);\n        }\n\n        layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n        layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n        layoutNodes[i].weight = degrees[i];\n      }\n\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes: layoutNodes,\n        edges: this.edges\n      };\n    }\n    /**\n     * 根据节点的拓扑结构排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n\n  }, {\n    key: \"topologyOrdering\",\n    value: function topologyOrdering() {\n      var directed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var self = this;\n      var degrees = self.degrees;\n      var edges = self.edges;\n      var nodes = self.nodes;\n      var cnodes = clone(nodes);\n      var nodeMap = self.nodeMap;\n      var orderedCNodes = [cnodes[0]];\n      var resNodes = [nodes[0]];\n      var pickFlags = [];\n      var n = nodes.length;\n      pickFlags[0] = true;\n      initHierarchy(cnodes, edges, nodeMap, directed);\n      var k = 0;\n      cnodes.forEach(function (cnode, i) {\n        if (i !== 0) {\n          if ((i === n - 1 || degrees[i] !== degrees[i + 1] || connect(orderedCNodes[k], cnode, edges)) && !pickFlags[i]) {\n            orderedCNodes.push(cnode);\n            resNodes.push(nodes[nodeMap[cnode.id]]);\n            pickFlags[i] = true;\n            k++;\n          } else {\n            var children = orderedCNodes[k].children;\n            var foundChild = false;\n\n            for (var j = 0; j < children.length; j++) {\n              var childIdx = nodeMap[children[j]];\n\n              if (degrees[childIdx] === degrees[i] && !pickFlags[childIdx]) {\n                orderedCNodes.push(cnodes[childIdx]);\n                resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n                pickFlags[childIdx] = true;\n                foundChild = true;\n                break;\n              }\n            }\n\n            var ii = 0;\n\n            while (!foundChild) {\n              if (!pickFlags[ii]) {\n                orderedCNodes.push(cnodes[ii]);\n                resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n                pickFlags[ii] = true;\n                foundChild = true;\n              }\n\n              ii++;\n\n              if (ii === n) {\n                break;\n              }\n            }\n          }\n        }\n      });\n      return resNodes;\n    }\n    /**\n     * 根据节点度数大小排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n\n  }, {\n    key: \"degreeOrdering\",\n    value: function degreeOrdering() {\n      var self = this;\n      var nodes = self.nodes;\n      var orderedNodes = [];\n      var degrees = self.degrees;\n      nodes.forEach(function (node, i) {\n        node.degree = degrees[i];\n        orderedNodes.push(node);\n      });\n      orderedNodes.sort(compareDegree);\n      return orderedNodes;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"circular\";\n    }\n  }]);\n\n  return CircularLayout;\n}(Base);","map":null,"metadata":{},"sourceType":"module"}