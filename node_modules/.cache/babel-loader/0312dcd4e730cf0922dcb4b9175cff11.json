{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview dagre layout\n * @author shiwu.wyy@antfin.com\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DagreLayout = void 0;\n\nvar index_1 = __importDefault(require(\"./dagre/index\"));\n\nvar util_1 = require(\"../util\");\n\nvar base_1 = require(\"./base\");\n\nvar graph_1 = require(\"./dagre/graph\");\n/**\n * 层次布局\n */\n\n\nvar DagreLayout =\n/** @class */\nfunction (_super) {\n  __extends(DagreLayout, _super);\n\n  function DagreLayout(options) {\n    var _this = _super.call(this) || this;\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n\n    _this.rankdir = \"TB\";\n    /** 节点水平间距(px) */\n\n    _this.nodesep = 50;\n    /** 每一层节点之间间距 */\n\n    _this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    _this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n\n    _this.sortByCombo = false;\n    /** 是否保留每条边上的dummy node */\n\n    _this.edgeLabelSpace = true;\n    /** 是否基于 dagre 进行辐射布局，若是，第一层节点将被放置在最内环上，其余层依次向外辐射 */\n\n    _this.radial = false;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.layoutNode = function (nodeId) {\n      var self = _this;\n      var nodes = self.nodes;\n      var node = nodes.find(function (node) {\n        return node.id === nodeId;\n      });\n\n      if (node) {\n        var layout = node.layout !== false;\n        return layout;\n      }\n\n      return true;\n    };\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  DagreLayout.prototype.getDefaultCfg = function () {\n    return {\n      rankdir: \"TB\",\n      align: undefined,\n      nodeSize: undefined,\n      nodesepFunc: undefined,\n      ranksepFunc: undefined,\n      nodesep: 50,\n      ranksep: 50,\n      controlPoints: false,\n      radial: false,\n      focusNode: null // radial 为 true 时生效，关注的节点\n\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  DagreLayout.prototype.execute = function () {\n    var _this = this;\n\n    var _a;\n\n    var self = this;\n    var nodes = self.nodes,\n        nodeSize = self.nodeSize,\n        rankdir = self.rankdir,\n        combos = self.combos,\n        begin = self.begin,\n        radial = self.radial;\n    if (!nodes) return;\n    var edges = self.edges || [];\n    var g = new graph_1.Graph({\n      multigraph: true,\n      compound: true\n    });\n    var nodeSizeFunc;\n\n    if (!nodeSize) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        if (d.size) {\n          if ((0, util_1.isArray)(d.size)) {\n            return d.size;\n          }\n\n          if ((0, util_1.isObject)(d.size)) {\n            return [d.size.width || 40, d.size.height || 40];\n          }\n\n          return [d.size, d.size];\n        }\n\n        return [40, 40];\n      };\n    } else if ((0, util_1.isArray)(nodeSize)) {\n      nodeSizeFunc = function nodeSizeFunc() {\n        return nodeSize;\n      };\n    } else {\n      nodeSizeFunc = function nodeSizeFunc() {\n        return [nodeSize, nodeSize];\n      };\n    }\n\n    var ranksepfunc = (0, util_1.getFunc)(self.ranksep, 50, self.ranksepFunc);\n    var nodesepfunc = (0, util_1.getFunc)(self.nodesep, 50, self.nodesepFunc);\n    var horisep = nodesepfunc;\n    var vertisep = ranksepfunc;\n\n    if (rankdir === \"LR\" || rankdir === \"RL\") {\n      horisep = ranksepfunc;\n      vertisep = nodesepfunc;\n    }\n\n    g.setDefaultEdgeLabel(function () {\n      return {};\n    });\n    g.setGraph(self);\n    var comboMap = {};\n\n    if (this.sortByCombo && combos) {\n      combos.forEach(function (combo) {\n        if (!combo.parentId) return;\n\n        if (!comboMap[combo.parentId]) {\n          comboMap[combo.parentId] = true;\n          g.setNode(combo.parentId, {});\n        }\n\n        g.setParent(combo.id, combo.parentId);\n      });\n    }\n\n    nodes.filter(function (node) {\n      return node.layout !== false;\n    }).forEach(function (node) {\n      var size = nodeSizeFunc(node);\n      var verti = vertisep(node);\n      var hori = horisep(node);\n      var width = size[0] + 2 * hori;\n      var height = size[1] + 2 * verti;\n      var layer = node.layer;\n\n      if ((0, util_1.isNumber)(layer)) {\n        // 如果有layer属性，加入到node的label中\n        g.setNode(node.id, {\n          width: width,\n          height: height,\n          layer: layer\n        });\n      } else {\n        g.setNode(node.id, {\n          width: width,\n          height: height\n        });\n      }\n\n      if (_this.sortByCombo && node.comboId) {\n        if (!comboMap[node.comboId]) {\n          comboMap[node.comboId] = true;\n          g.setNode(node.comboId, {});\n        }\n\n        g.setParent(node.id, node.comboId);\n      }\n    });\n    edges.forEach(function (edge) {\n      // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n      var source = (0, util_1.getEdgeTerminal)(edge, 'source');\n      var target = (0, util_1.getEdgeTerminal)(edge, 'target');\n\n      if (_this.layoutNode(source) && _this.layoutNode(target)) {\n        g.setEdge(source, target, {\n          weight: edge.weight || 1\n        });\n      }\n    }); // 考虑增量图中的原始图\n\n    var prevGraph = undefined;\n\n    if (self.preset) {\n      prevGraph = new graph_1.Graph({\n        multigraph: true,\n        compound: true\n      });\n      self.preset.nodes.forEach(function (node) {\n        prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);\n      });\n    }\n\n    index_1.default.layout(g, {\n      prevGraph: prevGraph,\n      edgeLabelSpace: self.edgeLabelSpace,\n      keepNodeOrder: Boolean(!!self.nodeOrder),\n      nodeOrder: self.nodeOrder\n    });\n    var dBegin = [0, 0];\n\n    if (begin) {\n      var minX_1 = Infinity;\n      var minY_1 = Infinity;\n      g.nodes().forEach(function (node) {\n        var coord = g.node(node);\n        if (minX_1 > coord.x) minX_1 = coord.x;\n        if (minY_1 > coord.y) minY_1 = coord.y;\n      });\n      g.edges().forEach(function (edge) {\n        var _a;\n\n        var coord = g.edge(edge);\n        (_a = coord.points) === null || _a === void 0 ? void 0 : _a.forEach(function (point) {\n          if (minX_1 > point.x) minX_1 = point.x;\n          if (minY_1 > point.y) minY_1 = point.y;\n        });\n      });\n      dBegin[0] = begin[0] - minX_1;\n      dBegin[1] = begin[1] - minY_1;\n    } // 变形为辐射\n\n\n    if (radial) {\n      var _b = this,\n          focusNode = _b.focusNode,\n          ranksep = _b.ranksep,\n          getRadialPos_1 = _b.getRadialPos;\n\n      var focusId = (0, util_1.isString)(focusNode) ? focusNode : focusNode === null || focusNode === void 0 ? void 0 : focusNode.id;\n      var focusLayer_1 = focusId ? (_a = g.node(focusId)) === null || _a === void 0 ? void 0 : _a._rank : 0;\n      var layers_1 = [];\n      var isHorizontal = rankdir === 'LR' || rankdir === 'RL';\n      var dim_1 = isHorizontal ? 'y' : 'x';\n      var sizeDim_1 = isHorizontal ? 'height' : 'width'; // 找到整个图作为环的坐标维度（dim）的最大、最小值，考虑节点宽度\n\n      var min_1 = Infinity;\n      var max_1 = -Infinity;\n      g.nodes().forEach(function (node) {\n        var coord = g.node(node);\n        var i = nodes.findIndex(function (it) {\n          return it.id === node;\n        });\n        if (!nodes[i]) return;\n        var currentNodesep = nodesepfunc(nodes[i]);\n\n        if (focusLayer_1 === 0) {\n          if (!layers_1[coord._rank]) layers_1[coord._rank] = {\n            nodes: [],\n            totalWidth: 0,\n            maxSize: -Infinity\n          };\n\n          layers_1[coord._rank].nodes.push(node);\n\n          layers_1[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n          if (layers_1[coord._rank].maxSize < Math.max(coord.width, coord.height)) layers_1[coord._rank].maxSize = Math.max(coord.width, coord.height);\n        } else {\n          var diffLayer = coord._rank - focusLayer_1;\n\n          if (diffLayer === 0) {\n            if (!layers_1[diffLayer]) layers_1[diffLayer] = {\n              nodes: [],\n              totalWidth: 0,\n              maxSize: -Infinity\n            };\n            layers_1[diffLayer].nodes.push(node);\n            layers_1[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n            if (layers_1[diffLayer].maxSize < Math.max(coord.width, coord.height)) layers_1[diffLayer].maxSize = Math.max(coord.width, coord.height);\n          } else {\n            var diffLayerAbs = Math.abs(diffLayer);\n            if (!layers_1[diffLayerAbs]) layers_1[diffLayerAbs] = {\n              left: [],\n              right: [],\n              totalWidth: 0,\n              maxSize: -Infinity\n            };\n            layers_1[diffLayerAbs].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n            if (layers_1[diffLayerAbs].maxSize < Math.max(coord.width, coord.height)) layers_1[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);\n\n            if (diffLayer < 0) {\n              layers_1[diffLayerAbs].left.push(node);\n            } else {\n              layers_1[diffLayerAbs].right.push(node);\n            }\n          }\n        }\n\n        var leftPos = coord[dim_1] - coord[sizeDim_1] / 2 - currentNodesep;\n        var rightPos = coord[dim_1] + coord[sizeDim_1] / 2 + currentNodesep;\n        if (leftPos < min_1) min_1 = leftPos;\n        if (rightPos > max_1) max_1 = rightPos;\n      }); // const padding = (max - min) * 0.1; // TODO\n      // \b初始化为第一圈的半径，后面根据每层 ranksep 叠加\n\n      var radius_1 = ranksep || 50; // TODO;\n\n      var radiusMap_1 = {}; // 扩大最大最小值范围，以便为环上留出接缝处的空隙\n\n      var rangeLength_1 = (max_1 - min_1) / 0.9;\n      var range_1 = [(min_1 + max_1 - rangeLength_1) * 0.5, (min_1 + max_1 + rangeLength_1) * 0.5]; // 根据半径、分布比例，计算节点在环上的位置，并返回该组节点中最大的 ranksep 值\n\n      var processNodes_1 = function processNodes_1(layerNodes, radius, propsMaxRanksep, arcRange) {\n        if (propsMaxRanksep === void 0) {\n          propsMaxRanksep = -Infinity;\n        }\n\n        if (arcRange === void 0) {\n          arcRange = [0, 1];\n        }\n\n        var maxRanksep = propsMaxRanksep;\n        layerNodes.forEach(function (node) {\n          var coord = g.node(node);\n          radiusMap_1[node] = radius; // 获取变形为 radial 后的直角坐标系坐标\n\n          var _a = getRadialPos_1(coord[dim_1], range_1, rangeLength_1, radius, arcRange),\n              newX = _a.x,\n              newY = _a.y; // 将新坐标写入源数据\n\n\n          var i = nodes.findIndex(function (it) {\n            return it.id === node;\n          });\n          if (!nodes[i]) return;\n          nodes[i].x = newX + dBegin[0];\n          nodes[i].y = newY + dBegin[1]; // @ts-ignore: pass layer order to data for increment layout use\n\n          nodes[i]._order = coord._order; // 找到本层最大的一个 ranksep，作为下一层与本层的间隙，叠加到下一层的半径上\n\n          var currentNodeRanksep = ranksepfunc(nodes[i]);\n          if (maxRanksep < currentNodeRanksep) maxRanksep = currentNodeRanksep;\n        });\n        return maxRanksep;\n      };\n\n      var isFirstLevel_1 = true;\n      var lastLayerMaxNodeSize_1 = 0;\n      layers_1.forEach(function (layerNodes) {\n        var _a, _b, _c, _d, _e, _f, _g;\n\n        if (!((_a = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.nodes) === null || _a === void 0 ? void 0 : _a.length) && !((_b = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.left) === null || _b === void 0 ? void 0 : _b.length) && !((_c = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.right) === null || _c === void 0 ? void 0 : _c.length)) return; // 第一层只有一个节点，直接放在圆心，初始半径设定为 0\n\n        if (isFirstLevel_1 && layerNodes.nodes.length === 1) {\n          // 将新坐标写入源数据\n          var i = nodes.findIndex(function (it) {\n            return it.id === layerNodes.nodes[0];\n          });\n          nodes[i].x = dBegin[0];\n          nodes[i].y = dBegin[1];\n          radiusMap_1[layerNodes.nodes[0]] = 0;\n          radius_1 = ranksepfunc(nodes[i]);\n          isFirstLevel_1 = false;\n          return;\n        } // 为接缝留出空隙，半径也需要扩大\n\n\n        radius_1 = Math.max(radius_1, layerNodes.totalWidth / (2 * Math.PI)); // / 0.9;\n\n        var maxRanksep = -Infinity;\n\n        if (focusLayer_1 === 0 || ((_d = layerNodes.nodes) === null || _d === void 0 ? void 0 : _d.length)) {\n          maxRanksep = processNodes_1(layerNodes.nodes, radius_1, maxRanksep, [0, 1]); // 0.8\n        } else {\n          var leftRatio = ((_e = layerNodes.left) === null || _e === void 0 ? void 0 : _e.length) / (((_f = layerNodes.left) === null || _f === void 0 ? void 0 : _f.length) + ((_g = layerNodes.right) === null || _g === void 0 ? void 0 : _g.length));\n          maxRanksep = processNodes_1(layerNodes.left, radius_1, maxRanksep, [0, leftRatio]); // 接缝留出 0.05 的缝隙\n\n          maxRanksep = processNodes_1(layerNodes.right, radius_1, maxRanksep, [leftRatio + 0.05, 1]); // 接缝留出 0.05 的缝隙\n        }\n\n        radius_1 += maxRanksep;\n        isFirstLevel_1 = false;\n        lastLayerMaxNodeSize_1 - layerNodes.maxSize;\n      });\n      g.edges().forEach(function (edge) {\n        var _a, _b, _c;\n\n        var coord = g.edge(edge);\n        var i = edges.findIndex(function (it) {\n          var source = (0, util_1.getEdgeTerminal)(it, 'source');\n          var target = (0, util_1.getEdgeTerminal)(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n\n        if (self.edgeLabelSpace && self.controlPoints && edges[i].type !== \"loop\") {\n          var otherDim_1 = dim_1 === 'x' ? 'y' : 'x';\n          var controlPoints = (_a = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a === void 0 ? void 0 : _a.slice(1, coord.points.length - 1);\n          var newControlPoints_1 = [];\n          var sourceOtherDimValue_1 = (_b = g.node(edge.v)) === null || _b === void 0 ? void 0 : _b[otherDim_1];\n          var otherDimDist_1 = sourceOtherDimValue_1 - ((_c = g.node(edge.w)) === null || _c === void 0 ? void 0 : _c[otherDim_1]);\n          var sourceRadius_1 = radiusMap_1[edge.v];\n          var radiusDist_1 = sourceRadius_1 - radiusMap_1[edge.w];\n          controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.forEach(function (point) {\n            // 根据该边的起点、终点半径，及起点、终点、控制点位置关系，确定该控制点的半径\n            var cRadius = (point[otherDim_1] - sourceOtherDimValue_1) / otherDimDist_1 * radiusDist_1 + sourceRadius_1; // 获取变形为 radial 后的直角坐标系坐标\n\n            var newPos = getRadialPos_1(point[dim_1], range_1, rangeLength_1, cRadius);\n            newControlPoints_1.push({\n              x: newPos.x + dBegin[0],\n              y: newPos.y + dBegin[1]\n            });\n          });\n          edges[i].controlPoints = newControlPoints_1;\n        }\n      });\n    } else {\n      g.nodes().forEach(function (node) {\n        var coord = g.node(node);\n        var i = nodes.findIndex(function (it) {\n          return it.id === node;\n        });\n        if (!nodes[i]) return;\n        nodes[i].x = coord.x + dBegin[0];\n        nodes[i].y = coord.y + dBegin[1]; // @ts-ignore: pass layer order to data for increment layout use\n\n        nodes[i]._order = coord._order;\n      });\n      g.edges().forEach(function (edge) {\n        var _a;\n\n        var coord = g.edge(edge);\n        var i = edges.findIndex(function (it) {\n          var source = (0, util_1.getEdgeTerminal)(it, 'source');\n          var target = (0, util_1.getEdgeTerminal)(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n\n        if (self.edgeLabelSpace && self.controlPoints && edges[i].type !== \"loop\") {\n          edges[i].controlPoints = (_a = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a === void 0 ? void 0 : _a.slice(1, coord.points.length - 1); // 去掉头尾\n\n          edges[i].controlPoints.forEach(function (point) {\n            point.x += dBegin[0];\n            point.y += dBegin[1];\n          });\n        }\n      });\n    }\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  };\n\n  DagreLayout.prototype.getRadialPos = function (dimValue, range, rangeLength, radius, arcRange) {\n    if (arcRange === void 0) {\n      arcRange = [0, 1];\n    } // dimRatio 占圆弧的比例\n\n\n    var dimRatio = (dimValue - range[0]) / rangeLength; // 再进一步归一化到指定的范围上\n\n    dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0]; // 使用最终归一化后的范围计算角度\n\n    var angle = dimRatio * 2 * Math.PI; // 弧度\n    // 将极坐标系转换为直角坐标系\n\n    return {\n      x: Math.cos(angle) * radius,\n      y: Math.sin(angle) * radius\n    };\n  };\n\n  DagreLayout.prototype.getType = function () {\n    return \"dagre\";\n  };\n\n  return DagreLayout;\n}(base_1.Base);\n\nexports.DagreLayout = DagreLayout;","map":null,"metadata":{},"sourceType":"script"}