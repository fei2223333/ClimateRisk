{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar Grid = /*#__PURE__*/function () {\n  function Grid() {\n    _classCallCheck(this, Grid);\n\n    this.cells = [];\n    this.columnNum = 0;\n    this.rowNum = 0;\n    this.additionColumn = [];\n    this.additionRow = [];\n  }\n\n  _createClass(Grid, [{\n    key: \"init\",\n    value: function init(width, height, gridSize) {\n      this.cells = [];\n      this.CELL_W = gridSize.CELL_W || Grid.DEFAULT_CELL_W;\n      this.CELL_H = gridSize.CELL_H || Grid.DEFAULT_CELL_H;\n      this.columnNum = Math.ceil(width / this.CELL_W);\n      this.rowNum = Math.ceil(height / this.CELL_H);\n      Grid.MIN_DIST = Math.pow(width, 2) + Math.pow(height, 2);\n\n      for (var i = 0; i < this.columnNum; i++) {\n        var tmp = [];\n\n        for (var j = 0; j < this.rowNum; j++) {\n          var cell = {\n            dx: i,\n            dy: j,\n            x: i * this.CELL_W,\n            y: j * this.CELL_H,\n            occupied: false\n          };\n          tmp.push(cell);\n        }\n\n        this.cells.push(tmp);\n      }\n    }\n  }, {\n    key: \"findGridByNodeId\",\n    value: function findGridByNodeId(nodeId) {\n      var _a, _b;\n\n      for (var i = 0; i < this.columnNum; i++) {\n        for (var j = 0; j < this.rowNum; j++) {\n          if (this.cells[i][j].node) {\n            if (((_b = (_a = this.cells[i][j]) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.id) === nodeId) {\n              return {\n                column: i,\n                row: j\n              };\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"sqdist\",\n    value: function sqdist(a, b) {\n      return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n    }\n  }, {\n    key: \"occupyNearest\",\n    value: function occupyNearest(p) {\n      var minDist = Grid.MIN_DIST;\n      var d;\n      var candidate = null;\n\n      for (var i = 0; i < this.columnNum; i++) {\n        for (var j = 0; j < this.rowNum; j++) {\n          if (!this.cells[i][j].occupied && (d = this.sqdist(p, this.cells[i][j])) < minDist) {\n            minDist = d;\n            candidate = this.cells[i][j];\n          }\n        }\n      }\n\n      if (candidate) {\n        candidate.occupied = true;\n      }\n\n      return candidate;\n    }\n  }, {\n    key: \"insertColumn\",\n    value: function insertColumn(columnIndex, length) {\n      if (length <= 0) return; // 插入空列\n\n      for (var i = 0; i < length; i++) {\n        this.cells[i + this.columnNum] = [];\n\n        for (var j = 0; j < this.rowNum; j++) {\n          this.cells[i + this.columnNum][j] = {\n            dx: i,\n            dy: j,\n            x: i * this.CELL_W,\n            y: j * this.CELL_H,\n            occupied: false,\n            node: null\n          };\n        }\n      } // 交换数据\n\n\n      for (var _i = this.columnNum - 1; _i > columnIndex; _i--) {\n        for (var _j = 0; _j < this.rowNum; _j++) {\n          this.cells[_i + length][_j] = Object.assign(Object.assign({}, this.cells[_i][_j]), {\n            x: (_i + length) * this.CELL_W,\n            y: _j * this.CELL_H\n          });\n          this.cells[_i][_j] = {\n            x: _i * this.CELL_W,\n            y: _j * this.CELL_H,\n            occupied: true,\n            node: null\n          };\n        }\n      } // 已有行列的处理\n\n\n      for (var _j2 = 0; _j2 < this.additionColumn.length; _j2++) {\n        if (this.additionColumn[_j2] >= columnIndex) {\n          this.additionColumn[_j2] += length;\n        }\n      } // 记录新增的行列\n\n\n      for (var _i2 = 0; _i2 < length; _i2++) {\n        this.additionColumn.push(columnIndex + _i2 + 1);\n      }\n\n      this.columnNum += length;\n    }\n  }, {\n    key: \"insertRow\",\n    value: function insertRow(rowIndex, length) {\n      if (length <= 0) return; // 插入空行\n\n      for (var j = 0; j < length; j++) {\n        for (var i = 0; i < this.columnNum; i++) {\n          this.cells[i][j + this.rowNum] = {\n            dx: i,\n            dy: j,\n            x: i * this.CELL_W,\n            y: j * this.CELL_H,\n            occupied: false,\n            node: null\n          };\n        }\n      } // 交换数据\n\n\n      for (var _i3 = 0; _i3 < this.columnNum; _i3++) {\n        for (var _j3 = this.rowNum - 1; _j3 > rowIndex; _j3--) {\n          this.cells[_i3][_j3 + length] = Object.assign(Object.assign({}, this.cells[_i3][_j3]), {\n            dx: _i3,\n            dy: _j3 + length,\n            x: _i3 * this.CELL_W,\n            y: (_j3 + length) * this.CELL_H\n          });\n          this.cells[_i3][_j3] = {\n            dx: _i3,\n            dy: _j3,\n            x: _i3 * this.CELL_W,\n            y: _j3 * this.CELL_H,\n            occupied: false,\n            node: null\n          };\n        }\n      } // 已有行列的处理\n\n\n      for (var _j4 = 0; _j4 < this.additionRow.length; _j4++) {\n        if (this.additionRow[_j4] >= rowIndex) {\n          this.additionRow[_j4] += length;\n        }\n      } // 记录新增的行列\n\n\n      for (var _i4 = 0; _i4 < length; _i4++) {\n        this.additionRow.push(rowIndex + _i4 + 1);\n      }\n\n      this.rowNum += length;\n    }\n  }, {\n    key: \"getNodes\",\n    value: function getNodes() {\n      var nodes = [];\n\n      for (var i = 0; i < this.columnNum; i++) {\n        for (var j = 0; j < this.rowNum; j++) {\n          if (this.cells[i][j].node) {\n            nodes.push(this.cells[i][j]);\n          }\n        }\n      }\n\n      return nodes;\n    }\n  }]);\n\n  return Grid;\n}();\n\nexport { Grid as default };\nGrid.MIN_DIST = 50;\nGrid.DEFAULT_CELL_W = 80;\nGrid.DEFAULT_CELL_H = 80;","map":null,"metadata":{},"sourceType":"module"}