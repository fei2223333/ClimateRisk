{"ast":null,"code":"import _defineProperty from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt } from '../../util';\nimport { Marker } from '../marker';\n\nfunction qualify(value) {\n  return typeof value === 'string' || ObjectExt.isPlainObject(value);\n}\n\nexport var sourceMarker = {\n  qualify: qualify,\n  set: function set(marker, _ref) {\n    var view = _ref.view,\n        attrs = _ref.attrs;\n    return createMarker('marker-start', marker, view, attrs);\n  }\n};\nexport var targetMarker = {\n  qualify: qualify,\n  set: function set(marker, _ref2) {\n    var view = _ref2.view,\n        attrs = _ref2.attrs;\n    return createMarker('marker-end', marker, view, attrs, {\n      transform: 'rotate(180)'\n    });\n  }\n};\nexport var vertexMarker = {\n  qualify: qualify,\n  set: function set(marker, _ref3) {\n    var view = _ref3.view,\n        attrs = _ref3.attrs;\n    return createMarker('marker-mid', marker, view, attrs);\n  }\n};\n\nfunction createMarker(type, marker, view, attrs) {\n  var manual = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var def = typeof marker === 'string' ? {\n    name: marker\n  } : marker;\n\n  var name = def.name,\n      args = def.args,\n      others = __rest(def, [\"name\", \"args\"]);\n\n  var preset = others;\n\n  if (name && typeof name === 'string') {\n    var fn = Marker.registry.get(name);\n\n    if (fn) {\n      preset = fn(Object.assign(Object.assign({}, others), args));\n    } else {\n      return Marker.registry.onNotFound(name);\n    }\n  }\n\n  var options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);\n  return _defineProperty({}, type, \"url(#\".concat(view.graph.defineMarker(options), \")\"));\n}\n\nfunction normalizeAttr(attr, type) {\n  var result = {}; // The context 'fill' is disregared here. The usual case is to use the\n  // marker with a connection(for which 'fill' attribute is set to 'none').\n\n  var stroke = attr.stroke;\n\n  if (typeof stroke === 'string') {\n    result.stroke = stroke;\n    result.fill = stroke;\n  } // Again the context 'fill-opacity' is ignored.\n\n\n  var strokeOpacity = attr.strokeOpacity;\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr['stroke-opacity'];\n  }\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr.opacity;\n  }\n\n  if (strokeOpacity != null) {\n    result['stroke-opacity'] = strokeOpacity;\n    result['fill-opacity'] = strokeOpacity;\n  }\n\n  if (type !== 'marker-mid') {\n    var strokeWidth = parseFloat(attr.strokeWidth || attr['stroke-width']);\n\n    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {\n      var offset = Math.ceil(strokeWidth / 2);\n      result.refX = type === 'marker-start' ? offset : -offset;\n    }\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}