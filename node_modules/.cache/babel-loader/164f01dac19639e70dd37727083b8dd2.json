{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { FunctionExt } from '../../../util';\nimport { Point, Rectangle } from '../../../geometry';\nimport { SortedSet } from './sorted-set';\nimport { ObstacleMap } from './obstacle-map';\nimport * as util from './util';\nimport { resolveOptions } from './options';\n/**\n * Finds the route between two points (`from`, `to`).\n */\n\nfunction findRoute(edgeView, from, to, map, options) {\n  var precision = options.precision;\n  var sourceEndpoint;\n  var targetEndpoint;\n\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(util.getSourceEndpoint(edgeView, options).clone(), precision);\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision);\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(util.getTargetEndpoint(edgeView, options).clone(), precision);\n  } else {\n    targetEndpoint = util.round(to.clone(), precision);\n  } // Get grid for this route.\n\n\n  var grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint); // Get pathfinding points.\n  // -----------------------\n\n  var startPoint = sourceEndpoint;\n  var endPoint = targetEndpoint;\n  var startPoints;\n  var endPoints;\n\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(startPoint, from, options.startDirections, grid, options);\n  } else {\n    startPoints = [startPoint];\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);\n  } else {\n    endPoints = [endPoint];\n  } // take into account only accessible rect points (those not under obstacles)\n\n\n  startPoints = startPoints.filter(function (p) {\n    return map.isAccessible(p);\n  });\n  endPoints = endPoints.filter(function (p) {\n    return map.isAccessible(p);\n  }); // There is an accessible route point on both sides.\n\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    var openSet = new SortedSet(); // Keeps the actual points for given nodes of the open set.\n\n    var points = {}; // Keeps the point that is immediate predecessor of given element.\n\n    var parents = {}; // Cost from start to a point along best known path.\n\n    var costs = {};\n\n    for (var i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      var _startPoint = startPoints[i];\n      var key = util.getKey(_startPoint);\n      openSet.add(key, util.getCost(_startPoint, endPoints));\n      points[key] = _startPoint;\n      costs[key] = 0;\n    }\n\n    var previousRouteDirectionAngle = options.previousDirectionAngle; // undefined for first route\n\n    var isPathBeginning = previousRouteDirectionAngle === undefined; // directions\n\n    var direction;\n    var directionChange;\n    var directions = util.getGridOffsets(grid, options);\n    var numDirections = directions.length;\n    var endPointsKeys = endPoints.reduce(function (res, endPoint) {\n      var key = util.getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []); // main route finding loop\n\n    var sameStartEndPoints = Point.equalPoints(startPoints, endPoints);\n    var loopsRemaining = options.maxLoopCount;\n\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      var currentKey = openSet.pop();\n      var currentPoint = points[currentKey];\n      var currentParent = parents[currentKey];\n      var currentCost = costs[currentKey];\n      var isStartPoint = currentPoint.equals(startPoint);\n      var isRouteBeginning = currentParent == null;\n      var previousDirectionAngle = void 0;\n\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle;\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);\n      } else {\n        previousDirectionAngle = null;\n      } // Check if we reached any endpoint\n\n\n      var skipEndCheck = isRouteBeginning && sameStartEndPoints;\n\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle;\n        return util.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);\n      } // Go over all possible directions and find neighbors\n\n\n      for (var _i = 0; _i < numDirections; _i += 1) {\n        direction = directions[_i];\n        var directionAngle = direction.angle;\n        directionChange = util.getDirectionChange(previousDirectionAngle, directionAngle); // Don't use the point changed rapidly.\n\n        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {\n          continue;\n        }\n\n        var neighborPoint = util.align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);\n        var neighborKey = util.getKey(neighborPoint); // Closed points were already evaluated.\n\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue;\n        } // Neighbor is an end point.\n\n\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          var isEndPoint = neighborPoint.equals(endPoint);\n\n          if (!isEndPoint) {\n            var endDirectionAngle = util.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);\n            var endDirectionChange = util.getDirectionChange(directionAngle, endDirectionAngle);\n\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue;\n            }\n          }\n        } // The current direction is ok.\n        // ----------------------------\n\n\n        var neighborCost = direction.cost;\n        var neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];\n        var costFromStart = currentCost + neighborCost + neighborPenalty; // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + util.getCost(neighborPoint, endPoints));\n        }\n      }\n\n      loopsRemaining -= 1;\n    }\n  }\n\n  if (options.fallbackRoute) {\n    return FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);\n  }\n\n  return null;\n}\n\nexport var router = function router(vertices, optionsRaw, edgeView) {\n  var options = resolveOptions(optionsRaw);\n  var sourceBBox = util.getSourceBBox(edgeView, options);\n  var targetBBox = util.getTargetBBox(edgeView, options);\n  var sourceEndpoint = util.getSourceEndpoint(edgeView, options); // pathfinding\n\n  var map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);\n  var oldVertices = vertices.map(function (p) {\n    return Point.create(p);\n  });\n  var newVertices = []; // The origin of first route's grid, does not need snapping\n\n  var tailPoint = sourceEndpoint;\n  var from;\n  var to;\n\n  for (var i = 0, len = oldVertices.length; i <= len; i += 1) {\n    var partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i]; // This is the last iteration\n\n    if (to == null) {\n      to = targetBBox; // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n\n      var edge = edgeView.cell;\n      var isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;\n\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        var dragFrom = from === sourceBBox ? sourceEndpoint : from;\n        var dragTo = to.getOrigin();\n        partialRoute = FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);\n      }\n    } // Find the partial route\n\n\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options);\n    } // Cannot found the partial route.\n\n\n    if (partialRoute === null) {\n      return FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);\n    } // Remove the first point if the previous partial route has\n    // the same point as last.\n\n\n    var leadPoint = partialRoute[0];\n\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift();\n    } // Save tailPoint for next iteration\n\n\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    newVertices.push.apply(newVertices, _toConsumableArray(partialRoute));\n  }\n\n  return newVertices;\n};","map":null,"metadata":{},"sourceType":"module"}