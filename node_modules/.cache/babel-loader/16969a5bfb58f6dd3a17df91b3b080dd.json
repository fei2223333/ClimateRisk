{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Angle, Point, Line } from '../../geometry';\n\nfunction rollup(points, merge) {\n  if (merge != null && merge !== false) {\n    var amount = typeof merge === 'boolean' ? 0 : merge;\n\n    if (amount > 0) {\n      var center1 = Point.create(points[1]).move(points[2], amount);\n      var center2 = Point.create(points[1]).move(points[0], amount);\n      return [center1.toJSON()].concat(_toConsumableArray(points), [center2.toJSON()]);\n    }\n\n    {\n      var center = points[1];\n      return [Object.assign({}, center)].concat(_toConsumableArray(points), [Object.assign({}, center)]);\n    }\n  }\n\n  return points;\n}\n\nexport var loop = function loop(vertices, options, edgeView) {\n  var width = options.width || 50;\n  var height = options.height || 80;\n  var halfHeight = height / 2;\n  var angle = options.angle || 'auto';\n  var sourceAnchor = edgeView.sourceAnchor;\n  var targetAnchor = edgeView.targetAnchor;\n  var sourceBBox = edgeView.sourceBBox;\n  var targetBBox = edgeView.targetBBox;\n\n  if (sourceAnchor.equals(targetAnchor)) {\n    var getVertices = function getVertices(angle) {\n      var rad = Angle.toRad(angle);\n      var sin = Math.sin(rad);\n      var cos = Math.cos(rad);\n      var center = new Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);\n      var ref = new Point(center.x - cos * halfHeight, center.y - sin * halfHeight);\n      var p1 = ref.clone().rotate(-90, center);\n      var p2 = ref.clone().rotate(90, center);\n      return [p1.toJSON(), center.toJSON(), p2.toJSON()];\n    };\n\n    var validate = function validate(end) {\n      var start = sourceAnchor.clone().move(end, -1);\n      var line = new Line(start, end);\n      return !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line);\n    };\n\n    var angles = [0, 90, 180, 270, 45, 135, 225, 315];\n\n    if (typeof angle === 'number') {\n      return rollup(getVertices(angle), options.merge);\n    }\n\n    var center = sourceBBox.getCenter();\n\n    if (center.equals(sourceAnchor)) {\n      return rollup(getVertices(0), options.merge);\n    }\n\n    var deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));\n    var ret = getVertices(deg);\n\n    if (validate(ret[1])) {\n      return rollup(ret, options.merge);\n    } // return the best vertices\n\n\n    for (var i = 1, l = angles.length; i < l; i += 1) {\n      ret = getVertices(deg + angles[i]);\n\n      if (validate(ret[1])) {\n        return rollup(ret, options.merge);\n      }\n    }\n\n    return rollup(ret, options.merge);\n  }\n\n  {\n    var line = new Line(sourceAnchor, targetAnchor);\n    var parallel = line.parallel(-width);\n\n    var _center = parallel.getCenter();\n\n    var p1 = parallel.start.clone().move(parallel.end, halfHeight);\n    var p2 = parallel.end.clone().move(parallel.start, halfHeight);\n    var ref = line.parallel(-1);\n    var line1 = new Line(ref.start, _center);\n    var line2 = new Line(ref.end, _center);\n\n    if (sourceBBox.containsPoint(_center) || targetBBox.containsPoint(_center) || sourceBBox.intersectsWithLine(line1) || sourceBBox.intersectsWithLine(line2) || targetBBox.intersectsWithLine(line1) || targetBBox.intersectsWithLine(line2)) {\n      parallel = line.parallel(width);\n      _center = parallel.getCenter();\n      p1 = parallel.start.clone().move(parallel.end, halfHeight);\n      p2 = parallel.end.clone().move(parallel.start, halfHeight);\n    }\n\n    if (options.merge) {\n      var _line = new Line(sourceAnchor, targetAnchor);\n\n      var normal = new Line(_center, _line.center).setLength(Number.MAX_SAFE_INTEGER);\n      var intersects1 = sourceBBox.intersectsWithLine(normal);\n      var intersects2 = targetBBox.intersectsWithLine(normal);\n      var intersects = intersects1 ? Array.isArray(intersects1) ? intersects1 : [intersects1] : [];\n\n      if (intersects2) {\n        if (Array.isArray(intersects2)) {\n          intersects.push.apply(intersects, _toConsumableArray(intersects2));\n        } else {\n          intersects.push(intersects2);\n        }\n      }\n\n      var anchor = _line.center.closest(intersects);\n\n      if (anchor) {\n        edgeView.sourceAnchor = anchor.clone();\n        edgeView.targetAnchor = anchor.clone();\n      } else {\n        edgeView.sourceAnchor = _line.center.clone();\n        edgeView.targetAnchor = _line.center.clone();\n      }\n    }\n\n    return rollup([p1.toJSON(), _center.toJSON(), p2.toJSON()], options.merge);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}