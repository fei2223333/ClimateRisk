{"ast":null,"code":"export var Scheduler;\n\n(function (Scheduler) {\n  var queue = [];\n  var threshold = 1000 / 60;\n  var unit = [];\n  var deadline = 0;\n\n  var getTime = function getTime() {\n    return performance.now();\n  };\n\n  var peek = function peek(queue) {\n    return queue[0];\n  };\n\n  var schedule = function schedule(cb) {\n    return unit.push(cb) === 1 && postMessage();\n  };\n\n  var postMessage = function () {\n    var cb = function cb() {\n      return unit.splice(0, unit.length).forEach(function (c) {\n        return c();\n      });\n    };\n\n    if (typeof MessageChannel !== 'undefined') {\n      var _MessageChannel = new MessageChannel(),\n          port1 = _MessageChannel.port1,\n          port2 = _MessageChannel.port2;\n\n      port1.onmessage = cb;\n      return function () {\n        return port2.postMessage(null);\n      };\n    }\n\n    return function () {\n      return setTimeout(cb);\n    };\n  }();\n\n  var flushTask = function flushTask() {\n    deadline = getTime() + threshold;\n    var job = peek(queue);\n\n    while (job && !Scheduler.shouldYield()) {\n      var _job = job,\n          callback = _job.callback,\n          data = _job.data;\n      job.callback = null;\n      var next = callback && callback(data);\n\n      if (next) {\n        job.callback = next;\n      } else {\n        queue.shift();\n      }\n\n      job = peek(queue);\n    }\n\n    job && schedule(flushTask);\n  };\n\n  Scheduler.scheduleTask = function (callback, data) {\n    var task = {\n      callback: callback,\n      data: data\n    };\n    queue.push(task);\n    schedule(flushTask);\n  };\n\n  Scheduler.shouldYield = function () {\n    var _a, _b;\n\n    return ((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline;\n  };\n})(Scheduler || (Scheduler = {}));","map":null,"metadata":{},"sourceType":"module"}