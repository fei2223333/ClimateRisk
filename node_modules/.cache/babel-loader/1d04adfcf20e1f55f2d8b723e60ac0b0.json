{"ast":null,"code":"import _defineProperty from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { FunctionExt } from '../../util';\nimport { View } from '../../view/view';\nimport { Graph } from '../../graph/graph';\nimport { Point } from '../../geometry';\nvar ClassName;\n\n(function (ClassName) {\n  ClassName.root = 'widget-minimap';\n  ClassName.viewport = \"\".concat(ClassName.root, \"-viewport\");\n  ClassName.zoom = \"\".concat(ClassName.viewport, \"-zoom\");\n})(ClassName || (ClassName = {}));\n\nexport var MiniMap = /*#__PURE__*/function (_View) {\n  _inherits(MiniMap, _View);\n\n  function MiniMap(options) {\n    var _this;\n\n    _classCallCheck(this, MiniMap);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MiniMap).call(this));\n    _this.options = Object.assign(Object.assign({}, Util.defaultOptions), options);\n    _this.updateViewport = FunctionExt.debounce(_this.updateViewport.bind(_assertThisInitialized(_assertThisInitialized(_this))), 0);\n    _this.container = document.createElement('div');\n    _this.$container = _this.$(_this.container).addClass(_this.prefixClassName(ClassName.root));\n    var graphContainer = document.createElement('div');\n\n    _this.container.appendChild(graphContainer);\n\n    _this.$viewport = _this.$('<div>').addClass(_this.prefixClassName(ClassName.viewport));\n\n    if (_this.options.scalable) {\n      _this.zoomHandle = _this.$('<div>').addClass(_this.prefixClassName(ClassName.zoom)).appendTo(_this.$viewport).get(0);\n    }\n\n    _this.$container.append(_this.$viewport).css({\n      width: _this.options.width,\n      height: _this.options.height,\n      padding: _this.options.padding\n    });\n\n    if (_this.options.container) {\n      _this.options.container.appendChild(_this.container);\n    }\n\n    _this.sourceGraph = _this.graph;\n    var targetGraphOptions = Object.assign(Object.assign({}, _this.options.graphOptions), {\n      container: graphContainer,\n      model: _this.sourceGraph.model,\n      frozen: true,\n      async: _this.sourceGraph.isAsync(),\n      interacting: false,\n      grid: false,\n      background: false,\n      rotating: false,\n      resizing: false,\n      embedding: false,\n      selecting: false,\n      snapline: false,\n      clipboard: false,\n      history: false,\n      scroller: false\n    });\n    _this.targetGraph = _this.options.createGraph ? _this.options.createGraph(targetGraphOptions) : new Graph(targetGraphOptions);\n\n    _this.targetGraph.renderer.unfreeze();\n\n    _this.updatePaper(_this.sourceGraph.options.width, _this.sourceGraph.options.height);\n\n    _this.startListening();\n\n    return _this;\n  }\n\n  _createClass(MiniMap, [{\n    key: \"startListening\",\n    value: function startListening() {\n      var _this$delegateEvents;\n\n      if (this.scroller) {\n        this.$graphContainer.on(\"scroll\".concat(this.getEventNamespace()), this.updateViewport);\n      } else {\n        this.sourceGraph.on('translate', this.onSourceGraphTransform, this);\n        this.sourceGraph.on('scale', this.onSourceGraphTransform, this);\n      }\n\n      this.sourceGraph.on('resize', this.updatePaper, this);\n      this.delegateEvents((_this$delegateEvents = {\n        mousedown: 'startAction',\n        touchstart: 'startAction'\n      }, _defineProperty(_this$delegateEvents, \"mousedown .\".concat(this.prefixClassName('graph')), 'scrollTo'), _defineProperty(_this$delegateEvents, \"touchstart .\".concat(this.prefixClassName('graph')), 'scrollTo'), _this$delegateEvents));\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      if (this.scroller) {\n        this.$graphContainer.off(this.getEventNamespace());\n      } else {\n        this.sourceGraph.off('translate', this.onSourceGraphTransform, this);\n        this.sourceGraph.off('scale', this.onSourceGraphTransform, this);\n      }\n\n      this.sourceGraph.off('resize', this.updatePaper, this);\n      this.undelegateEvents();\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.targetGraph.view.remove();\n      this.stopListening();\n      this.targetGraph.dispose();\n    }\n  }, {\n    key: \"onSourceGraphTransform\",\n    value: function onSourceGraphTransform() {\n      if (!this.targetGraphTransforming) {\n        this.updatePaper(this.sourceGraph.options.width, this.sourceGraph.options.height);\n      } else {\n        this.updateViewport();\n      }\n    }\n  }, {\n    key: \"updatePaper\",\n    value: function updatePaper(w, h) {\n      var width;\n      var height;\n\n      if (typeof w === 'object') {\n        width = w.width;\n        height = w.height;\n      } else {\n        width = w;\n        height = h;\n      }\n\n      var origin = this.sourceGraph.options;\n      var scale = this.sourceGraph.transform.getScale();\n      var maxWidth = this.options.width - 2 * this.options.padding;\n      var maxHeight = this.options.height - 2 * this.options.padding;\n      width /= scale.sx; // eslint-disable-line\n\n      height /= scale.sy; // eslint-disable-line\n\n      this.ratio = Math.min(maxWidth / width, maxHeight / height);\n      var ratio = this.ratio;\n      var x = origin.x * ratio / scale.sx;\n      var y = origin.y * ratio / scale.sy;\n      width *= ratio; // eslint-disable-line\n\n      height *= ratio; // eslint-disable-line\n\n      this.targetGraph.resizeGraph(width, height);\n      this.targetGraph.translate(x, y);\n      this.targetGraph.scale(ratio, ratio);\n      this.updateViewport();\n      return this;\n    }\n  }, {\n    key: \"updateViewport\",\n    value: function updateViewport() {\n      var ratio = this.ratio;\n      var scale = this.sourceGraph.transform.getScale();\n      var origin = null;\n\n      if (this.scroller) {\n        origin = this.scroller.clientToLocalPoint(0, 0);\n      } else {\n        var ctm = this.sourceGraph.matrix();\n        origin = new Point(-ctm.e / ctm.a, -ctm.f / ctm.d);\n      }\n\n      var position = this.$(this.targetGraph.container).position();\n      var translation = this.targetGraph.translate();\n      translation.ty = translation.ty || 0;\n      this.geometry = {\n        top: position.top + origin.y * ratio + translation.ty,\n        left: position.left + origin.x * ratio + translation.tx,\n        width: this.$graphContainer.innerWidth() * ratio / scale.sx,\n        height: this.$graphContainer.innerHeight() * ratio / scale.sy\n      };\n      this.$viewport.css(this.geometry);\n    }\n  }, {\n    key: \"startAction\",\n    value: function startAction(evt) {\n      var e = this.normalizeEvent(evt);\n      var action = e.target === this.zoomHandle ? 'zooming' : 'panning';\n\n      var _this$sourceGraph$tra = this.sourceGraph.translate(),\n          tx = _this$sourceGraph$tra.tx,\n          ty = _this$sourceGraph$tra.ty;\n\n      var eventData = {\n        action: action,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        scrollLeft: this.graphContainer.scrollLeft,\n        scrollTop: this.graphContainer.scrollTop,\n        zoom: this.sourceGraph.zoom(),\n        scale: this.sourceGraph.transform.getScale(),\n        geometry: this.geometry,\n        translateX: tx,\n        translateY: ty\n      };\n      this.targetGraphTransforming = true;\n      this.delegateDocumentEvents(Util.documentEvents, eventData);\n    }\n  }, {\n    key: \"doAction\",\n    value: function doAction(evt) {\n      var _this2 = this;\n\n      var e = this.normalizeEvent(evt);\n      var clientX = e.clientX;\n      var clientY = e.clientY;\n      var data = e.data;\n\n      switch (data.action) {\n        case 'panning':\n          {\n            var scale = this.sourceGraph.transform.getScale();\n            var rx = (clientX - data.clientX) * scale.sx;\n            var ry = (clientY - data.clientY) * scale.sy;\n\n            if (this.scroller) {\n              this.graphContainer.scrollLeft = data.scrollLeft + rx / this.ratio;\n              this.graphContainer.scrollTop = data.scrollTop + ry / this.ratio;\n            } else {\n              this.sourceGraph.translate(data.translateX - rx / this.ratio, data.translateY - ry / this.ratio);\n            }\n\n            break;\n          }\n\n        case 'zooming':\n          {\n            var startScale = data.scale;\n            var startGeometry = data.geometry;\n            var delta = 1 + (data.clientX - clientX) / startGeometry.width / startScale.sx;\n\n            if (data.frameId) {\n              cancelAnimationFrame(data.frameId);\n            }\n\n            data.frameId = requestAnimationFrame(function () {\n              _this2.sourceGraph.zoom(delta * data.zoom, {\n                absolute: true,\n                minScale: _this2.options.minScale,\n                maxScale: _this2.options.maxScale\n              });\n            });\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n  }, {\n    key: \"stopAction\",\n    value: function stopAction() {\n      this.undelegateDocumentEvents();\n      this.targetGraphTransforming = false;\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(evt) {\n      var e = this.normalizeEvent(evt);\n      var x;\n      var y;\n      var ts = this.targetGraph.translate();\n      ts.ty = ts.ty || 0;\n\n      if (e.offsetX == null) {\n        var offset = this.$(this.targetGraph.container).offset();\n        x = e.pageX - offset.left;\n        y = e.pageY - offset.top;\n      } else {\n        x = e.offsetX;\n        y = e.offsetY;\n      }\n\n      var cx = (x - ts.tx) / this.ratio;\n      var cy = (y - ts.ty) / this.ratio;\n      this.sourceGraph.centerPoint(cx, cy);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.remove();\n    }\n  }, {\n    key: \"graph\",\n    get: function get() {\n      return this.options.graph;\n    }\n  }, {\n    key: \"scroller\",\n    get: function get() {\n      return this.graph.scroller.widget;\n    }\n  }, {\n    key: \"graphContainer\",\n    get: function get() {\n      if (this.scroller) {\n        return this.scroller.container;\n      }\n\n      return this.graph.container;\n    }\n  }, {\n    key: \"$graphContainer\",\n    get: function get() {\n      if (this.scroller) {\n        return this.scroller.$container;\n      }\n\n      return this.$(this.graph.container);\n    }\n  }]);\n\n  return MiniMap;\n}(View);\n\n__decorate([View.dispose()], MiniMap.prototype, \"dispose\", null);\n\nvar Util;\n\n(function (Util) {\n  Util.defaultOptions = {\n    width: 300,\n    height: 200,\n    padding: 10,\n    scalable: true,\n    minScale: 0.01,\n    maxScale: 16,\n    graphOptions: {},\n    createGraph: function createGraph(options) {\n      return new Graph(options);\n    }\n  };\n  Util.documentEvents = {\n    mousemove: 'doAction',\n    touchmove: 'doAction',\n    mouseup: 'stopAction',\n    touchend: 'stopAction'\n  };\n})(Util || (Util = {}));","map":null,"metadata":{},"sourceType":"module"}