{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConcentricLayout = void 0;\n\nvar util_1 = require(\"../util\");\n\nvar base_1 = require(\"./base\");\n/**\n * 同心圆布局\n */\n\n\nvar ConcentricLayout =\n/** @class */\nfunction (_super) {\n  __extends(ConcentricLayout, _super);\n\n  function ConcentricLayout(options) {\n    var _this = _super.call(this) || this;\n\n    _this.nodeSize = 30;\n    /** min spacing between outside of nodes (used for radius adjustment) */\n\n    _this.minNodeSpacing = 10;\n    /** same as minNodeSpacing. min spacing between outside of nodes (used for radius adjustment) */\n\n    _this.nodeSpacing = 10;\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = false;\n    /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n\n    _this.equidistant = false;\n    /** where nodes start in radians */\n\n    _this.startAngle = 3 / 2 * Math.PI;\n    /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n\n    _this.clockwise = true;\n    /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n\n    _this.sortBy = \"degree\";\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  ConcentricLayout.prototype.getDefaultCfg = function () {\n    return {\n      nodeSize: 30,\n      minNodeSpacing: 10,\n      nodeSpacing: 10,\n      preventOverlap: false,\n      sweep: undefined,\n      equidistant: false,\n      startAngle: 3 / 2 * Math.PI,\n      clockwise: true,\n      maxLevelDiff: undefined,\n      sortBy: \"degree\"\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  ConcentricLayout.prototype.execute = function () {\n    var _a, _b;\n\n    var self = this;\n    var nodes = self.nodes,\n        edges = self.edges;\n    var n = nodes.length;\n\n    if (n === 0) {\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    var center = self.center;\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n      return;\n    }\n\n    var nodeSize = self.nodeSize,\n        nodeSpacing = self.nodeSpacing;\n    var layoutNodes = [];\n    var maxNodeSize;\n    var maxNodeSpacing = 0;\n\n    if ((0, util_1.isArray)(nodeSize)) {\n      maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);\n    } else {\n      maxNodeSize = nodeSize;\n    }\n\n    if ((0, util_1.isArray)(nodeSpacing)) {\n      maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);\n    } else if ((0, util_1.isNumber)(nodeSpacing)) {\n      maxNodeSpacing = nodeSpacing;\n    }\n\n    nodes.forEach(function (node) {\n      layoutNodes.push(node);\n      var nodeSize = maxNodeSize;\n\n      if ((0, util_1.isArray)(node.size)) {\n        nodeSize = Math.max(node.size[0], node.size[1]);\n      } else if ((0, util_1.isNumber)(node.size)) {\n        nodeSize = node.size;\n      } else if ((0, util_1.isObject)(node.size)) {\n        nodeSize = Math.max(node.size.width, node.size.height);\n      }\n\n      maxNodeSize = Math.max(maxNodeSize, nodeSize);\n\n      if ((0, util_1.isFunction)(nodeSpacing)) {\n        maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);\n      }\n    });\n    self.clockwise = self.counterclockwise !== undefined ? !self.counterclockwise : self.clockwise; // layout\n\n    var nodeMap = {};\n    var indexMap = {};\n    layoutNodes.forEach(function (node, i) {\n      nodeMap[node.id] = node;\n      indexMap[node.id] = i;\n    }); // get the node degrees\n\n    if (self.sortBy === \"degree\" || !(0, util_1.isString)(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = \"degree\";\n\n      if (!(0, util_1.isNumber)(nodes[0].degree)) {\n        var values_1 = (0, util_1.getDegree)(nodes.length, indexMap, edges);\n        layoutNodes.forEach(function (node, i) {\n          node.degree = values_1[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort(function (n1, n2) {\n      return n2[self.sortBy] - n1[self.sortBy];\n    });\n    self.maxValueNode = layoutNodes[0];\n    self.maxLevelDiff = self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4; // put the values into levels\n\n    var levels = [[]];\n    var currentLevel = levels[0];\n    layoutNodes.forEach(function (node) {\n      if (currentLevel.length > 0) {\n        var diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n\n        if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n\n      currentLevel.push(node);\n    }); // create positions for levels\n\n    var minDist = maxNodeSize + (maxNodeSpacing || self.minNodeSpacing); // min dist between nodes\n\n    if (!self.preventOverlap) {\n      // then strictly constrain to bb\n      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      var maxR = Math.min(self.width, self.height) / 2 - minDist;\n      var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n      minDist = Math.min(minDist, rStep);\n    } // find the metrics for each level\n\n\n    var r = 0;\n    levels.forEach(function (level) {\n      var sweep = self.sweep;\n\n      if (sweep === undefined) {\n        sweep = 2 * Math.PI - 2 * Math.PI / level.length;\n      }\n\n      var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n      if (level.length > 1 && self.preventOverlap) {\n        // but only if more than one node (can't overlap)\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n        r = Math.max(rMin, r);\n      }\n\n      level.r = r;\n      r += minDist;\n    });\n\n    if (self.equidistant) {\n      var rDeltaMax_1 = 0;\n      var rr_1 = 0;\n\n      for (var i = 0; i < levels.length; i++) {\n        var level = levels[i];\n        var rDelta = level.r - rr_1;\n        rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);\n      }\n\n      rr_1 = 0;\n      levels.forEach(function (level, i) {\n        if (i === 0) {\n          rr_1 = level.r;\n        }\n\n        level.r = rr_1;\n        rr_1 += rDeltaMax_1;\n      });\n    } // calculate the node positions\n\n\n    levels.forEach(function (level) {\n      var dTheta = level.dTheta;\n      var rr = level.r;\n      level.forEach(function (node, j) {\n        var theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n        node.x = center[0] + rr * Math.cos(theta);\n        node.y = center[1] + rr * Math.sin(theta);\n      });\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  };\n\n  ConcentricLayout.prototype.getType = function () {\n    return \"concentric\";\n  };\n\n  return ConcentricLayout;\n}(base_1.Base);\n\nexports.ConcentricLayout = ConcentricLayout;","map":null,"metadata":{},"sourceType":"script"}