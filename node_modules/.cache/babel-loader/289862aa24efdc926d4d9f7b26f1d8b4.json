{"ast":null,"code":"import { Graph, Path, Registry, Shape } from '@antv/x6';\nimport { EDGE_PATH_TYPE, XFLOW_SHAPE } from '../constants';\n\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.VERTICAL_NODE)) {\n  Graph.registerConnector(EDGE_PATH_TYPE.VERTICAL_NODE, function (s, e) {\n    var offset = 16;\n    var deltaY = Math.abs(e.y - s.y);\n    var control = Math.floor(deltaY / 3 * 2);\n    var v1 = {\n      x: s.x,\n      y: s.y + offset + control\n    };\n    var v2 = {\n      x: e.x,\n      y: e.y - offset - control\n    };\n    return Path.normalize(\"M \".concat(s.x, \" \").concat(s.y, \"\\n         L \").concat(s.x, \" \").concat(s.y + offset, \"\\n         C \").concat(v1.x, \" \").concat(v1.y, \" \").concat(v2.x, \" \").concat(v2.y, \" \").concat(e.x, \" \").concat(e.y - offset, \"\\n         L \").concat(e.x, \" \").concat(e.y, \"\\n        \"));\n  }, true);\n}\n\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.VERTICAL_GROUP)) {\n  Graph.registerConnector(EDGE_PATH_TYPE.VERTICAL_GROUP, function (s, t) {\n    var offset = 4;\n    var control = Math.abs(t.y - s.y);\n    var v1 = {\n      x: s.x,\n      y: s.y + offset + control\n    };\n    var v2 = {\n      x: t.x,\n      y: t.y - offset - control\n    };\n    return Path.normalize(\"M \".concat(s.x, \" \").concat(s.y, \"\\n       L \").concat(s.x, \" \").concat(s.y + offset, \"\\n       C \").concat(v1.x, \" \").concat(v1.y, \" \").concat(v2.x, \" \").concat(v2.y, \" \").concat(t.x, \" \").concat(t.y - offset, \"\\n       L \").concat(t.x, \" \").concat(t.y, \"\\n      \"));\n  }, true);\n} // TODO: fix this vertical function\n\n\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.HORIRONTAL_NODE)) {\n  Graph.registerConnector(EDGE_PATH_TYPE.HORIRONTAL_NODE, function (s, e) {\n    var offset = 4; // const control = 80;\n\n    var deltaY = Math.abs(e.y - s.y);\n    var control = Math.floor(deltaY / 3 * 2);\n    var v1 = {\n      x: s.x,\n      y: s.y + offset + control\n    };\n    var v2 = {\n      x: e.x,\n      y: e.y - offset - control\n    };\n    return Path.normalize(\"M \".concat(s.x, \" \").concat(s.y, \"\\n         L \").concat(s.x, \" \").concat(s.y + offset, \"\\n         C \").concat(v1.x, \" \").concat(v1.y, \" \").concat(v2.x, \" \").concat(v2.y, \" \").concat(e.x, \" \").concat(e.y - offset, \"\\n         L \").concat(e.x, \" \").concat(e.y, \"\\n        \"));\n  }, true);\n}\n\nvar XFlowEdge = Shape.Edge.registry.get(XFLOW_SHAPE.EDGE);\n\nif (!Shape.Edge.registry.exist(XFLOW_SHAPE.EDGE)) {\n  XFlowEdge = Shape.Edge.registry.register(XFLOW_SHAPE.EDGE, Shape.Edge.define({\n    zIndex: 1,\n    highlight: false,\n    shape: XFLOW_SHAPE.EDGE // https://x6.antv.vision/zh/docs/api/registry/node-anchor\n    // source: {\n    //   anchor: {\n    //     name: 'bottom',\n    //   },\n    // },\n    // target: {\n    //   anchor: {\n    //     name: 'center',\n    //   },\n    // },\n\n  }), true);\n}\n\nexport { EDGE_PATH_TYPE, XFlowEdge };","map":null,"metadata":{},"sourceType":"module"}