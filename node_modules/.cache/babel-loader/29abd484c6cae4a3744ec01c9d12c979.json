{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport graphlib from '../graphlib';\nimport util from '../util';\nvar Graph = graphlib.Graph;\n/*\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\n\nvar findType1Conflicts = function findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  var visitLayer = function visitLayer(prevLayer, layer) {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    var k0 = 0; // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n\n    var scanPos = 0;\n    var prevLayerLength = prevLayer.length;\n    var lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, i) {\n      var _a;\n\n      var w = findOtherInnerSegmentNode(g, v);\n      var k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        (_a = layer.slice(scanPos, i + 1)) === null || _a === void 0 ? void 0 : _a.forEach(function (scanNode) {\n          var _a;\n\n          (_a = g.predecessors(scanNode)) === null || _a === void 0 ? void 0 : _a.forEach(function (u) {\n            var uLabel = g.node(u);\n            var uPos = uLabel.order;\n\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n    return layer;\n  };\n\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n\n  return conflicts;\n};\n\nvar findType2Conflicts = function findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  var scan = function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    var range = [];\n\n    for (var i = southPos; i < southEnd; i++) {\n      range.push(i);\n    }\n\n    range.forEach(function (i) {\n      var _a;\n\n      v = south[i];\n\n      if (g.node(v).dummy) {\n        (_a = g.predecessors(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (u) {\n          var uNode = g.node(u);\n\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  };\n\n  var visitLayer = function visitLayer(north, south) {\n    var prevNorthPos = -1;\n    var nextNorthPos;\n    var southPos = 0;\n    south === null || south === void 0 ? void 0 : south.forEach(function (v, southLookahead) {\n      if (g.node(v).dummy === \"border\") {\n        var predecessors = g.predecessors(v) || [];\n\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n    return south;\n  };\n\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n\n  return conflicts;\n};\n\nvar findOtherInnerSegmentNode = function findOtherInnerSegmentNode(g, v) {\n  var _a;\n\n  if (g.node(v).dummy) {\n    return (_a = g.predecessors(v)) === null || _a === void 0 ? void 0 : _a.find(function (u) {\n      return g.node(u).dummy;\n    });\n  }\n};\n\nvar addConflict = function addConflict(conflicts, v, w) {\n  var vv = v;\n  var ww = w;\n\n  if (vv > ww) {\n    var tmp = vv;\n    vv = ww;\n    ww = tmp;\n  }\n\n  var conflictsV = conflicts[vv];\n\n  if (!conflictsV) {\n    conflicts[vv] = conflictsV = {};\n  }\n\n  conflictsV[ww] = true;\n};\n\nvar hasConflict = function hasConflict(conflicts, v, w) {\n  var vv = v;\n  var ww = w;\n\n  if (vv > ww) {\n    var tmp = v;\n    vv = ww;\n    ww = tmp;\n  }\n\n  return conflicts[vv] && conflicts[vv].hasOwnProperty(ww);\n};\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\n\n\nvar verticalAlignment = function verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {};\n  var align = {};\n  var pos = {}; // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    var prevIdx = -1;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v) {\n      var ws = neighborFn(v);\n\n      if (ws.length) {\n        ws = ws.sort(function (a, b) {\n          return pos[a] - pos[b];\n        });\n        var mp = (ws.length - 1) / 2;\n\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n  return {\n    root: root,\n    align: align\n  };\n};\n\nvar horizontalCompaction = function horizontalCompaction(g, layering, root, align, reverseSep) {\n  var _a; // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n\n\n  var xs = {};\n  var blockG = buildBlockGraph(g, layering, root, reverseSep);\n  var borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  var iterate = function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }; // First pass, assign smallest coordinates\n\n\n  var pass1 = function pass1(elem) {\n    xs[elem] = (blockG.inEdges(elem) || []).reduce(function (acc, e) {\n      return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e));\n    }, 0);\n  }; // Second pass, assign greatest coordinates\n\n\n  var pass2 = function pass2(elem) {\n    var min = (blockG.outEdges(elem) || []).reduce(function (acc, e) {\n      return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n    var node = g.node(elem);\n\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  };\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG)); // Assign x coordinates to all nodes\n  // @ts-ignore\n\n  (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n    xs[v] = xs[root[v]];\n  });\n  return xs;\n};\n\nvar buildBlockGraph = function buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph();\n  var graphLabel = g.graph();\n  var sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    var u;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n\n      if (u) {\n        var uRoot = root[u];\n        var prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n\n      u = v;\n    });\n  });\n  return blockGraph;\n};\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\n\n\nvar findSmallestWidthAlignment = function findSmallestWidthAlignment(g, xss) {\n  // @ts-ignore\n  return util.minBy(Object.values(xss), function (xs) {\n    var _a;\n\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n    (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n      var x = xs[v];\n      var halfWidth = width(g, v) / 2;\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n    return max - min;\n  });\n};\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\n\n\nfunction alignCoordinates(xss, alignTo) {\n  // @ts-ignore\n  var alignToVals = Object.values(alignTo);\n  var alignToMin = Math.min.apply(Math, _toConsumableArray(alignToVals));\n  var alignToMax = Math.max.apply(Math, _toConsumableArray(alignToVals));\n  [\"u\", \"d\"].forEach(function (vert) {\n    [\"l\", \"r\"].forEach(function (horiz) {\n      var alignment = vert + horiz;\n      var xs = xss[alignment];\n      var delta;\n      if (xs === alignTo) return;\n      var xsVals = Object.values(xs);\n      delta = horiz === \"l\" ? alignToMin - Math.min.apply(Math, _toConsumableArray(xsVals)) : alignToMax - Math.max.apply(Math, _toConsumableArray(xsVals));\n\n      if (delta) {\n        xss[alignment] = {};\n        Object.keys(xs).forEach(function (key) {\n          xss[alignment][key] = xs[key] + delta;\n        });\n      }\n    });\n  });\n}\n\nvar balance = function balance(xss, align) {\n  var result = {};\n  Object.keys(xss.ul).forEach(function (key) {\n    if (align) {\n      result[key] = xss[align.toLowerCase()][key];\n    } else {\n      // @ts-ignore\n      var values = Object.values(xss).map(function (x) {\n        return x[key];\n      });\n      var xs = values.sort(function (a, b) {\n        return a - b;\n      });\n      result[key] = (xs[1] + xs[2]) / 2;\n    }\n  });\n  return result; // return _.mapValues(xss.ul, function(ignore, v) {\n  //   if (align) {\n  //     return xss[align.toLowerCase()][v];\n  //   } else {\n  //     const xs = _.sortBy(_.map(xss, v));\n  //     return (xs[1] + xs[2]) / 2;\n  //   }\n  // });\n};\n\nvar positionX = function positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n  var conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n  var xss = {};\n  var adjustedLayering;\n  [\"u\", \"d\"].forEach(function (vert) {\n    // @ts-ignore\n    adjustedLayering = vert === \"u\" ? layering : Object.values(layering).reverse();\n    [\"l\", \"r\"].forEach(function (horiz) {\n      if (horiz === \"r\") {\n        // @ts-ignore\n        adjustedLayering = adjustedLayering.map(function (inner) {\n          return Object.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === \"r\");\n\n      if (horiz === \"r\") {\n        // @ts-ignore\n        xs = Object.values(xs).map(function (x) {\n          return -x;\n        });\n      }\n\n      xss[vert + horiz] = xs;\n    });\n  });\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n};\n\nvar sep = function sep(nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n    sum += vLabel.width / 2;\n\n    if (vLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((vLabel.labelpos || '').toLowerCase()) {\n        case \"l\":\n          delta = -vLabel.width / 2;\n          break;\n\n        case \"r\":\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n\n    delta = 0;\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += wLabel.width / 2;\n\n    if (wLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((wLabel.labelpos || '').toLowerCase()) {\n        case \"l\":\n          delta = wLabel.width / 2;\n          break;\n\n        case \"r\":\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n\n    delta = 0;\n    return sum;\n  };\n};\n\nvar width = function width(g, v) {\n  var _a;\n\n  return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.width) || 0;\n};\n\nexport { positionX, findType1Conflicts, findType2Conflicts, addConflict, hasConflict, verticalAlignment, horizontalCompaction, alignCoordinates, findSmallestWidthAlignment, balance };\nexport default {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n};","map":null,"metadata":{},"sourceType":"module"}