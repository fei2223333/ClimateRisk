{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport * as util from './util';\nimport { Angle } from './angle';\nimport { Line } from './line';\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nexport var Rectangle = /*#__PURE__*/function (_Geometry) {\n  _inherits(Rectangle, _Geometry);\n\n  function Rectangle(x, y, width, height) {\n    var _this;\n\n    _classCallCheck(this, Rectangle);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Rectangle).call(this));\n    _this.x = x == null ? 0 : x;\n    _this.y = y == null ? 0 : y;\n    _this.width = width == null ? 0 : width;\n    _this.height = height == null ? 0 : height;\n    return _this;\n  }\n\n  _createClass(Rectangle, [{\n    key: \"getOrigin\",\n    value: function getOrigin() {\n      return this.origin;\n    }\n  }, {\n    key: \"getTopLeft\",\n    value: function getTopLeft() {\n      return this.topLeft;\n    }\n  }, {\n    key: \"getTopCenter\",\n    value: function getTopCenter() {\n      return this.topCenter;\n    }\n  }, {\n    key: \"getTopRight\",\n    value: function getTopRight() {\n      return this.topRight;\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n  }, {\n    key: \"getCenterX\",\n    value: function getCenterX() {\n      return this.x + this.width / 2;\n    }\n  }, {\n    key: \"getCenterY\",\n    value: function getCenterY() {\n      return this.y + this.height / 2;\n    }\n  }, {\n    key: \"getBottomLeft\",\n    value: function getBottomLeft() {\n      return this.bottomLeft;\n    }\n  }, {\n    key: \"getBottomCenter\",\n    value: function getBottomCenter() {\n      return this.bottomCenter;\n    }\n  }, {\n    key: \"getBottomRight\",\n    value: function getBottomRight() {\n      return this.bottomRight;\n    }\n  }, {\n    key: \"getCorner\",\n    value: function getCorner() {\n      return this.corner;\n    }\n  }, {\n    key: \"getRightMiddle\",\n    value: function getRightMiddle() {\n      return this.rightMiddle;\n    }\n  }, {\n    key: \"getLeftMiddle\",\n    value: function getLeftMiddle() {\n      return this.leftMiddle;\n    }\n  }, {\n    key: \"getTopLine\",\n    value: function getTopLine() {\n      return this.topLine;\n    }\n  }, {\n    key: \"getRightLine\",\n    value: function getRightLine() {\n      return this.rightLine;\n    }\n  }, {\n    key: \"getBottomLine\",\n    value: function getBottomLine() {\n      return this.bottomLine;\n    }\n  }, {\n    key: \"getLeftLine\",\n    value: function getLeftLine() {\n      return this.leftLine;\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the rectangle.\n     *\n     * If `angle` is specified, the bounding box calculation will take into\n     * account the rotation of the rectangle by angle degrees around its center.\n     */\n\n  }, {\n    key: \"bbox\",\n    value: function bbox(angle) {\n      if (!angle) {\n        return this.clone();\n      }\n\n      var rad = Angle.toRad(angle);\n      var st = Math.abs(Math.sin(rad));\n      var ct = Math.abs(Math.cos(rad));\n      var w = this.width * ct + this.height * st;\n      var h = this.width * st + this.height * ct;\n      return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n    }\n  }, {\n    key: \"round\",\n    value: function round() {\n      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.x = util.round(this.x, precision);\n      this.y = util.round(this.y, precision);\n      this.width = util.round(this.width, precision);\n      this.height = util.round(this.height, precision);\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(x, y, width, height) {\n      var rect = Rectangle.create(x, y, width, height);\n      var minX = Math.min(this.x, rect.x);\n      var minY = Math.min(this.y, rect.y);\n      var maxX = Math.max(this.x + this.width, rect.x + rect.width);\n      var maxY = Math.max(this.y + this.height, rect.y + rect.height);\n      this.x = minX;\n      this.y = minY;\n      this.width = maxX - minX;\n      this.height = maxY - minY;\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(x, y, width, height) {\n      var rect = Rectangle.create(x, y, width, height);\n      this.x = rect.x;\n      this.y = rect.y;\n      this.width = rect.width;\n      this.height = rect.height;\n      return this;\n    }\n  }, {\n    key: \"inflate\",\n    value: function inflate(dx, dy) {\n      var w = dx;\n      var h = dy != null ? dy : dx;\n      this.x -= w;\n      this.y -= h;\n      this.width += 2 * w;\n      this.height += 2 * h;\n      return this;\n    }\n  }, {\n    key: \"snapToGrid\",\n    value: function snapToGrid(gx, gy) {\n      var origin = this.origin.snapToGrid(gx, gy);\n      var corner = this.corner.snapToGrid(gx, gy);\n      this.x = origin.x;\n      this.y = origin.y;\n      this.width = corner.x - origin.x;\n      this.height = corner.y - origin.y;\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      var p = Point.create(tx, ty);\n      this.x += p.x;\n      this.y += p.y;\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n      var pos = this.origin.scale(sx, sy, origin);\n      this.x = pos.x;\n      this.y = pos.y;\n      this.width *= sx;\n      this.height *= sy;\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(degree) {\n      var center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getCenter();\n\n      if (degree !== 0) {\n        var rad = Angle.toRad(degree);\n        var cos = Math.cos(rad);\n        var sin = Math.sin(rad);\n        var p1 = this.getOrigin();\n        var p2 = this.getTopRight();\n        var p3 = this.getBottomRight();\n        var p4 = this.getBottomLeft();\n        p1 = Point.rotateEx(p1, cos, sin, center);\n        p2 = Point.rotateEx(p2, cos, sin, center);\n        p3 = Point.rotateEx(p3, cos, sin, center);\n        p4 = Point.rotateEx(p4, cos, sin, center);\n        var rect = new Rectangle(p1.x, p1.y, 0, 0);\n        rect.add(p2.x, p2.y, 0, 0);\n        rect.add(p3.x, p3.y, 0, 0);\n        rect.add(p4.x, p4.y, 0, 0);\n        this.update(rect);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"rotate90\",\n    value: function rotate90() {\n      var t = (this.width - this.height) / 2;\n      this.x += t;\n      this.y -= t;\n      var tmp = this.width;\n      this.width = this.height;\n      this.height = tmp;\n      return this;\n    }\n    /**\n     * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n     * `rect.width` and `rect.height`.\n     */\n\n  }, {\n    key: \"moveAndExpand\",\n    value: function moveAndExpand(rect) {\n      var ref = Rectangle.clone(rect);\n      this.x += ref.x || 0;\n      this.y += ref.y || 0;\n      this.width += ref.width || 0;\n      this.height += ref.height || 0;\n      return this;\n    }\n    /**\n     * Returns an object where `sx` and `sy` give the maximum scaling that can be\n     * applied to the rectangle so that it would still fit into `limit`. If\n     * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n     * scaled around its center.\n     */\n\n  }, {\n    key: \"getMaxScaleToFit\",\n    value: function getMaxScaleToFit(limit) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;\n      var rect = Rectangle.clone(limit);\n      var ox = origin.x;\n      var oy = origin.y; // Find the maximal possible scale for all corners, so when the scale\n      // is applied the point is still inside the rectangle.\n\n      var sx1 = Infinity;\n      var sx2 = Infinity;\n      var sx3 = Infinity;\n      var sx4 = Infinity;\n      var sy1 = Infinity;\n      var sy2 = Infinity;\n      var sy3 = Infinity;\n      var sy4 = Infinity; // Top Left\n\n      var p1 = rect.topLeft;\n\n      if (p1.x < ox) {\n        sx1 = (this.x - ox) / (p1.x - ox);\n      }\n\n      if (p1.y < oy) {\n        sy1 = (this.y - oy) / (p1.y - oy);\n      } // Bottom Right\n\n\n      var p2 = rect.bottomRight;\n\n      if (p2.x > ox) {\n        sx2 = (this.x + this.width - ox) / (p2.x - ox);\n      }\n\n      if (p2.y > oy) {\n        sy2 = (this.y + this.height - oy) / (p2.y - oy);\n      } // Top Right\n\n\n      var p3 = rect.topRight;\n\n      if (p3.x > ox) {\n        sx3 = (this.x + this.width - ox) / (p3.x - ox);\n      }\n\n      if (p3.y < oy) {\n        sy3 = (this.y - oy) / (p3.y - oy);\n      } // Bottom Left\n\n\n      var p4 = rect.bottomLeft;\n\n      if (p4.x < ox) {\n        sx4 = (this.x - ox) / (p4.x - ox);\n      }\n\n      if (p4.y > oy) {\n        sy4 = (this.y + this.height - oy) / (p4.y - oy);\n      }\n\n      return {\n        sx: Math.min(sx1, sx2, sx3, sx4),\n        sy: Math.min(sy1, sy2, sy3, sy4)\n      };\n    }\n    /**\n     * Returns a number that specifies the maximum scaling that can be applied to\n     * the rectangle along both axes so that it would still fit into `limit`. If\n     * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n     * scaled around its center.\n     */\n\n  }, {\n    key: \"getMaxUniformScaleToFit\",\n    value: function getMaxUniformScaleToFit(limit) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;\n      var scale = this.getMaxScaleToFit(limit, origin);\n      return Math.min(scale.sx, scale.sy);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(x, y) {\n      return util.containsPoint(this, Point.create(x, y));\n    }\n  }, {\n    key: \"containsRect\",\n    value: function containsRect(x, y, width, height) {\n      var b = Rectangle.create(x, y, width, height);\n      var x1 = this.x;\n      var y1 = this.y;\n      var w1 = this.width;\n      var h1 = this.height;\n      var x2 = b.x;\n      var y2 = b.y;\n      var w2 = b.width;\n      var h2 = b.height; // one of the dimensions is 0\n\n      if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n        return false;\n      }\n\n      return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;\n    }\n    /**\n     * Returns an array of the intersection points of the rectangle and the line.\n     * Return `null` if no intersection exists.\n     */\n\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var rectLines = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n      var points = [];\n      var dedupeArr = [];\n      rectLines.forEach(function (l) {\n        var p = line.intersectsWithLine(l);\n\n        if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n          points.push(p);\n          dedupeArr.push(p.toString());\n        }\n      });\n      return points.length > 0 ? points : null;\n    }\n    /**\n     * Returns the point on the boundary of the rectangle that is the intersection\n     * of the rectangle with a line starting in the center the rectangle ending in\n     * the point `p`.\n     *\n     * If `angle` is specified, the intersection will take into account the\n     * rotation of the rectangle by `angle` degrees around its center.\n     */\n\n  }, {\n    key: \"intersectsWithLineFromCenterToPoint\",\n    value: function intersectsWithLineFromCenterToPoint(p, angle) {\n      var ref = Point.clone(p);\n      var center = this.center;\n      var result = null;\n\n      if (angle != null && angle !== 0) {\n        ref.rotate(angle, center);\n      }\n\n      var sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n      var connector = new Line(center, ref);\n\n      for (var i = sides.length - 1; i >= 0; i -= 1) {\n        var intersection = sides[i].intersectsWithLine(connector);\n\n        if (intersection !== null) {\n          result = intersection;\n          break;\n        }\n      }\n\n      if (result && angle != null && angle !== 0) {\n        result.rotate(-angle, center);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"intersectsWithRect\",\n    value: function intersectsWithRect(x, y, width, height) {\n      var ref = Rectangle.create(x, y, width, height); // no intersection\n\n      if (!this.isIntersectWithRect(ref)) {\n        return null;\n      }\n\n      var myOrigin = this.origin;\n      var myCorner = this.corner;\n      var rOrigin = ref.origin;\n      var rCorner = ref.corner;\n      var xx = Math.max(myOrigin.x, rOrigin.x);\n      var yy = Math.max(myOrigin.y, rOrigin.y);\n      return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);\n    }\n  }, {\n    key: \"isIntersectWithRect\",\n    value: function isIntersectWithRect(x, y, width, height) {\n      var ref = Rectangle.create(x, y, width, height);\n      var myOrigin = this.origin;\n      var myCorner = this.corner;\n      var rOrigin = ref.origin;\n      var rCorner = ref.corner;\n\n      if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Normalize the rectangle, i.e. make it so that it has non-negative\n     * width and height. If width is less than `0`, the function swaps left and\n     * right corners and if height is less than `0`, the top and bottom corners\n     * are swapped.\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var newx = this.x;\n      var newy = this.y;\n      var newwidth = this.width;\n      var newheight = this.height;\n\n      if (this.width < 0) {\n        newx = this.x + this.width;\n        newwidth = -this.width;\n      }\n\n      if (this.height < 0) {\n        newy = this.y + this.height;\n        newheight = -this.height;\n      }\n\n      this.x = newx;\n      this.y = newy;\n      this.width = newwidth;\n      this.height = newheight;\n      return this;\n    }\n    /**\n     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n     */\n\n  }, {\n    key: \"union\",\n    value: function union(rect) {\n      var ref = Rectangle.clone(rect);\n      var myOrigin = this.origin;\n      var myCorner = this.corner;\n      var rOrigin = ref.origin;\n      var rCorner = ref.corner;\n      var originX = Math.min(myOrigin.x, rOrigin.x);\n      var originY = Math.min(myOrigin.y, rOrigin.y);\n      var cornerX = Math.max(myCorner.x, rCorner.x);\n      var cornerY = Math.max(myCorner.y, rCorner.y);\n      return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);\n    }\n    /**\n     * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n     * the rectangle which is nearest to the point `p`.\n     */\n\n  }, {\n    key: \"getNearestSideToPoint\",\n    value: function getNearestSideToPoint(p) {\n      var ref = Point.clone(p);\n      var distLeft = ref.x - this.x;\n      var distRight = this.x + this.width - ref.x;\n      var distTop = ref.y - this.y;\n      var distBottom = this.y + this.height - ref.y;\n      var closest = distLeft;\n      var side = 'left';\n\n      if (distRight < closest) {\n        closest = distRight;\n        side = 'right';\n      }\n\n      if (distTop < closest) {\n        closest = distTop;\n        side = 'top';\n      }\n\n      if (distBottom < closest) {\n        side = 'bottom';\n      }\n\n      return side;\n    }\n    /**\n     * Returns a point on the boundary of the rectangle nearest to the point `p`.\n     */\n\n  }, {\n    key: \"getNearestPointToPoint\",\n    value: function getNearestPointToPoint(p) {\n      var ref = Point.clone(p);\n\n      if (this.containsPoint(ref)) {\n        var side = this.getNearestSideToPoint(ref);\n\n        switch (side) {\n          case 'right':\n            return new Point(this.x + this.width, ref.y);\n\n          case 'left':\n            return new Point(this.x, ref.y);\n\n          case 'bottom':\n            return new Point(ref.x, this.y + this.height);\n\n          case 'top':\n            return new Point(ref.x, this.y);\n\n          default:\n            break;\n        }\n      }\n\n      return ref.adhereToRect(this);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rect) {\n      return rect != null && rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        x: this.x,\n        y: this.y,\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.x, \" \").concat(this.y, \" \").concat(this.width, \" \").concat(this.height);\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Rectangle.toStringTag;\n    }\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.width;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.height;\n    }\n  }, {\n    key: \"origin\",\n    get: function get() {\n      return new Point(this.x, this.y);\n    }\n  }, {\n    key: \"topLeft\",\n    get: function get() {\n      return new Point(this.x, this.y);\n    }\n  }, {\n    key: \"topCenter\",\n    get: function get() {\n      return new Point(this.x + this.width / 2, this.y);\n    }\n  }, {\n    key: \"topRight\",\n    get: function get() {\n      return new Point(this.x + this.width, this.y);\n    }\n  }, {\n    key: \"center\",\n    get: function get() {\n      return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    }\n  }, {\n    key: \"bottomLeft\",\n    get: function get() {\n      return new Point(this.x, this.y + this.height);\n    }\n  }, {\n    key: \"bottomCenter\",\n    get: function get() {\n      return new Point(this.x + this.width / 2, this.y + this.height);\n    }\n  }, {\n    key: \"bottomRight\",\n    get: function get() {\n      return new Point(this.x + this.width, this.y + this.height);\n    }\n  }, {\n    key: \"corner\",\n    get: function get() {\n      return new Point(this.x + this.width, this.y + this.height);\n    }\n  }, {\n    key: \"rightMiddle\",\n    get: function get() {\n      return new Point(this.x + this.width, this.y + this.height / 2);\n    }\n  }, {\n    key: \"leftMiddle\",\n    get: function get() {\n      return new Point(this.x, this.y + this.height / 2);\n    }\n  }, {\n    key: \"topLine\",\n    get: function get() {\n      return new Line(this.topLeft, this.topRight);\n    }\n  }, {\n    key: \"rightLine\",\n    get: function get() {\n      return new Line(this.topRight, this.bottomRight);\n    }\n  }, {\n    key: \"bottomLine\",\n    get: function get() {\n      return new Line(this.bottomLeft, this.bottomRight);\n    }\n  }, {\n    key: \"leftLine\",\n    get: function get() {\n      return new Line(this.topLeft, this.bottomLeft);\n    }\n  }]);\n\n  return Rectangle;\n}(Geometry);\n\n(function (Rectangle) {\n  Rectangle.toStringTag = \"X6.Geometry.\".concat(Rectangle.name);\n\n  function isRectangle(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Rectangle) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var rect = instance;\n\n    if ((tag == null || tag === Rectangle.toStringTag) && typeof rect.x === 'number' && typeof rect.y === 'number' && typeof rect.width === 'number' && typeof rect.height === 'number' && typeof rect.inflate === 'function' && typeof rect.moveAndExpand === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Rectangle.isRectangle = isRectangle;\n})(Rectangle || (Rectangle = {}));\n\n(function (Rectangle) {\n  function isRectangleLike(o) {\n    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number' && typeof o.width === 'number' && typeof o.height === 'number';\n  }\n\n  Rectangle.isRectangleLike = isRectangleLike;\n})(Rectangle || (Rectangle = {}));\n\n(function (Rectangle) {\n  function create(x, y, width, height) {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height);\n    }\n\n    return clone(x);\n  }\n\n  Rectangle.create = create;\n\n  function clone(rect) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone();\n    }\n\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3]);\n    }\n\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n  }\n\n  Rectangle.clone = clone;\n\n  function fromSize(size) {\n    return new Rectangle(0, 0, size.width, size.height);\n  }\n\n  Rectangle.fromSize = fromSize;\n\n  function fromPositionAndSize(pos, size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height);\n  }\n\n  Rectangle.fromPositionAndSize = fromPositionAndSize;\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n\n  function fromEllipse(ellipse) {\n    return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);\n  }\n\n  Rectangle.fromEllipse = fromEllipse;\n})(Rectangle || (Rectangle = {}));","map":null,"metadata":{},"sourceType":"module"}