{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Dom, FunctionExt } from '../../util';\nimport { Point } from '../../geometry';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\n\nvar Anchor = /*#__PURE__*/function (_ToolsView$ToolItem) {\n  _inherits(Anchor, _ToolsView$ToolItem);\n\n  function Anchor() {\n    _classCallCheck(this, Anchor);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Anchor).apply(this, arguments));\n  }\n\n  _createClass(Anchor, [{\n    key: \"onRender\",\n    value: function onRender() {\n      Dom.addClass(this.container, this.prefixClassName(\"edge-tool-\".concat(this.type, \"-anchor\")));\n      this.toggleArea(false);\n      this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var type = this.type;\n      var edgeView = this.cellView;\n      var terminalView = edgeView.getTerminalView(type);\n\n      if (terminalView) {\n        this.updateAnchor();\n        this.updateArea();\n        this.container.style.display = '';\n      } else {\n        this.container.style.display = 'none';\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateAnchor\",\n    value: function updateAnchor() {\n      var childNodes = this.childNodes;\n\n      if (!childNodes) {\n        return;\n      }\n\n      var anchorNode = childNodes.anchor;\n\n      if (!anchorNode) {\n        return;\n      }\n\n      var type = this.type;\n      var edgeView = this.cellView;\n      var options = this.options;\n      var position = edgeView.getTerminalAnchor(type);\n      var customAnchor = edgeView.cell.prop([type, 'anchor']);\n      anchorNode.setAttribute('transform', \"translate(\".concat(position.x, \", \").concat(position.y, \")\"));\n      var anchorAttrs = customAnchor ? options.customAnchorAttrs : options.defaultAnchorAttrs;\n\n      if (anchorAttrs) {\n        Object.keys(anchorAttrs).forEach(function (attrName) {\n          anchorNode.setAttribute(attrName, anchorAttrs[attrName]);\n        });\n      }\n    }\n  }, {\n    key: \"updateArea\",\n    value: function updateArea() {\n      var childNodes = this.childNodes;\n\n      if (!childNodes) {\n        return;\n      }\n\n      var areaNode = childNodes.area;\n\n      if (!areaNode) {\n        return;\n      }\n\n      var type = this.type;\n      var edgeView = this.cellView;\n      var terminalView = edgeView.getTerminalView(type);\n\n      if (terminalView) {\n        var terminalCell = terminalView.cell;\n        var magnet = edgeView.getTerminalMagnet(type);\n        var padding = this.options.areaPadding || 0;\n\n        if (!Number.isFinite(padding)) {\n          padding = 0;\n        }\n\n        var bbox;\n        var angle;\n        var center;\n\n        if (terminalView.isEdgeElement(magnet)) {\n          bbox = terminalView.getBBox();\n          angle = 0;\n          center = bbox.getCenter();\n        } else {\n          bbox = terminalView.getUnrotatedBBoxOfElement(magnet);\n          angle = terminalCell.getAngle();\n          center = bbox.getCenter();\n\n          if (angle) {\n            center.rotate(-angle, terminalCell.getBBox().getCenter());\n          }\n        }\n\n        bbox.inflate(padding);\n        Dom.attr(areaNode, {\n          x: -bbox.width / 2,\n          y: -bbox.height / 2,\n          width: bbox.width,\n          height: bbox.height,\n          transform: \"translate(\".concat(center.x, \", \").concat(center.y, \") rotate(\").concat(angle, \")\")\n        });\n      }\n    }\n  }, {\n    key: \"toggleArea\",\n    value: function toggleArea(visible) {\n      if (this.childNodes) {\n        var elem = this.childNodes.area;\n\n        if (elem) {\n          elem.style.display = visible ? '' : 'none';\n        }\n      }\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(evt) {\n      if (this.guard(evt)) {\n        return;\n      }\n\n      evt.stopPropagation();\n      evt.preventDefault();\n      this.graph.view.undelegateEvents();\n\n      if (this.options.documentEvents) {\n        this.delegateDocumentEvents(this.options.documentEvents);\n      }\n\n      this.focus();\n      this.toggleArea(this.options.restrictArea);\n      this.cell.startBatch('move-anchor', {\n        ui: true,\n        toolId: this.cid\n      });\n    }\n  }, {\n    key: \"resetAnchor\",\n    value: function resetAnchor(anchor) {\n      var type = this.type;\n      var cell = this.cell;\n\n      if (anchor) {\n        cell.prop([type, 'anchor'], anchor, {\n          rewrite: true,\n          ui: true,\n          toolId: this.cid\n        });\n      } else {\n        cell.removeProp([type, 'anchor'], {\n          ui: true,\n          toolId: this.cid\n        });\n      }\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(evt) {\n      var terminalType = this.type;\n      var edgeView = this.cellView;\n      var terminalView = edgeView.getTerminalView(terminalType);\n\n      if (terminalView == null) {\n        return;\n      }\n\n      var e = this.normalizeEvent(evt);\n      var terminalCell = terminalView.cell;\n      var terminalMagnet = edgeView.getTerminalMagnet(terminalType);\n      var coords = this.graph.clientToLocal(e.clientX, e.clientY);\n      var snapFn = this.options.snap;\n\n      if (typeof snapFn === 'function') {\n        var tmp = FunctionExt.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);\n        coords = Point.create(tmp);\n      }\n\n      if (this.options.restrictArea) {\n        if (terminalView.isEdgeElement(terminalMagnet)) {\n          var pointAtConnection = terminalView.getClosestPoint(coords);\n\n          if (pointAtConnection) {\n            coords = pointAtConnection;\n          }\n        } else {\n          var bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);\n          var angle = terminalCell.getAngle();\n          var origin = terminalCell.getBBox().getCenter();\n          var rotatedCoords = coords.clone().rotate(angle, origin);\n\n          if (!bbox.containsPoint(rotatedCoords)) {\n            coords = bbox.getNearestPointToPoint(rotatedCoords).rotate(-angle, origin);\n          }\n        }\n      }\n\n      var anchor;\n      var anchorFn = this.options.anchor;\n\n      if (typeof anchorFn === 'function') {\n        anchor = FunctionExt.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);\n      }\n\n      this.resetAnchor(anchor);\n      this.update();\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(evt) {\n      this.graph.view.delegateEvents();\n      this.undelegateDocumentEvents();\n      this.blur();\n      this.toggleArea(false);\n      var edgeView = this.cellView;\n\n      if (this.options.removeRedundancies) {\n        edgeView.removeRedundantLinearVertices({\n          ui: true,\n          toolId: this.cid\n        });\n      }\n\n      this.cell.stopBatch('move-anchor', {\n        ui: true,\n        toolId: this.cid\n      });\n    }\n  }, {\n    key: \"onDblClick\",\n    value: function onDblClick() {\n      var anchor = this.options.resetAnchor;\n\n      if (anchor) {\n        this.resetAnchor(anchor === true ? undefined : anchor);\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.options.type;\n    }\n  }]);\n\n  return Anchor;\n}(ToolsView.ToolItem);\n\n(function (Anchor) {\n  Anchor.config({\n    tagName: 'g',\n    markup: [{\n      tagName: 'circle',\n      selector: 'anchor',\n      attrs: {\n        cursor: 'pointer'\n      }\n    }, {\n      tagName: 'rect',\n      selector: 'area',\n      attrs: {\n        'pointer-events': 'none',\n        fill: 'none',\n        stroke: '#33334F',\n        'stroke-dasharray': '2,4',\n        rx: 5,\n        ry: 5\n      }\n    }],\n    events: {\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown',\n      dblclick: 'onDblClick'\n    },\n    documentEvents: {\n      mousemove: 'onMouseMove',\n      touchmove: 'onMouseMove',\n      mouseup: 'onMouseUp',\n      touchend: 'onMouseUp',\n      touchcancel: 'onMouseUp'\n    },\n    customAnchorAttrs: {\n      'stroke-width': 4,\n      stroke: '#33334F',\n      fill: '#FFFFFF',\n      r: 5\n    },\n    defaultAnchorAttrs: {\n      'stroke-width': 2,\n      stroke: '#FFFFFF',\n      fill: '#33334F',\n      r: 6\n    },\n    areaPadding: 6,\n    snapRadius: 10,\n    resetAnchor: true,\n    restrictArea: true,\n    removeRedundancies: true,\n    anchor: Util.getAnchor,\n    snap: function snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {\n      var snapRadius = toolView.options.snapRadius || 0;\n      var isSource = terminalType === 'source';\n      var refIndex = isSource ? 0 : -1;\n      var ref = this.cell.getVertexAt(refIndex) || this.getTerminalAnchor(isSource ? 'target' : 'source');\n\n      if (ref) {\n        if (Math.abs(ref.x - pos.x) < snapRadius) pos.x = ref.x;\n        if (Math.abs(ref.y - pos.y) < snapRadius) pos.y = ref.y;\n      }\n\n      return pos;\n    }\n  });\n})(Anchor || (Anchor = {}));\n\nexport var SourceAnchor = Anchor.define({\n  name: 'source-anchor',\n  type: 'source'\n});\nexport var TargetAnchor = Anchor.define({\n  name: 'target-anchor',\n  type: 'target'\n});","map":null,"metadata":{},"sourceType":"module"}