{"ast":null,"code":"var isEdgeView = function isEdgeView(val, _ref) {\n  var view = _ref.view;\n  return view.cell.isEdge();\n};\n\nexport var connection = {\n  qualify: isEdgeView,\n  set: function set(val, args) {\n    var view = args.view;\n    var stubs = val.stubs || 0;\n    var d;\n\n    if (Number.isFinite(stubs) && stubs !== 0) {\n      var offset;\n\n      if (stubs < 0) {\n        var len = view.getConnectionLength() || 0;\n        offset = (len + stubs) / 2;\n      } else {\n        offset = stubs;\n      }\n\n      var path = view.getConnection();\n\n      if (path) {\n        var sourceParts = path.divideAtLength(offset);\n        var targetParts = path.divideAtLength(-offset);\n\n        if (sourceParts && targetParts) {\n          d = \"\".concat(sourceParts[0].serialize(), \" \").concat(targetParts[1].serialize());\n        }\n      }\n    }\n\n    return {\n      d: d || view.getConnectionPathData()\n    };\n  }\n};\nexport var atConnectionLengthKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: true\n  })\n};\nexport var atConnectionLengthIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: false\n  })\n};\nexport var atConnectionRatioKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: true\n  })\n};\nexport var atConnectionRatioIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: false\n  })\n}; // aliases\n// -------\n\nexport var atConnectionLength = atConnectionLengthKeepGradient;\nexport var atConnectionRatio = atConnectionRatioKeepGradient; // utils\n// -----\n\nfunction atConnectionWrapper(method, options) {\n  var zeroVector = {\n    x: 1,\n    y: 0\n  };\n  return function (value, args) {\n    var p;\n    var angle;\n    var view = args.view;\n    var tangent = view[method](Number(value));\n\n    if (tangent) {\n      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = view.path.start;\n      angle = 0;\n    }\n\n    if (angle === 0) {\n      return {\n        transform: \"translate(\".concat(p.x, \",\").concat(p.y, \"')\")\n      };\n    }\n\n    return {\n      transform: \"translate(\".concat(p.x, \",\").concat(p.y, \"') rotate(\").concat(angle, \")\")\n    };\n  };\n}","map":null,"metadata":{},"sourceType":"module"}