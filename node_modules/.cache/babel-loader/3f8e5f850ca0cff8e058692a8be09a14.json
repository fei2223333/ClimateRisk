{"ast":null,"code":"import _defineProperty from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ObjectExt, ArrayExt, Dom, FunctionExt, StringExt, Scheduler } from '../util';\nimport { Point } from '../geometry';\nimport { Dictionary } from '../common';\nimport { Attr } from '../registry/attr';\nimport { View } from './view';\nexport var AttrManager = /*#__PURE__*/function () {\n  function AttrManager(view) {\n    _classCallCheck(this, AttrManager);\n\n    this.view = view;\n  }\n\n  _createClass(AttrManager, [{\n    key: \"getDefinition\",\n    value: function getDefinition(attrName) {\n      return this.cell.getAttrDefinition(attrName);\n    }\n  }, {\n    key: \"processAttrs\",\n    value: function processAttrs(elem, raw) {\n      var _this = this;\n\n      var normal;\n      var set;\n      var offset;\n      var position;\n      var delay;\n      var specials = []; // divide the attributes between normal and special\n\n      Object.keys(raw).forEach(function (name) {\n        var val = raw[name];\n\n        var definition = _this.getDefinition(name);\n\n        var isValid = FunctionExt.call(Attr.isValidDefinition, _this.view, definition, val, {\n          elem: elem,\n          attrs: raw,\n          cell: _this.cell,\n          view: _this.view\n        });\n\n        if (definition && isValid) {\n          if (typeof definition === 'string') {\n            if (normal == null) {\n              normal = {};\n            }\n\n            normal[definition] = val;\n          } else if (val !== null) {\n            specials.push({\n              name: name,\n              definition: definition\n            });\n          }\n        } else {\n          if (normal == null) {\n            normal = {};\n          }\n\n          var normalName = AttrManager.CASE_SENSITIVE_ATTR.includes(name) ? name : StringExt.kebabCase(name);\n          normal[normalName] = val;\n        }\n      });\n      specials.forEach(function (_ref) {\n        var name = _ref.name,\n            definition = _ref.definition;\n        var val = raw[name];\n        var setDefine = definition;\n\n        if (typeof setDefine.set === 'function') {\n          if (!Dom.isHTMLElement(elem) && AttrManager.DELAY_ATTRS.includes(name)) {\n            if (delay == null) {\n              delay = {};\n            }\n\n            delay[name] = val;\n          } else {\n            if (set == null) {\n              set = {};\n            }\n\n            set[name] = val;\n          }\n        }\n\n        var offsetDefine = definition;\n\n        if (typeof offsetDefine.offset === 'function') {\n          if (offset == null) {\n            offset = {};\n          }\n\n          offset[name] = val;\n        }\n\n        var positionDefine = definition;\n\n        if (typeof positionDefine.position === 'function') {\n          if (position == null) {\n            position = {};\n          }\n\n          position[name] = val;\n        }\n      });\n      return {\n        raw: raw,\n        normal: normal,\n        set: set,\n        offset: offset,\n        position: position,\n        delay: delay\n      };\n    }\n  }, {\n    key: \"mergeProcessedAttrs\",\n    value: function mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {\n      allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);\n      allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);\n      allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset); // Handle also the special transform property.\n\n      var transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;\n\n      if (transform != null && roProcessedAttrs.normal) {\n        roProcessedAttrs.normal.transform = transform;\n      }\n\n      allProcessedAttrs.normal = roProcessedAttrs.normal;\n    }\n  }, {\n    key: \"findAttrs\",\n    value: function findAttrs(cellAttrs, rootNode, selectorCache, selectors) {\n      var merge = [];\n      var result = new Dictionary();\n      Object.keys(cellAttrs).forEach(function (selector) {\n        var attrs = cellAttrs[selector];\n\n        if (!ObjectExt.isPlainObject(attrs)) {\n          return;\n        }\n\n        var _View$find = View.find(selector, rootNode, selectors),\n            isCSSSelector = _View$find.isCSSSelector,\n            elems = _View$find.elems;\n\n        selectorCache[selector] = elems;\n\n        for (var i = 0, l = elems.length; i < l; i += 1) {\n          var elem = elems[i];\n          var unique = selectors && selectors[selector] === elem;\n          var prev = result.get(elem);\n\n          if (prev) {\n            if (!prev.array) {\n              merge.push(elem);\n              prev.array = true;\n              prev.attrs = [prev.attrs];\n              prev.priority = [prev.priority];\n            }\n\n            var attributes = prev.attrs;\n            var selectedLength = prev.priority;\n\n            if (unique) {\n              // node referenced by `selector`\n              attributes.unshift(attrs);\n              selectedLength.unshift(-1);\n            } else {\n              // node referenced by `groupSelector` or CSSSelector\n              var sortIndex = ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);\n              attributes.splice(sortIndex, 0, attrs);\n              selectedLength.splice(sortIndex, 0, l);\n            }\n          } else {\n            result.set(elem, {\n              elem: elem,\n              attrs: attrs,\n              priority: unique ? -1 : l,\n              array: false\n            });\n          }\n        }\n      });\n      merge.forEach(function (node) {\n        var item = result.get(node);\n        var arr = item.attrs;\n        item.attrs = arr.reduceRight(function (memo, attrs) {\n          return ObjectExt.merge(memo, attrs);\n        }, {});\n      });\n      return result;\n    }\n  }, {\n    key: \"updateRelativeAttrs\",\n    value: function updateRelativeAttrs(elem, processedAttrs, refBBox, options) {\n      var _this2 = this;\n\n      var rawAttrs = processedAttrs.raw || {};\n      var nodeAttrs = processedAttrs.normal || {};\n      var setAttrs = processedAttrs.set;\n      var positionAttrs = processedAttrs.position;\n      var offsetAttrs = processedAttrs.offset;\n      var delayAttrs = processedAttrs.delay;\n\n      var getOptions = function getOptions() {\n        return {\n          elem: elem,\n          cell: _this2.cell,\n          view: _this2.view,\n          attrs: rawAttrs,\n          refBBox: refBBox.clone()\n        };\n      };\n\n      if (setAttrs != null) {\n        Object.keys(setAttrs).forEach(function (name) {\n          var val = setAttrs[name];\n\n          var def = _this2.getDefinition(name);\n\n          if (def != null) {\n            var ret = FunctionExt.call(def.set, _this2.view, val, getOptions());\n\n            if (typeof ret === 'object') {\n              nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);\n            } else if (ret != null) {\n              nodeAttrs[name] = ret;\n            }\n          }\n        });\n      }\n\n      if (Dom.isHTMLElement(elem)) {\n        // TODO: setting the `transform` attribute on HTMLElements\n        // via `node.style.transform = 'matrix(...)';` would introduce\n        // a breaking change (e.g. basic.TextBlock).\n        this.view.setAttrs(nodeAttrs, elem);\n        return;\n      } // The final translation of the subelement.\n\n\n      var nodeTransform = nodeAttrs.transform;\n      var transform = nodeTransform ? \"\".concat(nodeTransform) : null;\n      var nodeMatrix = Dom.transformStringToMatrix(transform);\n      var nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);\n\n      if (nodeTransform) {\n        delete nodeAttrs.transform;\n        nodeMatrix.e = 0;\n        nodeMatrix.f = 0;\n      } // Calculates node scale determined by the scalable group.\n\n\n      var sx = 1;\n      var sy = 1;\n\n      if (positionAttrs || offsetAttrs) {\n        var scale = this.view.getScaleOfElement(elem, options.scalableNode);\n        sx = scale.sx;\n        sy = scale.sy;\n      }\n\n      var positioned = false;\n\n      if (positionAttrs != null) {\n        Object.keys(positionAttrs).forEach(function (name) {\n          var val = positionAttrs[name];\n\n          var def = _this2.getDefinition(name);\n\n          if (def != null) {\n            var ts = FunctionExt.call(def.position, _this2.view, val, getOptions());\n\n            if (ts != null) {\n              positioned = true;\n              nodePosition.translate(Point.create(ts).scale(sx, sy));\n            }\n          }\n        });\n      } // The node bounding box could depend on the `size`\n      // set from the previous loop.\n\n\n      this.view.setAttrs(nodeAttrs, elem);\n      var offseted = false;\n\n      if (offsetAttrs != null) {\n        // Check if the node is visible\n        var nodeBoundingRect = this.view.getBoundingRectOfElement(elem);\n\n        if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n          var nodeBBox = Dom.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n          Object.keys(offsetAttrs).forEach(function (name) {\n            var val = offsetAttrs[name];\n\n            var def = _this2.getDefinition(name);\n\n            if (def != null) {\n              var ts = FunctionExt.call(def.offset, _this2.view, val, {\n                elem: elem,\n                cell: _this2.cell,\n                view: _this2.view,\n                attrs: rawAttrs,\n                refBBox: nodeBBox\n              });\n\n              if (ts != null) {\n                offseted = true;\n                nodePosition.translate(Point.create(ts).scale(sx, sy));\n              }\n            }\n          });\n        }\n      }\n\n      if (nodeTransform != null || positioned || offseted) {\n        nodePosition.round(1);\n        nodeMatrix.e = nodePosition.x;\n        nodeMatrix.f = nodePosition.y;\n        elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix));\n      } // delay render\n\n\n      var updateDelayAttrs = function updateDelayAttrs() {\n        if (delayAttrs != null) {\n          Object.keys(delayAttrs).forEach(function (name) {\n            var val = delayAttrs[name];\n\n            var def = _this2.getDefinition(name);\n\n            if (def != null) {\n              var ret = FunctionExt.call(def.set, _this2.view, val, getOptions());\n\n              if (typeof ret === 'object') {\n                _this2.view.setAttrs(ret, elem);\n              } else if (ret != null) {\n                _this2.view.setAttrs(_defineProperty({}, name, ret), elem);\n              }\n            }\n          });\n        }\n      };\n\n      if (options.forceSync) {\n        updateDelayAttrs();\n      } else {\n        Scheduler.scheduleTask(updateDelayAttrs);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(rootNode, attrs, options) {\n      var _this3 = this;\n\n      var selectorCache = {};\n      var nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors); // `nodesAttrs` are different from all attributes, when\n      // rendering only attributes sent to this method.\n\n      var nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;\n      var specialItems = [];\n      nodesAttrs.each(function (data) {\n        var node = data.elem;\n        var nodeAttrs = data.attrs;\n\n        var processed = _this3.processAttrs(node, nodeAttrs);\n\n        if (processed.set == null && processed.position == null && processed.offset == null && processed.delay == null) {\n          _this3.view.setAttrs(processed.normal, node);\n        } else {\n          var _data = nodesAllAttrs.get(node);\n\n          var nodeAllAttrs = _data ? _data.attrs : null;\n          var refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;\n          var refNode;\n\n          if (refSelector) {\n            refNode = (selectorCache[refSelector] || _this3.view.find(refSelector, rootNode, options.selectors))[0];\n\n            if (!refNode) {\n              throw new Error(\"\\\"\".concat(refSelector, \"\\\" reference does not exist.\"));\n            }\n          } else {\n            refNode = null;\n          }\n\n          var item = {\n            node: node,\n            refNode: refNode,\n            attributes: nodeAllAttrs,\n            processedAttributes: processed\n          }; // If an element in the list is positioned relative to this one, then\n          // we want to insert this one before it in the list.\n\n          var index = specialItems.findIndex(function (item) {\n            return item.refNode === node;\n          });\n\n          if (index > -1) {\n            specialItems.splice(index, 0, item);\n          } else {\n            specialItems.push(item);\n          }\n        }\n      });\n      var bboxCache = new Dictionary();\n      var rotatableMatrix;\n      specialItems.forEach(function (item) {\n        var node = item.node;\n        var refNode = item.refNode;\n        var unrotatedRefBBox;\n        var isRefNodeRotatable = refNode != null && options.rotatableNode != null && Dom.contains(options.rotatableNode, refNode); // Find the reference element bounding box. If no reference was\n        // provided, we use the optional bounding box.\n\n        if (refNode) {\n          unrotatedRefBBox = bboxCache.get(refNode);\n        }\n\n        if (!unrotatedRefBBox) {\n          var target = isRefNodeRotatable ? options.rotatableNode : rootNode;\n          unrotatedRefBBox = refNode ? Dom.getBBox(refNode, {\n            target: target\n          }) : options.rootBBox;\n\n          if (refNode) {\n            bboxCache.set(refNode, unrotatedRefBBox);\n          }\n        }\n\n        var processedAttrs;\n\n        if (options.attrs && item.attributes) {\n          // If there was a special attribute affecting the position amongst\n          // passed-in attributes we have to merge it with the rest of the\n          // element's attributes as they are necessary to update the position\n          // relatively (i.e `ref-x` && 'ref-dx').\n          processedAttrs = _this3.processAttrs(node, item.attributes);\n\n          _this3.mergeProcessedAttrs(processedAttrs, item.processedAttributes);\n        } else {\n          processedAttrs = item.processedAttributes;\n        }\n\n        var refBBox = unrotatedRefBBox;\n\n        if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {\n          // If the referenced node is inside the rotatable group while the\n          // updated node is outside, we need to take the rotatable node\n          // transformation into account.\n          if (!rotatableMatrix) {\n            rotatableMatrix = Dom.transformStringToMatrix(Dom.attr(options.rotatableNode, 'transform'));\n          }\n\n          refBBox = Dom.transformRectangle(unrotatedRefBBox, rotatableMatrix);\n        }\n\n        var caller = specialItems.find(function (item) {\n          return item.refNode === node;\n        });\n\n        if (caller) {\n          options.forceSync = true;\n        }\n\n        _this3.updateRelativeAttrs(node, processedAttrs, refBBox, options);\n      });\n    }\n  }, {\n    key: \"cell\",\n    get: function get() {\n      return this.view.cell;\n    }\n  }]);\n\n  return AttrManager;\n}();\n\n(function (AttrManager) {\n  AttrManager.CASE_SENSITIVE_ATTR = ['viewBox'];\n  AttrManager.DELAY_ATTRS = ['text', 'textWrap', 'sourceMarker', 'targetMarker'];\n})(AttrManager || (AttrManager = {}));","map":null,"metadata":{},"sourceType":"module"}