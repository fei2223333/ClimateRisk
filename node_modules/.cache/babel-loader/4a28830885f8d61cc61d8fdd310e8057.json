{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt, FunctionExt } from '../util';\nimport { Basecoat } from '../common';\nimport { Model } from '../model/model';\nexport var HistoryManager = /*#__PURE__*/function (_Basecoat) {\n  _inherits(HistoryManager, _Basecoat);\n\n  function HistoryManager(options) {\n    var _this;\n\n    _classCallCheck(this, HistoryManager);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HistoryManager).call(this));\n    _this.batchCommands = null;\n    _this.batchLevel = 0;\n    _this.lastBatchIndex = -1;\n    _this.freezed = false;\n    _this.handlers = [];\n    _this.graph = options.graph;\n    _this.model = options.graph.model;\n    _this.options = Util.getOptions(options);\n    _this.validator = new HistoryManager.Validator({\n      history: _assertThisInitialized(_assertThisInitialized(_this)),\n      cancelInvalid: _this.options.cancelInvalid\n    });\n\n    _this.clean();\n\n    _this.startListening();\n\n    return _this;\n  }\n\n  _createClass(HistoryManager, [{\n    key: \"enable\",\n    value: function enable() {\n      if (this.disabled) {\n        this.options.enabled = true;\n      }\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      if (!this.disabled) {\n        this.options.enabled = false;\n      }\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.disabled) {\n        var cmd = this.undoStack.pop();\n\n        if (cmd) {\n          this.revertCommand(cmd, options);\n          this.redoStack.push(cmd);\n          this.notify('undo', cmd, options);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.disabled) {\n        var cmd = this.redoStack.pop();\n\n        if (cmd) {\n          this.applyCommand(cmd, options);\n          this.undoStack.push(cmd);\n          this.notify('redo', cmd, options);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Same as `undo()` but does not store the undo-ed command to the\n     * `redoStack`. Canceled command therefore cannot be redo-ed.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.disabled) {\n        var cmd = this.undoStack.pop();\n\n        if (cmd) {\n          this.revertCommand(cmd, options);\n          this.redoStack = [];\n          this.notify('cancel', cmd, options);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.undoStack = [];\n      this.redoStack = [];\n      this.notify('clean', null, options);\n      return this;\n    }\n  }, {\n    key: \"canUndo\",\n    value: function canUndo() {\n      return !this.disabled && this.undoStack.length > 0;\n    }\n  }, {\n    key: \"canRedo\",\n    value: function canRedo() {\n      return !this.disabled && this.redoStack.length > 0;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(events) {\n      var _this$validator;\n\n      for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        callbacks[_key - 1] = arguments[_key];\n      }\n\n      (_this$validator = this.validator).validate.apply(_this$validator, [events].concat(callbacks));\n\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.validator.dispose();\n      this.clean();\n      this.stopListening();\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      var _this2 = this;\n\n      this.model.on('batch:start', this.initBatchCommand, this);\n      this.model.on('batch:stop', this.storeBatchCommand, this);\n\n      if (this.options.eventNames) {\n        this.options.eventNames.forEach(function (name, index) {\n          _this2.handlers[index] = _this2.addCommand.bind(_this2, name);\n\n          _this2.model.on(name, _this2.handlers[index]);\n        });\n      }\n\n      this.validator.on('invalid', function (args) {\n        return _this2.trigger('invalid', args);\n      });\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      var _this3 = this;\n\n      this.model.off('batch:start', this.initBatchCommand, this);\n      this.model.off('batch:stop', this.storeBatchCommand, this);\n\n      if (this.options.eventNames) {\n        this.options.eventNames.forEach(function (name, index) {\n          _this3.model.off(name, _this3.handlers[index]);\n        });\n        this.handlers.length = 0;\n      }\n\n      this.validator.off('invalid');\n    }\n  }, {\n    key: \"createCommand\",\n    value: function createCommand(options) {\n      return {\n        batch: options ? options.batch : false,\n        data: {}\n      };\n    }\n  }, {\n    key: \"revertCommand\",\n    value: function revertCommand(cmd, options) {\n      this.freezed = true;\n      var cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n\n      for (var i = cmds.length - 1; i >= 0; i -= 1) {\n        var _cmd = cmds[i];\n        var localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(_cmd.options, this.options.revertOptionsList || []));\n        this.executeCommand(_cmd, true, localOptions);\n      }\n\n      this.freezed = false;\n    }\n  }, {\n    key: \"applyCommand\",\n    value: function applyCommand(cmd, options) {\n      this.freezed = true;\n      var cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n\n      for (var i = 0; i < cmds.length; i += 1) {\n        var _cmd2 = cmds[i];\n        var localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(_cmd2.options, this.options.applyOptionsList || []));\n        this.executeCommand(_cmd2, false, localOptions);\n      }\n\n      this.freezed = false;\n    }\n  }, {\n    key: \"executeCommand\",\n    value: function executeCommand(cmd, revert, options) {\n      var model = this.model; // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)\n\n      var cell = model.getCell(cmd.data.id);\n      var event = cmd.event;\n\n      if (Util.isAddEvent(event) && revert || Util.isRemoveEvent(event) && !revert) {\n        cell.remove(options);\n      } else if (Util.isAddEvent(event) && !revert || Util.isRemoveEvent(event) && revert) {\n        var data = cmd.data;\n\n        if (data.node) {\n          model.addNode(data.props, options);\n        } else if (data.edge) {\n          model.addEdge(data.props, options);\n        }\n      } else if (Util.isChangeEvent(event)) {\n        var _data = cmd.data;\n        var key = _data.key;\n\n        if (key) {\n          var value = revert ? _data.prev[key] : _data.next[key];\n          cell.prop(key, value, options);\n        }\n      } else {\n        var executeCommand = this.options.executeCommand;\n\n        if (executeCommand) {\n          FunctionExt.call(executeCommand, this, cmd, revert, options);\n        }\n      }\n    }\n  }, {\n    key: \"addCommand\",\n    value: function addCommand(event, args) {\n      if (this.freezed || this.disabled) {\n        return;\n      }\n\n      var eventArgs = args;\n      var options = eventArgs.options || {};\n\n      if (options.dryrun) {\n        return;\n      }\n\n      if (Util.isAddEvent(event) && this.options.ignoreAdd || Util.isRemoveEvent(event) && this.options.ignoreRemove || Util.isChangeEvent(event) && this.options.ignoreChange) {\n        return;\n      } // before\n      // ------\n\n\n      var before = this.options.beforeAddCommand;\n\n      if (before != null && FunctionExt.call(before, this, event, args) === false) {\n        return;\n      }\n\n      if (event === 'cell:change:*') {\n        // eslint-disable-next-line\n        event = \"cell:change:\".concat(eventArgs.key);\n      }\n\n      var cell = eventArgs.cell;\n      var isModelChange = Model.isModel(cell);\n      var cmd;\n\n      if (this.batchCommands) {\n        // In most cases we are working with same object, doing\n        // same action etc. translate an object piece by piece.\n        cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)]; // Check if we are start working with new object or performing different\n        // action with it. Note, that command is uninitialized when lastCmdIndex\n        // equals -1. In that case we are done, command we were looking for is\n        // already set\n\n        var diffId = isModelChange && !cmd.modelChange || cmd.data.id !== cell.id;\n        var diffName = cmd.event !== event;\n\n        if (this.lastBatchIndex >= 0 && (diffId || diffName)) {\n          // Trying to find command first, which was performing same\n          // action with the object as we are doing now with cell.\n          var index = this.batchCommands.findIndex(function (cmd) {\n            return (isModelChange && cmd.modelChange || cmd.data.id === cell.id) && cmd.event === event;\n          });\n\n          if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n            cmd = this.createCommand({\n              batch: true\n            });\n          } else {\n            cmd = this.batchCommands[index];\n            this.batchCommands.splice(index, 1);\n          }\n\n          this.batchCommands.push(cmd);\n          this.lastBatchIndex = this.batchCommands.length - 1;\n        }\n      } else {\n        cmd = this.createCommand({\n          batch: false\n        });\n      } // add & remove\n      // ------------\n\n\n      if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n        var data = cmd.data;\n        cmd.event = event;\n        cmd.options = options;\n        data.id = cell.id;\n        data.props = ObjectExt.cloneDeep(cell.toJSON());\n\n        if (cell.isEdge()) {\n          data.edge = true;\n        } else if (cell.isNode()) {\n          data.node = true;\n        }\n\n        return this.push(cmd, options);\n      } // change:*\n      // --------\n\n\n      if (Util.isChangeEvent(event)) {\n        var key = args.key;\n        var _data2 = cmd.data;\n\n        if (!cmd.batch || !cmd.event) {\n          // Do this only once. Set previous data and action (also\n          // serves as a flag so that we don't repeat this branche).\n          cmd.event = event;\n          cmd.options = options;\n          _data2.key = key;\n\n          if (_data2.prev == null) {\n            _data2.prev = {};\n          }\n\n          _data2.prev[key] = ObjectExt.clone(cell.previous(key));\n\n          if (isModelChange) {\n            cmd.modelChange = true;\n          } else {\n            _data2.id = cell.id;\n          }\n        }\n\n        if (_data2.next == null) {\n          _data2.next = {};\n        }\n\n        _data2.next[key] = ObjectExt.clone(cell.prop(key));\n        return this.push(cmd, options);\n      } // others\n      // ------\n\n\n      var afterAddCommand = this.options.afterAddCommand;\n\n      if (afterAddCommand) {\n        FunctionExt.call(afterAddCommand, this, event, args, cmd);\n      }\n\n      this.push(cmd, options);\n    }\n    /**\n     * Gather multiple changes into a single command. These commands could\n     * be reverted with single `undo()` call. From the moment the function\n     * is called every change made on model is not stored into the undoStack.\n     * Changes are temporarily kept until `storeBatchCommand()` is called.\n     */\n    // eslint-disable-next-line\n\n  }, {\n    key: \"initBatchCommand\",\n    value: function initBatchCommand(options) {\n      if (this.freezed) {\n        return;\n      }\n\n      if (this.batchCommands) {\n        this.batchLevel += 1;\n      } else {\n        this.batchCommands = [this.createCommand({\n          batch: true\n        })];\n        this.batchLevel = 0;\n        this.lastBatchIndex = -1;\n      }\n    }\n    /**\n     * Store changes temporarily kept in the undoStack. You have to call this\n     * function as many times as `initBatchCommand()` been called.\n     */\n\n  }, {\n    key: \"storeBatchCommand\",\n    value: function storeBatchCommand(options) {\n      if (this.freezed) {\n        return;\n      }\n\n      if (this.batchCommands && this.batchLevel <= 0) {\n        var cmds = this.filterBatchCommand(this.batchCommands);\n\n        if (cmds.length > 0) {\n          this.redoStack = [];\n          this.undoStack.push(cmds);\n          this.notify('add', cmds, options);\n        }\n\n        this.batchCommands = null;\n        this.lastBatchIndex = -1;\n        this.batchLevel = 0;\n      } else if (this.batchCommands && this.batchLevel > 0) {\n        this.batchLevel -= 1;\n      }\n    }\n  }, {\n    key: \"filterBatchCommand\",\n    value: function filterBatchCommand(batchCommands) {\n      var cmds = batchCommands.slice();\n      var result = [];\n\n      var _loop = function _loop() {\n        var cmd = cmds.shift();\n        var evt = cmd.event;\n        var id = cmd.data.id;\n\n        if (evt != null && (id != null || cmd.modelChange)) {\n          if (Util.isAddEvent(evt)) {\n            var index = cmds.findIndex(function (c) {\n              return Util.isRemoveEvent(c.event) && c.data.id === id;\n            });\n\n            if (index >= 0) {\n              cmds = cmds.filter(function (c, i) {\n                return index < i || c.data.id !== id;\n              });\n              return \"continue\";\n            }\n          } else if (Util.isRemoveEvent(evt)) {\n            var _index = cmds.findIndex(function (c) {\n              return Util.isAddEvent(c.event) && c.data.id === id;\n            });\n\n            if (_index >= 0) {\n              cmds.splice(_index, 1);\n              return \"continue\";\n            }\n          } else if (Util.isChangeEvent(evt)) {\n            var data = cmd.data;\n\n            if (ObjectExt.isEqual(data.prev, data.next)) {\n              return \"continue\";\n            }\n          } else {// pass\n          }\n\n          result.push(cmd);\n        }\n      };\n\n      while (cmds.length > 0) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(event, cmd, options) {\n      var cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];\n      this.emit(event, {\n        cmds: cmds,\n        options: options\n      });\n      this.emit('change', {\n        cmds: cmds,\n        options: options\n      });\n    }\n  }, {\n    key: \"push\",\n    value: function push(cmd, options) {\n      this.redoStack = [];\n\n      if (cmd.batch) {\n        this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);\n        this.emit('batch', {\n          cmd: cmd,\n          options: options\n        });\n      } else {\n        this.undoStack.push(cmd);\n        this.notify('add', cmd, options);\n      }\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this.options.enabled !== true;\n    }\n  }]);\n\n  return HistoryManager;\n}(Basecoat);\n\n__decorate([Basecoat.dispose()], HistoryManager.prototype, \"dispose\", null);\n\n(function (HistoryManager) {\n  /**\n   * Runs a set of callbacks to determine if a command is valid. This is\n   * useful for checking if a certain action in your application does\n   * lead to an invalid state of the graph.\n   */\n  var Validator = /*#__PURE__*/function (_Basecoat2) {\n    _inherits(Validator, _Basecoat2);\n\n    function Validator(options) {\n      var _this4;\n\n      _classCallCheck(this, Validator);\n\n      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Validator).call(this));\n      _this4.map = {};\n      _this4.command = options.history;\n      _this4.cancelInvalid = options.cancelInvalid !== false;\n\n      _this4.command.on('add', _this4.onCommandAdded, _assertThisInitialized(_assertThisInitialized(_this4)));\n\n      return _this4;\n    }\n\n    _createClass(Validator, [{\n      key: \"onCommandAdded\",\n      value: function onCommandAdded(_ref) {\n        var _this5 = this;\n\n        var cmds = _ref.cmds;\n        return Array.isArray(cmds) ? cmds.every(function (cmd) {\n          return _this5.isValidCommand(cmd);\n        }) : this.isValidCommand(cmds);\n      }\n    }, {\n      key: \"isValidCommand\",\n      value: function isValidCommand(cmd) {\n        if (cmd.options && cmd.options.validation === false) {\n          return true;\n        }\n\n        var callbacks = cmd.event && this.map[cmd.event] || [];\n        var handoverErr = null;\n        callbacks.forEach(function (routes) {\n          var i = 0;\n\n          var rollup = function rollup(err) {\n            var fn = routes[i];\n            i += 1;\n\n            try {\n              if (fn) {\n                fn(err, cmd, rollup);\n              } else {\n                handoverErr = err;\n                return;\n              }\n            } catch (err) {\n              rollup(err);\n            }\n          };\n\n          rollup(handoverErr);\n        });\n\n        if (handoverErr) {\n          if (this.cancelInvalid) {\n            this.command.cancel();\n          }\n\n          this.emit('invalid', {\n            err: handoverErr\n          });\n          return false;\n        }\n\n        return true;\n      }\n    }, {\n      key: \"validate\",\n      value: function validate(events) {\n        var _this6 = this;\n\n        for (var _len2 = arguments.length, callbacks = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          callbacks[_key2 - 1] = arguments[_key2];\n        }\n\n        var evts = Array.isArray(events) ? events : events.split(/\\s+/);\n        callbacks.forEach(function (callback) {\n          if (typeof callback !== 'function') {\n            throw new Error(\"\".concat(evts.join(' '), \" requires callback functions.\"));\n          }\n        });\n        evts.forEach(function (event) {\n          if (_this6.map[event] == null) {\n            _this6.map[event] = [];\n          }\n\n          _this6.map[event].push(callbacks);\n        });\n        return this;\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this.command.off('add', this.onCommandAdded, this);\n      }\n    }]);\n\n    return Validator;\n  }(Basecoat);\n\n  __decorate([Basecoat.dispose()], Validator.prototype, \"dispose\", null);\n\n  HistoryManager.Validator = Validator;\n})(HistoryManager || (HistoryManager = {}));\n\nvar Util;\n\n(function (Util) {\n  function isAddEvent(event) {\n    return event === 'cell:added';\n  }\n\n  Util.isAddEvent = isAddEvent;\n\n  function isRemoveEvent(event) {\n    return event === 'cell:removed';\n  }\n\n  Util.isRemoveEvent = isRemoveEvent;\n\n  function isChangeEvent(event) {\n    return event != null && event.startsWith('cell:change:');\n  }\n\n  Util.isChangeEvent = isChangeEvent;\n\n  function getOptions(options) {\n    var graph = options.graph,\n        others = __rest(options, [\"graph\"]);\n\n    var reservedNames = ['cell:added', 'cell:removed', 'cell:change:*'];\n    var batchEvents = ['batch:start', 'batch:stop'];\n    var eventNames = options.eventNames ? options.eventNames.filter(function (event) {\n      return !(Util.isChangeEvent(event) || reservedNames.includes(event) || batchEvents.includes(event));\n    }) : reservedNames;\n    return Object.assign(Object.assign({}, others), {\n      eventNames: eventNames,\n      applyOptionsList: options.applyOptionsList || ['propertyPath'],\n      revertOptionsList: options.revertOptionsList || ['propertyPath']\n    });\n  }\n\n  Util.getOptions = getOptions;\n\n  function sortBatchCommands(cmds) {\n    var results = [];\n\n    for (var i = 0, ii = cmds.length; i < ii; i += 1) {\n      var cmd = cmds[i];\n      var index = null;\n\n      if (Util.isAddEvent(cmd.event)) {\n        var id = cmd.data.id;\n\n        for (var j = 0; j < i; j += 1) {\n          if (cmds[j].data.id === id) {\n            index = j;\n            break;\n          }\n        }\n      }\n\n      if (index !== null) {\n        results.splice(index, 0, cmd);\n      } else {\n        results.push(cmd);\n      }\n    }\n\n    return results;\n  }\n\n  Util.sortBatchCommands = sortBatchCommands;\n})(Util || (Util = {}));","map":null,"metadata":{},"sourceType":"module"}