{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FruchtermanLayout = void 0;\n\nvar base_1 = require(\"./base\");\n\nvar util_1 = require(\"../util\");\n\nvar SPEED_DIVISOR = 800;\n/**\n * fruchterman 布局\n */\n\nvar FruchtermanLayout =\n/** @class */\nfunction (_super) {\n  __extends(FruchtermanLayout, _super);\n\n  function FruchtermanLayout(options) {\n    var _this = _super.call(this) || this;\n    /** 停止迭代的最大迭代数 */\n\n\n    _this.maxIteration = 1000;\n    /** 是否启动 worker */\n\n    _this.workerEnabled = false;\n    /** 重力大小，影响图的紧凑程度 */\n\n    _this.gravity = 10;\n    /** 速度 */\n\n    _this.speed = 5;\n    /** 是否产生聚类力 */\n\n    _this.clustering = false;\n    /** 聚类力大小 */\n\n    _this.clusterGravity = 10;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.nodeMap = {};\n    _this.nodeIdxMap = {};\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n    /** 每次迭代结束的回调函数 */\n\n\n    _this.tick = function () {};\n    /** 是否使用 window.setInterval 运行迭代 */\n\n\n    _this.animate = true;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  FruchtermanLayout.prototype.getDefaultCfg = function () {\n    return {\n      maxIteration: 1000,\n      gravity: 10,\n      speed: 1,\n      clustering: false,\n      clusterGravity: 10,\n      animate: true\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  FruchtermanLayout.prototype.execute = function () {\n    var _this = this;\n\n    var _a, _b;\n\n    var self = this;\n    var nodes = self.nodes;\n\n    if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n      window.clearInterval(self.timeInterval);\n    }\n\n    if (!nodes || nodes.length === 0) {\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    var center = self.center;\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n      return;\n    }\n\n    var nodeMap = {};\n    var nodeIdxMap = {};\n    nodes.forEach(function (node, i) {\n      if (!(0, util_1.isNumber)(node.x)) node.x = Math.random() * _this.width;\n      if (!(0, util_1.isNumber)(node.y)) node.y = Math.random() * _this.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap; // layout\n\n    return self.run();\n  };\n\n  FruchtermanLayout.prototype.run = function () {\n    var _a;\n\n    var self = this;\n    var nodes = self.nodes;\n    if (!nodes) return;\n    var edges = self.edges,\n        maxIteration = self.maxIteration,\n        workerEnabled = self.workerEnabled,\n        clustering = self.clustering,\n        animate = self.animate;\n    var clusterMap = {};\n\n    if (clustering) {\n      nodes.forEach(function (n) {\n        if (clusterMap[n.cluster] === undefined) {\n          clusterMap[n.cluster] = {\n            name: n.cluster,\n            cx: 0,\n            cy: 0,\n            count: 0\n          };\n        }\n      });\n    }\n\n    if (workerEnabled || !animate) {\n      for (var i = 0; i < maxIteration; i++) {\n        self.runOneStep(clusterMap);\n      }\n\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n    } else {\n      if (typeof window === \"undefined\") return;\n      var iter_1 = 0; // interval for render the result after each iteration\n\n      this.timeInterval = window.setInterval(function () {\n        var _a;\n\n        self.runOneStep(clusterMap);\n        iter_1++;\n\n        if (iter_1 >= maxIteration) {\n          (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n          window.clearInterval(self.timeInterval);\n        }\n      }, 0);\n    }\n\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  };\n\n  FruchtermanLayout.prototype.runOneStep = function (clusterMap) {\n    var _a;\n\n    var self = this;\n    var nodes = self.nodes;\n    if (!nodes) return;\n    var edges = self.edges,\n        center = self.center,\n        gravity = self.gravity,\n        speed = self.speed,\n        clustering = self.clustering;\n    var area = self.height * self.width;\n    var maxDisplace = Math.sqrt(area) / 10;\n    var k2 = area / (nodes.length + 1);\n    var k = Math.sqrt(k2);\n    var displacements = [];\n    nodes.forEach(function (_, j) {\n      displacements[j] = {\n        x: 0,\n        y: 0\n      };\n    });\n    self.applyCalculate(nodes, edges, displacements, k, k2); // gravity for clusters\n\n    if (clustering) {\n      // re-compute the clustering centers\n      for (var key in clusterMap) {\n        clusterMap[key].cx = 0;\n        clusterMap[key].cy = 0;\n        clusterMap[key].count = 0;\n      }\n\n      nodes.forEach(function (n) {\n        var c = clusterMap[n.cluster];\n\n        if ((0, util_1.isNumber)(n.x)) {\n          c.cx += n.x;\n        }\n\n        if ((0, util_1.isNumber)(n.y)) {\n          c.cy += n.y;\n        }\n\n        c.count++;\n      });\n\n      for (var key in clusterMap) {\n        clusterMap[key].cx /= clusterMap[key].count;\n        clusterMap[key].cy /= clusterMap[key].count;\n      } // compute the cluster gravity forces\n\n\n      var clusterGravity_1 = self.clusterGravity || gravity;\n      nodes.forEach(function (n, j) {\n        if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y)) return;\n        var c = clusterMap[n.cluster];\n        var distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));\n        var gravityForce = k * clusterGravity_1;\n        displacements[j].x -= gravityForce * (n.x - c.cx) / distLength;\n        displacements[j].y -= gravityForce * (n.y - c.cy) / distLength;\n      });\n    } // gravity\n\n\n    nodes.forEach(function (n, j) {\n      if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y)) return;\n      var gravityForce = 0.01 * k * gravity;\n      displacements[j].x -= gravityForce * (n.x - center[0]);\n      displacements[j].y -= gravityForce * (n.y - center[1]);\n    }); // move\n\n    nodes.forEach(function (n, j) {\n      if ((0, util_1.isNumber)(n.fx) && (0, util_1.isNumber)(n.fy)) {\n        n.x = n.fx;\n        n.y = n.fy;\n        return;\n      }\n\n      if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y)) return;\n      var distLength = Math.sqrt(displacements[j].x * displacements[j].x + displacements[j].y * displacements[j].y);\n\n      if (distLength > 0) {\n        // && !n.isFixed()\n        var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n        n.x += displacements[j].x / distLength * limitedDist;\n        n.y += displacements[j].y / distLength * limitedDist;\n      }\n    });\n    (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);\n  };\n\n  FruchtermanLayout.prototype.applyCalculate = function (nodes, edges, displacements, k, k2) {\n    var self = this;\n    self.calRepulsive(nodes, displacements, k2);\n    if (edges) self.calAttractive(edges, displacements, k);\n  };\n\n  FruchtermanLayout.prototype.calRepulsive = function (nodes, displacements, k2) {\n    nodes.forEach(function (v, i) {\n      displacements[i] = {\n        x: 0,\n        y: 0\n      };\n      nodes.forEach(function (u, j) {\n        if (i === j) {\n          return;\n        }\n\n        if (!(0, util_1.isNumber)(v.x) || !(0, util_1.isNumber)(u.x) || !(0, util_1.isNumber)(v.y) || !(0, util_1.isNumber)(u.y)) {\n          return;\n        }\n\n        var vecX = v.x - u.x;\n        var vecY = v.y - u.y;\n        var vecLengthSqr = vecX * vecX + vecY * vecY;\n\n        if (vecLengthSqr === 0) {\n          vecLengthSqr = 1;\n          var sign = i > j ? 1 : -1;\n          vecX = 0.01 * sign;\n          vecY = 0.01 * sign;\n        }\n\n        var common = k2 / vecLengthSqr;\n        displacements[i].x += vecX * common;\n        displacements[i].y += vecY * common;\n      });\n    });\n  };\n\n  FruchtermanLayout.prototype.calAttractive = function (edges, displacements, k) {\n    var _this = this;\n\n    edges.forEach(function (e) {\n      var source = (0, util_1.getEdgeTerminal)(e, 'source');\n      var target = (0, util_1.getEdgeTerminal)(e, 'target');\n      if (!source || !target) return;\n      var uIndex = _this.nodeIdxMap[source];\n      var vIndex = _this.nodeIdxMap[target];\n\n      if (uIndex === vIndex) {\n        return;\n      }\n\n      var u = _this.nodeMap[source];\n      var v = _this.nodeMap[target];\n\n      if (!(0, util_1.isNumber)(v.x) || !(0, util_1.isNumber)(u.x) || !(0, util_1.isNumber)(v.y) || !(0, util_1.isNumber)(u.y)) {\n        return;\n      }\n\n      var vecX = v.x - u.x;\n      var vecY = v.y - u.y;\n      var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n      var common = vecLength * vecLength / k;\n      displacements[vIndex].x -= vecX / vecLength * common;\n      displacements[vIndex].y -= vecY / vecLength * common;\n      displacements[uIndex].x += vecX / vecLength * common;\n      displacements[uIndex].y += vecY / vecLength * common;\n    });\n  };\n\n  FruchtermanLayout.prototype.stop = function () {\n    if (this.timeInterval && typeof window !== \"undefined\") {\n      window.clearInterval(this.timeInterval);\n    }\n  };\n\n  FruchtermanLayout.prototype.destroy = function () {\n    var self = this;\n    self.stop();\n    self.tick = null;\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  };\n\n  FruchtermanLayout.prototype.getType = function () {\n    return \"fruchterman\";\n  };\n\n  return FruchtermanLayout;\n}(base_1.Base);\n\nexports.FruchtermanLayout = FruchtermanLayout;","map":null,"metadata":{},"sourceType":"script"}