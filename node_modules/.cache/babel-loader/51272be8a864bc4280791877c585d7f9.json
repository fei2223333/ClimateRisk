{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DagreCompoundLayout = void 0;\n\nvar base_1 = require(\"./base\");\n\nvar dagre_compound_1 = require(\"dagre-compound\");\n\nvar util_1 = require(\"../util\");\n\nvar DagreCompoundLayout =\n/** @class */\nfunction (_super) {\n  __extends(DagreCompoundLayout, _super);\n\n  function DagreCompoundLayout(options) {\n    var _this = _super.call(this) || this;\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n\n    _this.rankdir = 'TB';\n    /** 节点水平间距(px) */\n\n    _this.nodesep = 50;\n    /** 边水平间距(px) */\n\n    _this.edgesep = 5;\n    /** 每一层节点之间间距 */\n\n    _this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    _this.controlPoints = true;\n    /** 是否保留使用布局计算的锚点 */\n\n    _this.anchorPoint = true;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.combos = [];\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  DagreCompoundLayout.prototype.getDefaultCfg = function () {\n    return {\n      rankdir: 'TB',\n      align: undefined,\n      begin: undefined,\n      nodeSize: undefined,\n      nodesep: 50,\n      ranksep: 50,\n      controlPoints: true,\n      anchorPoint: true // 是否使用布局计算的锚点\n\n    };\n  };\n\n  DagreCompoundLayout.prototype.init = function (data) {\n    var hiddenNodes = data.hiddenNodes || []; // 被隐藏的节点\n\n    var hiddenEdges = data.hiddenEdges || []; // 被隐藏的边\n\n    var hiddenCombos = data.hiddenCombos || []; // 赋值 hiddenCombos\n    // 确保此次排序按照用户输入顺序\n\n    this.nodes = this.getDataByOrder((data.nodes || []).concat(hiddenNodes));\n    this.edges = this.getDataByOrder((data.edges || []).concat(hiddenEdges));\n    this.combos = (data.combos || []).concat(hiddenCombos.map(function (hc) {\n      return __assign(__assign({}, hc), {\n        collapsed: true\n      });\n    }));\n  };\n\n  DagreCompoundLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes,\n        edges = self.edges;\n    if (!nodes) return;\n\n    var _a = self.getLayoutConfig(),\n        graphDef = _a.graphDef,\n        graphOption = _a.graphOption,\n        graphSettings = _a.graphSettings;\n\n    var renderInfo = (0, dagre_compound_1.buildGraph)(graphDef, graphOption, graphSettings);\n    var flattenedRenderInfo = (0, dagre_compound_1.flatGraph)(renderInfo, true); // 打平数据进行遍历\n\n    this.updatePosition(flattenedRenderInfo);\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  };\n  /**\n   * combo 模式下查找节点完整路径\n   * @param nodeId\n   * @private\n   */\n\n\n  DagreCompoundLayout.prototype.getNodePath = function (nodeId) {\n    var self = this;\n    var nodes = self.nodes,\n        combos = self.combos;\n    var targetNode = nodes.find(function (n) {\n      return n.id === nodeId;\n    });\n\n    var findPath = function findPath(comboId, fullPath) {\n      if (fullPath === void 0) {\n        fullPath = [];\n      }\n\n      var combo = combos.find(function (c) {\n        return c.id === comboId;\n      });\n\n      if (combo) {\n        fullPath.unshift(comboId);\n\n        if (combo.parentId) {\n          return findPath(combo.parentId, fullPath);\n        }\n\n        return fullPath;\n      }\n\n      return fullPath;\n    };\n\n    if (targetNode && targetNode.comboId) {\n      return findPath(targetNode.comboId, [nodeId]);\n    }\n\n    return [nodeId];\n  };\n  /** 准备 dagre-compound 布局参数 */\n\n\n  DagreCompoundLayout.prototype.getLayoutConfig = function () {\n    var _a, _b, _c;\n\n    var self = this;\n    var nodes = self.nodes,\n        edges = self.edges,\n        combos = self.combos,\n        nodeSize = self.nodeSize,\n        rankdir = self.rankdir,\n        align = self.align,\n        edgesep = self.edgesep,\n        nodesep = self.nodesep,\n        ranksep = self.ranksep,\n        settings = self.settings;\n    var compound = (combos || []).reduce(function (pre, cur) {\n      var matchedNodes = nodes.filter(function (n) {\n        return n.comboId === cur.id;\n      }).map(function (n) {\n        return n.id;\n      });\n      var matchedCombos = (combos || []).filter(function (n) {\n        return n.parentId === cur.id;\n      }).map(function (n) {\n        return n.id;\n      });\n\n      if (matchedNodes.length || matchedCombos.length) {\n        pre[cur.id] = __spreadArray(__spreadArray([], matchedNodes, true), matchedCombos, true);\n      }\n\n      return pre;\n    }, {});\n    /** 计算 nodeSize */\n\n    var nodeSizeFunc;\n\n    if (!nodeSize) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        if (d && d.size) {\n          if ((0, util_1.isArray)(d.size)) {\n            return d.size;\n          }\n\n          if ((0, util_1.isObject)(d.size)) {\n            return [d.size.width || 40, d.size.height || 40];\n          }\n\n          return [d.size, d.size];\n        }\n\n        return [40, 40];\n      };\n    } else if ((0, util_1.isArray)(nodeSize)) {\n      nodeSizeFunc = function nodeSizeFunc() {\n        return nodeSize;\n      };\n    } else {\n      nodeSizeFunc = function nodeSizeFunc() {\n        return [nodeSize, nodeSize];\n      };\n    }\n    /** 计算 comboSize */\n\n\n    var comboSizeFunc = function comboSizeFunc(d) {\n      if (d && d.size) {\n        if ((0, util_1.isArray)(d.size)) {\n          return d.size;\n        }\n\n        return [d.size, d.size];\n      }\n\n      return [80, 40];\n    }; // 接受 defaultCombo 设置的 size\n\n\n    var _d = comboSizeFunc(combos === null || combos === void 0 ? void 0 : combos[0]),\n        metaWidth = _d[0],\n        metaHeight = _d[1]; // 初始化 padding\n\n\n    var subSceneMeta = (_b = (_a = self.graphSettings) === null || _a === void 0 ? void 0 : _a.subScene) === null || _b === void 0 ? void 0 : _b.meta;\n\n    var _e = ((_c = combos.find(function (c) {\n      return !c.collapsed;\n    })) === null || _c === void 0 ? void 0 : _c.padding) || [20, 20, 20, 20],\n        paddingTop = _e[0],\n        paddingRight = _e[1],\n        paddingBottom = _e[2],\n        paddingLeft = _e[3];\n\n    var graphDef = {\n      compound: compound,\n      nodes: __spreadArray([], (nodes || []).map(function (n) {\n        var size = nodeSizeFunc(n);\n        var width = size[0];\n        var height = size[1];\n        return __assign(__assign({}, n), {\n          width: width,\n          height: height\n        });\n      }), true),\n      edges: __spreadArray([], (edges || []).map(function (e) {\n        return __assign(__assign({}, e), {\n          v: e.source,\n          w: e.target\n        });\n      }), true)\n    }; // 需要展开的节点\n\n    var graphOption = {\n      expanded: (combos || []).filter(function (c) {\n        return !c.collapsed;\n      }).map(function (c) {\n        return c.id;\n      })\n    }; // dagre-compound 布局参数\n\n    var graphMetaConfig = {\n      graph: {\n        meta: {\n          align: align,\n          rankDir: rankdir,\n          nodeSep: nodesep,\n          edgeSep: edgesep,\n          rankSep: ranksep\n        }\n      },\n      subScene: {\n        meta: {\n          paddingTop: paddingTop || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop) || 20,\n          paddingRight: paddingRight || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight) || 20,\n          paddingBottom: paddingBottom || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom) || 20,\n          paddingLeft: paddingLeft || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft) || 20,\n          labelHeight: 0\n        }\n      },\n      nodeSize: {\n        meta: {\n          width: metaWidth,\n          height: metaHeight\n        }\n      }\n    }; // 合并用户输入的内容\n\n    var graphSettings = (0, dagre_compound_1.mergeConfig)(settings, __assign({}, (0, dagre_compound_1.mergeConfig)(graphMetaConfig, dagre_compound_1.LAYOUT_CONFIG)));\n    self.graphSettings = graphSettings;\n    return {\n      graphDef: graphDef,\n      graphOption: graphOption,\n      graphSettings: graphSettings\n    };\n  };\n  /** 更新节点与边位置 */\n\n\n  DagreCompoundLayout.prototype.updatePosition = function (flattenedGraph) {\n    var nodes = flattenedGraph.nodes,\n        edges = flattenedGraph.edges;\n    this.updateNodePosition(nodes, edges);\n    this.updateEdgePosition(nodes, edges);\n  };\n\n  DagreCompoundLayout.prototype.getBegin = function (flattenedNodes, flattenedEdges) {\n    var self = this;\n    var begin = self.begin;\n    var dBegin = [0, 0];\n\n    if (begin) {\n      var minX_1 = Infinity;\n      var minY_1 = Infinity;\n      flattenedNodes.forEach(function (node) {\n        if (minX_1 > node.x) minX_1 = node.x;\n        if (minY_1 > node.y) minY_1 = node.y;\n      });\n      flattenedEdges.forEach(function (edge) {\n        edge.points.forEach(function (point) {\n          if (minX_1 > point.x) minX_1 = point.x;\n          if (minY_1 > point.y) minY_1 = point.y;\n        });\n      });\n      dBegin[0] = begin[0] - minX_1;\n      dBegin[1] = begin[1] - minY_1;\n    }\n\n    return dBegin;\n  };\n\n  DagreCompoundLayout.prototype.updateNodePosition = function (flattenedNodes, flattenedEdges) {\n    var self = this;\n    var combos = self.combos,\n        nodes = self.nodes,\n        edges = self.edges,\n        anchorPoint = self.anchorPoint,\n        graphSettings = self.graphSettings;\n    var dBegin = this.getBegin(flattenedNodes, flattenedEdges);\n    flattenedNodes.forEach(function (node) {\n      var _a;\n\n      var x = node.x,\n          y = node.y,\n          id = node.id,\n          type = node.type,\n          coreBox = node.coreBox;\n\n      if (type === dagre_compound_1.HierarchyNodeType.META && id !== dagre_compound_1.ROOT_NAME) {\n        var i = combos.findIndex(function (item) {\n          return item.id === id;\n        });\n        var subSceneMeta = (_a = graphSettings === null || graphSettings === void 0 ? void 0 : graphSettings.subScene) === null || _a === void 0 ? void 0 : _a.meta; // 将布局生成的 combo 位置暂存至 offsetX offsetY\n\n        combos[i].offsetX = x + dBegin[0];\n        combos[i].offsetY = y + dBegin[1];\n        combos[i].fixSize = [coreBox.width, coreBox.height];\n        combos[i].fixCollapseSize = [coreBox.width, coreBox.height]; // 如果设置了收起时隐藏 padding，则手动优化 combo padding 信息，展开的话则恢复\n\n        if (!node.expanded) {\n          combos[i].padding = [0, 0, 0, 0];\n        } else {\n          combos[i].padding = [subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop, subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight, subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom, subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft];\n        }\n      } else if (type === dagre_compound_1.HierarchyNodeType.OP) {\n        var i = nodes.findIndex(function (item) {\n          return item.id === id;\n        });\n        nodes[i].x = x + dBegin[0];\n        nodes[i].y = y + dBegin[1];\n\n        if (anchorPoint) {\n          var anchorPoints_1 = [];\n          var outEdges = flattenedEdges.filter(function (e) {\n            return e.v === id;\n          });\n          var inEdges = flattenedEdges.filter(function (e) {\n            return e.w === id;\n          }); // 指定出边锚点，锚点中心点为 [0.5, 0.5]\n\n          if (outEdges.length > 0) {\n            outEdges.forEach(function (outEdge) {\n              var firstPoint = outEdge.points[0];\n              var anchorPointX = (firstPoint.x - x) / node.width + 0.5;\n              var anchorPointY = (firstPoint.y - y) / node.height + 0.5;\n              anchorPoints_1.push([anchorPointX, anchorPointY]); // 出边对应 source 边锚点\n\n              outEdge.baseEdgeList.forEach(function (baseEdge) {\n                var edge = edges.find(function (e) {\n                  return e.source === baseEdge.v && e.target === baseEdge.w;\n                });\n\n                if (edge) {\n                  edge.sourceAnchor = anchorPoints_1.length - 1;\n                }\n              });\n            });\n          } // 指定入边锚点\n\n\n          if (inEdges.length > 0) {\n            inEdges.forEach(function (inEdge) {\n              var lastPoint = inEdge.points[inEdge.points.length - 1];\n              var anchorPointX = (lastPoint.x - x) / node.width + 0.5;\n              var anchorPointY = (lastPoint.y - y) / node.height + 0.5;\n              anchorPoints_1.push([anchorPointX, anchorPointY]); // 出边对应 source 锚点\n\n              inEdge.baseEdgeList.forEach(function (baseEdge) {\n                var edge = edges.find(function (e) {\n                  return e.source === baseEdge.v && e.target === baseEdge.w;\n                });\n\n                if (edge) {\n                  edge.targetAnchor = anchorPoints_1.length - 1;\n                }\n              });\n            });\n          }\n\n          nodes[i].anchorPoints = anchorPoints_1.length > 0 ? anchorPoints_1 : nodes[i].anchorPoints || [];\n        }\n      }\n    });\n  };\n\n  DagreCompoundLayout.prototype.updateEdgePosition = function (flattenedNodes, flattenedEdges) {\n    var self = this;\n    var combos = self.combos,\n        edges = self.edges,\n        controlPoints = self.controlPoints;\n    var dBegin = this.getBegin(flattenedNodes, flattenedEdges);\n\n    if (controlPoints) {\n      combos.forEach(function (combo) {\n        combo.inEdges = [];\n        combo.outEdges = [];\n      });\n      edges.forEach(function (sourceEdge) {\n        var _a, _b, _c, _d;\n\n        var sourceNode = flattenedNodes.find(function (v) {\n          return v.id === sourceEdge.source;\n        });\n        var targetNode = flattenedNodes.find(function (v) {\n          return v.id === sourceEdge.target;\n        }); // Combo 收起状态，dagre-compound 不会渲染该节点，边需要使用到 group 的边作为补充\n\n        var points = [];\n        var sortedEdges = [];\n\n        if (sourceNode && targetNode) {\n          sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes);\n        } else if (!sourceNode || !targetNode) {\n          /** 存在收起节点时，需要重新计算边的 controlPoints，确保线正常 */\n          // 情况1：目标节点被收起了，向上寻找该节点最近一个存在的父节点\n          var sourceNodePath = self.getNodePath(sourceEdge.source);\n          var targetNodePath = self.getNodePath(sourceEdge.target);\n          var lastExistingSource_1 = sourceNodePath.reverse().slice(!sourceNode ? 1 : 0).find(function (parentId) {\n            return flattenedNodes.find(function (fNode) {\n              return fNode.id === parentId;\n            });\n          });\n          var lastExistingTarget_1 = targetNodePath.reverse().slice(!targetNode ? 1 : 0).find(function (parentId) {\n            return flattenedNodes.find(function (fNode) {\n              return fNode.id === parentId;\n            });\n          });\n          sourceNode = flattenedNodes.find(function (v) {\n            return v.id === lastExistingSource_1;\n          });\n          targetNode = flattenedNodes.find(function (v) {\n            return v.id === lastExistingTarget_1;\n          });\n          sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes, {\n            v: sourceEdge.source,\n            w: sourceEdge.target\n          });\n        }\n\n        points = sortedEdges.reduce(function (pre, cur) {\n          return __spreadArray(__spreadArray([], pre, true), cur.points.map(function (p) {\n            return __assign(__assign({}, p), {\n              x: p.x + dBegin[0],\n              y: p.y + dBegin[1]\n            });\n          }), true);\n        }, []); // 取消首尾节点\n\n        points = points.slice(1, -1);\n        sourceEdge.controlPoints = points;\n\n        if ((targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === dagre_compound_1.NodeType.META) {\n          // combo 节点控制点\n          var i = combos.findIndex(function (item) {\n            return item.id === (targetNode === null || targetNode === void 0 ? void 0 : targetNode.id);\n          });\n\n          if (!combos[i] || ((_a = combos[i].inEdges) === null || _a === void 0 ? void 0 : _a.some(function (inEdge) {\n            return inEdge.source === sourceNode.id && inEdge.target === targetNode.id;\n          }))) {\n            return;\n          }\n\n          (_b = combos[i].inEdges) === null || _b === void 0 ? void 0 : _b.push({\n            source: sourceNode.id,\n            target: targetNode.id,\n            controlPoints: points\n          });\n        }\n\n        if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === dagre_compound_1.NodeType.META) {\n          var i = combos.findIndex(function (item) {\n            return item.id === (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id);\n          });\n\n          if (!combos[i] || ((_c = combos[i].outEdges) === null || _c === void 0 ? void 0 : _c.some(function (oedge) {\n            return oedge.source === sourceNode.id && oedge.target === targetNode.id;\n          }))) {\n            return;\n          }\n\n          (_d = combos[i].outEdges) === null || _d === void 0 ? void 0 : _d.push({\n            source: sourceNode.id,\n            target: targetNode.id,\n            controlPoints: points\n          });\n        }\n      });\n    }\n  };\n\n  DagreCompoundLayout.prototype.getType = function () {\n    return 'dagreCompound';\n  };\n  /**\n   * 确保布局使用的数据与用户输入数据顺序一致\n   * 通过 layoutOrder 排序 节点 与 边\n   * @param list\n   * @private\n   */\n\n\n  DagreCompoundLayout.prototype.getDataByOrder = function (list) {\n    if (list.every(function (n) {\n      return n.layoutOrder !== undefined;\n    })) {// 所有数据均设置过索引，表示仅布局，数据未变化，无需处理\n    } else {\n      // 首次布局或动态添加删减节点时重新赋值\n      list.forEach(function (n, i) {\n        n.layoutOrder = i;\n      });\n    } // 按照 layoutOrder 排序\n\n\n    return list.sort(function (pre, cur) {\n      return pre.layoutOrder - cur.layoutOrder;\n    });\n  };\n\n  return DagreCompoundLayout;\n}(base_1.Base);\n\nexports.DagreCompoundLayout = DagreCompoundLayout;","map":null,"metadata":{},"sourceType":"script"}