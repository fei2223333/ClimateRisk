{"ast":null,"code":"import { isObject } from './object';\nexport var getEdgeTerminal = function getEdgeTerminal(edge, type) {\n  var terminal = edge[type];\n\n  if (isObject(terminal)) {\n    return terminal.cell;\n  }\n\n  return terminal;\n};\nexport var getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  if (!edges) return degrees;\n  edges.forEach(function (e) {\n    var source = getEdgeTerminal(e, 'source');\n    var target = getEdgeTerminal(e, 'target');\n\n    if (source) {\n      degrees[nodeIdxMap[source]] += 1;\n    }\n\n    if (target) {\n      degrees[nodeIdxMap[target]] += 1;\n    }\n  });\n  return degrees;\n};\nexport var floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var _i = 0; _i < size; _i += 1) {\n      for (var _j = 0; _j < size; _j += 1) {\n        if (dist[_i][_j] > dist[_i][k] + dist[k][_j]) {\n          dist[_i][_j] = dist[_i][k] + dist[k][_j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\nexport var getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n      edges = data.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = getEdgeTerminal(e, 'source');\n      var target = getEdgeTerminal(e, 'target');\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\n\nexport var scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\nvar traverseUp = function traverseUp(data, fn) {\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (!fn(data)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\n\n\nexport var traverseTreeUp = function traverseTreeUp(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};","map":null,"metadata":{},"sourceType":"module"}