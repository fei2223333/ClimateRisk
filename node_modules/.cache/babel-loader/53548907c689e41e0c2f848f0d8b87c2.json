{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MDSLayout = void 0;\n\nvar ml_matrix_1 = require(\"ml-matrix\");\n\nvar util_1 = require(\"../util\");\n\nvar base_1 = require(\"./base\");\n/**\n * mds 布局\n */\n\n\nvar MDSLayout =\n/** @class */\nfunction (_super) {\n  __extends(MDSLayout, _super);\n\n  function MDSLayout(options) {\n    var _this = _super.call(this) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 边长度 */\n\n    _this.linkDistance = 50;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  MDSLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      linkDistance: 50\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  MDSLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes,\n        _a = self.edges,\n        edges = _a === void 0 ? [] : _a;\n    var center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    var linkDistance = self.linkDistance; // the graph-theoretic distance (shortest path distance) matrix\n\n    var adjMatrix = (0, util_1.getAdjMatrix)({\n      nodes: nodes,\n      edges: edges\n    }, false);\n    var distances = (0, util_1.floydWarshall)(adjMatrix);\n    self.handleInfinity(distances); // scale the ideal edge length acoording to linkDistance\n\n    var scaledD = (0, util_1.scaleMatrix)(distances, linkDistance);\n    self.scaledDistances = scaledD; // get positions by MDS\n\n    var positions = self.runMDS();\n    self.positions = positions;\n    positions.forEach(function (p, i) {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  };\n  /**\n   * mds 算法\n   * @return {array} positions 计算后的节点位置数组\n   */\n\n\n  MDSLayout.prototype.runMDS = function () {\n    var self = this;\n    var dimension = 2;\n    var distances = self.scaledDistances; // square distances\n\n    var M = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n    var rowMeans = M.mean(\"row\");\n    var colMeans = M.mean(\"column\");\n    var totalMean = M.mean();\n    M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n    // points from it\n\n    var ret = new ml_matrix_1.SingularValueDecomposition(M);\n    var eigenValues = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();\n    return ret.leftSingularVectors.toJSON().map(function (row) {\n      return ml_matrix_1.Matrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n    });\n  };\n\n  MDSLayout.prototype.handleInfinity = function (distances) {\n    var maxDistance = -999999;\n    distances.forEach(function (row) {\n      row.forEach(function (value) {\n        if (value === Infinity) {\n          return;\n        }\n\n        if (maxDistance < value) {\n          maxDistance = value;\n        }\n      });\n    });\n    distances.forEach(function (row, i) {\n      row.forEach(function (value, j) {\n        if (value === Infinity) {\n          distances[i][j] = maxDistance;\n        }\n      });\n    });\n  };\n\n  MDSLayout.prototype.getType = function () {\n    return \"mds\";\n  };\n\n  return MDSLayout;\n}(base_1.Base);\n\nexports.MDSLayout = MDSLayout;","map":null,"metadata":{},"sourceType":"script"}