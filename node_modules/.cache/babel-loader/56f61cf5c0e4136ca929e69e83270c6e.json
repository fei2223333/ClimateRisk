{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Line } from '../line';\nimport { LineTo } from './lineto';\nimport { Segment } from './segment';\nexport var Close = /*#__PURE__*/function (_Segment) {\n  _inherits(Close, _Segment);\n\n  function Close() {\n    _classCallCheck(this, Close);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Close).apply(this, arguments));\n  }\n\n  _createClass(Close, [{\n    key: \"bbox\",\n    value: function bbox() {\n      return this.line.bbox();\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      return this.line.closestPoint(p);\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      return this.line.closestPointLength(p);\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      return this.line.closestPointNormalizedLength(p);\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      return this.line.closestPointTangent(p);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.line.length();\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var divided = this.line.divideAt(ratio);\n      return [// do not actually cut into the segment, first divided part can stay as Z\n      divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(), new LineTo(divided[1])];\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var divided = this.line.divideAtLength(length);\n      return [divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(), new LineTo(divided[1])];\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      return [];\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      return this.line.pointAt(ratio);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      return this.line.pointAtLength(length);\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      return this.line.tangentAt(ratio);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      return this.line.tangentAtLength(length);\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      if (!this.previousSegment || !this.subpathStartSegment) {\n        return false;\n      }\n\n      return !this.start.equals(this.end);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale() {\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate() {\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate() {\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(s) {\n      return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Close();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.type,\n        start: this.start.toJSON(),\n        end: this.end.toJSON()\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return this.type;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      if (!this.subpathStartSegment) {\n        throw new Error('Missing subpath start segment. (This segment needs a subpath ' + 'start segment (e.g. MoveTo), or segment has not yet been added' + ' to a path.)');\n      }\n\n      return this.subpathStartSegment.end;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'Z';\n    }\n  }, {\n    key: \"line\",\n    get: function get() {\n      return new Line(this.start, this.end);\n    }\n  }]);\n\n  return Close;\n}(Segment);\n\n(function (Close) {\n  function create() {\n    return new Close();\n  }\n\n  Close.create = create;\n})(Close || (Close = {}));","map":null,"metadata":{},"sourceType":"module"}