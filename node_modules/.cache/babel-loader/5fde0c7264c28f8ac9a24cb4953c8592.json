{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // deep first search with both order low for pre, lim for post\n\nvar dfsBothOrder = function dfsBothOrder(g) {\n  var _a;\n\n  var result = {};\n  var lim = 0;\n\n  var dfs = function dfs(v) {\n    var _a;\n\n    var low = lim;\n    (_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.forEach(dfs);\n    result[v] = {\n      low: low,\n      lim: lim++\n    };\n  };\n\n  (_a = g.children()) === null || _a === void 0 ? void 0 : _a.forEach(dfs);\n  return result;\n}; // Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\n\n\nvar findPath = function findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent;\n  var lca; // Traverse up from v to find the LCA\n\n  parent = v;\n\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n\n  lca = parent; // Traverse from w to LCA\n\n  parent = w;\n\n  while (parent && parent !== lca) {\n    wPath.push(parent);\n    parent = g.parent(parent);\n  }\n\n  return {\n    lca: lca,\n    path: vPath.concat(wPath.reverse())\n  };\n};\n\nvar parentDummyChains = function parentDummyChains(g) {\n  var _a;\n\n  var postorderNums = dfsBothOrder(g);\n  (_a = g.graph().dummyChains) === null || _a === void 0 ? void 0 : _a.forEach(function (startV) {\n    var _a, _b;\n\n    var v = startV;\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    if (!edgeObj) return;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while (pathV !== lca && ((_a = g.node(pathV)) === null || _a === void 0 ? void 0 : _a.maxRank) < node.rank) {\n          pathIdx++;\n          pathV = path[pathIdx];\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 && ((_b = g.node(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.minRank) <= node.rank) {\n          pathIdx++;\n        }\n\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n};\n\nexports.default = parentDummyChains;","map":null,"metadata":{},"sourceType":"script"}