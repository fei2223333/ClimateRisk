{"ast":null,"code":"import _defineProperty from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Util } from '../../global';\nimport { Rectangle, Angle } from '../../geometry';\nimport { ObjectExt, StringExt, FunctionExt } from '../../util';\nimport { Cell } from '../../model/cell';\nimport { Collection } from '../../model/collection';\nimport { View } from '../../view/view';\nimport { notify } from '../transform/util';\nimport { Handle } from '../common';\nexport var Selection = /*#__PURE__*/function (_View) {\n  _inherits(Selection, _View);\n\n  function Selection(options) {\n    var _this;\n\n    _classCallCheck(this, Selection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Selection).call(this));\n    _this.options = ObjectExt.merge({}, Private.defaultOptions, options);\n\n    if (_this.options.model) {\n      _this.options.collection = _this.options.model.collection;\n    }\n\n    if (_this.options.collection) {\n      _this.collection = _this.options.collection;\n    } else {\n      _this.collection = new Collection([], {\n        comparator: Private.depthComparator\n      });\n      _this.options.collection = _this.collection;\n    }\n\n    _this.boxCount = 0;\n\n    _this.createContainer();\n\n    _this.initHandles();\n\n    _this.startListening();\n\n    return _this;\n  }\n\n  _createClass(Selection, [{\n    key: \"startListening\",\n    value: function startListening() {\n      var _this$delegateEvents;\n\n      var graph = this.graph;\n      var collection = this.collection;\n      this.delegateEvents((_this$delegateEvents = {}, _defineProperty(_this$delegateEvents, \"mousedown .\".concat(this.boxClassName), 'onSelectionBoxMouseDown'), _defineProperty(_this$delegateEvents, \"touchstart .\".concat(this.boxClassName), 'onSelectionBoxMouseDown'), _this$delegateEvents), true);\n      graph.on('scale', this.onGraphTransformed, this);\n      graph.on('translate', this.onGraphTransformed, this);\n      graph.model.on('updated', this.onModelUpdated, this);\n      collection.on('added', this.onCellAdded, this);\n      collection.on('removed', this.onCellRemoved, this);\n      collection.on('reseted', this.onReseted, this);\n      collection.on('updated', this.onCollectionUpdated, this);\n      collection.on('node:change:position', this.onNodePositionChanged, this);\n      collection.on('cell:changed', this.onCellChanged, this);\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      var graph = this.graph;\n      var collection = this.collection;\n      this.undelegateEvents();\n      graph.off('scale', this.onGraphTransformed, this);\n      graph.off('translate', this.onGraphTransformed, this);\n      graph.model.off('updated', this.onModelUpdated, this);\n      collection.off('added', this.onCellAdded, this);\n      collection.off('removed', this.onCellRemoved, this);\n      collection.off('reseted', this.onReseted, this);\n      collection.off('updated', this.onCollectionUpdated, this);\n      collection.off('node:change:position', this.onNodePositionChanged, this);\n      collection.off('cell:changed', this.onCellChanged, this);\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.stopListening();\n    }\n  }, {\n    key: \"onGraphTransformed\",\n    value: function onGraphTransformed() {\n      this.updateSelectionBoxes({\n        async: false\n      });\n    }\n  }, {\n    key: \"onCellChanged\",\n    value: function onCellChanged() {\n      this.updateSelectionBoxes();\n    }\n  }, {\n    key: \"onNodePositionChanged\",\n    value: function onNodePositionChanged(_ref) {\n      var node = _ref.node,\n          options = _ref.options;\n      var _this$options = this.options,\n          showNodeSelectionBox = _this$options.showNodeSelectionBox,\n          pointerEvents = _this$options.pointerEvents;\n      var ui = options.ui,\n          selection = options.selection;\n      var allowTranslating = !this.translating;\n      /* Scenarios where this method is not called:\n       * 1. ShowNodeSelection is true or ponterEvents is none\n       * 2. Avoid circular calls with the selection tag\n       */\n\n      allowTranslating = allowTranslating && (showNodeSelectionBox !== true || pointerEvents === 'none');\n      allowTranslating = allowTranslating && ui && !selection;\n\n      if (allowTranslating) {\n        this.translating = true;\n        var current = node.position();\n        var previous = node.previous('position');\n        var dx = current.x - previous.x;\n        var dy = current.y - previous.y;\n\n        if (dx !== 0 || dy !== 0) {\n          this.translateSelectedNodes(dx, dy, node, options);\n        }\n\n        this.translating = false;\n      }\n    }\n  }, {\n    key: \"onModelUpdated\",\n    value: function onModelUpdated(_ref2) {\n      var removed = _ref2.removed;\n\n      if (removed && removed.length) {\n        this.unselect(removed);\n      }\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.length <= 0;\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected(cell) {\n      return this.collection.has(cell);\n    }\n  }, {\n    key: \"select\",\n    value: function select(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options.dryrun = true;\n      var items = this.filter(Array.isArray(cells) ? cells : [cells]);\n      this.collection.add(items, options);\n      return this;\n    }\n  }, {\n    key: \"unselect\",\n    value: function unselect(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // dryrun to prevent cell be removed from graph\n      options.dryrun = true;\n      this.collection.remove(Array.isArray(cells) ? cells : [cells], options);\n      return this;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (cells) {\n        if (options.batch) {\n          var filterCells = this.filter(Array.isArray(cells) ? cells : [cells]);\n          this.collection.reset(filterCells, Object.assign(Object.assign({}, options), {\n            ui: true\n          }));\n          return this;\n        }\n\n        var prev = this.cells;\n        var next = this.filter(Array.isArray(cells) ? cells : [cells]);\n        var prevMap = {};\n        var nextMap = {};\n        prev.forEach(function (cell) {\n          return prevMap[cell.id] = cell;\n        });\n        next.forEach(function (cell) {\n          return nextMap[cell.id] = cell;\n        });\n        var added = [];\n        var removed = [];\n        next.forEach(function (cell) {\n          if (!prevMap[cell.id]) {\n            added.push(cell);\n          }\n        });\n        prev.forEach(function (cell) {\n          if (!nextMap[cell.id]) {\n            removed.push(cell);\n          }\n        });\n\n        if (removed.length) {\n          this.unselect(removed, Object.assign(Object.assign({}, options), {\n            ui: true\n          }));\n        }\n\n        if (added.length) {\n          this.select(added, Object.assign(Object.assign({}, options), {\n            ui: true\n          }));\n        }\n\n        if (removed.length === 0 && added.length === 0) {\n          this.updateContainer();\n        }\n\n        return this;\n      }\n\n      return this.clean(options);\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.length) {\n        if (options.batch === false) {\n          this.unselect(this.cells, options);\n        } else {\n          this.collection.reset([], Object.assign(Object.assign({}, options), {\n            ui: true\n          }));\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setFilter\",\n    value: function setFilter(filter) {\n      this.options.filter = filter;\n    }\n  }, {\n    key: \"setContent\",\n    value: function setContent(content) {\n      this.options.content = content;\n    }\n  }, {\n    key: \"startSelecting\",\n    value: function startSelecting(evt) {\n      // Flow: startSelecting => adjustSelection => stopSelecting\n      evt = this.normalizeEvent(evt); // eslint-disable-line\n\n      this.clean();\n      var x;\n      var y;\n      var graphContainer = this.graph.container;\n\n      if (evt.offsetX != null && evt.offsetY != null && graphContainer.contains(evt.target)) {\n        x = evt.offsetX;\n        y = evt.offsetY;\n      } else {\n        var offset = this.$(graphContainer).offset();\n        var scrollLeft = graphContainer.scrollLeft;\n        var scrollTop = graphContainer.scrollTop;\n        x = evt.clientX - offset.left + window.pageXOffset + scrollLeft;\n        y = evt.clientY - offset.top + window.pageYOffset + scrollTop;\n      }\n\n      this.$container.css({\n        top: y,\n        left: x,\n        width: 1,\n        height: 1\n      });\n      this.setEventData(evt, {\n        action: 'selecting',\n        clientX: evt.clientX,\n        clientY: evt.clientY,\n        offsetX: x,\n        offsetY: y,\n        scrollerX: 0,\n        scrollerY: 0\n      });\n      this.delegateDocumentEvents(Private.documentEvents, evt.data);\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(cells) {\n      var _this2 = this;\n\n      var filter = this.options.filter;\n\n      if (Array.isArray(filter)) {\n        return cells.filter(function (cell) {\n          return !filter.includes(cell) && !filter.includes(cell.shape);\n        });\n      }\n\n      if (typeof filter === 'function') {\n        return cells.filter(function (cell) {\n          return FunctionExt.call(filter, _this2.graph, cell);\n        });\n      }\n\n      return cells;\n    }\n  }, {\n    key: \"stopSelecting\",\n    value: function stopSelecting(evt) {\n      var graph = this.graph;\n      var eventData = this.getEventData(evt);\n      var action = eventData.action;\n\n      switch (action) {\n        case 'selecting':\n          {\n            var width = this.$container.width();\n            var height = this.$container.height();\n            var offset = this.$container.offset();\n            var origin = graph.pageToLocal(offset.left, offset.top);\n            var scale = graph.transform.getScale();\n            width /= scale.sx;\n            height /= scale.sy;\n            var rect = new Rectangle(origin.x, origin.y, width, height);\n            var cells = this.getCellViewsInArea(rect).map(function (view) {\n              return view.cell;\n            });\n            this.reset(cells, {\n              batch: true\n            });\n            this.hideRubberband();\n            break;\n          }\n\n        case 'translating':\n          {\n            var client = graph.snapToGrid(evt.clientX, evt.clientY);\n\n            if (!this.options.following) {\n              var data = eventData;\n              this.updateSelectedNodesPosition({\n                dx: data.clientX - data.originX,\n                dy: data.clientY - data.originY\n              });\n            }\n\n            this.graph.model.stopBatch('move-selection');\n            this.notifyBoxEvent('box:mouseup', evt, client.x, client.y);\n            break;\n          }\n\n        default:\n          {\n            this.clean();\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(evt) {\n      var action = this.getEventData(evt).action;\n\n      if (action) {\n        this.stopSelecting(evt);\n        this.undelegateDocumentEvents();\n      }\n    }\n  }, {\n    key: \"onSelectionBoxMouseDown\",\n    value: function onSelectionBoxMouseDown(evt) {\n      if (!this.options.following) {\n        evt.stopPropagation();\n      }\n\n      var e = this.normalizeEvent(evt);\n\n      if (this.options.movable) {\n        this.startTranslating(e);\n      }\n\n      var activeView = this.getCellViewFromElem(e.target);\n      this.setEventData(e, {\n        activeView: activeView\n      });\n      var client = this.graph.snapToGrid(e.clientX, e.clientY);\n      this.notifyBoxEvent('box:mousedown', e, client.x, client.y);\n      this.delegateDocumentEvents(Private.documentEvents, e.data);\n    }\n  }, {\n    key: \"startTranslating\",\n    value: function startTranslating(evt) {\n      this.graph.model.startBatch('move-selection');\n      var client = this.graph.snapToGrid(evt.clientX, evt.clientY);\n      this.setEventData(evt, {\n        action: 'translating',\n        clientX: client.x,\n        clientY: client.y,\n        originX: client.x,\n        originY: client.y\n      });\n    }\n  }, {\n    key: \"getSelectionOffset\",\n    value: function getSelectionOffset(client, data) {\n      var dx = client.x - data.clientX;\n      var dy = client.y - data.clientY;\n      var restrict = this.graph.hook.getRestrictArea();\n\n      if (restrict) {\n        var cells = this.collection.toArray();\n        var totalBBox = Cell.getCellsBBox(cells, {\n          deep: true\n        }) || Rectangle.create();\n        var minDx = restrict.x - totalBBox.x;\n        var minDy = restrict.y - totalBBox.y;\n        var maxDx = restrict.x + restrict.width - (totalBBox.x + totalBBox.width);\n        var maxDy = restrict.y + restrict.height - (totalBBox.y + totalBBox.height);\n\n        if (dx < minDx) {\n          dx = minDx;\n        }\n\n        if (dy < minDy) {\n          dy = minDy;\n        }\n\n        if (maxDx < dx) {\n          dx = maxDx;\n        }\n\n        if (maxDy < dy) {\n          dy = maxDy;\n        }\n\n        if (!this.options.following) {\n          var offsetX = client.x - data.originX;\n          var offsetY = client.y - data.originY;\n          dx = offsetX <= minDx || offsetX >= maxDx ? 0 : dx;\n          dy = offsetY <= minDy || offsetY >= maxDy ? 0 : dy;\n        }\n      }\n\n      return {\n        dx: dx,\n        dy: dy\n      };\n    }\n  }, {\n    key: \"updateSelectedNodesPosition\",\n    value: function updateSelectedNodesPosition(offset) {\n      var dx = offset.dx,\n          dy = offset.dy;\n\n      if (dx || dy) {\n        if (this.translateSelectedNodes(dx, dy), this.boxesUpdated) {\n          if (this.collection.length > 1) {\n            this.updateSelectionBoxes();\n          }\n        } else {\n          var scale = this.graph.transform.getScale();\n          this.$boxes.add(this.$selectionContainer).css({\n            left: \"+=\".concat(dx * scale.sx),\n            top: \"+=\".concat(dy * scale.sy)\n          });\n        }\n      }\n    }\n  }, {\n    key: \"autoScrollGraph\",\n    value: function autoScrollGraph(x, y) {\n      var scroller = this.graph.scroller.widget;\n\n      if (scroller) {\n        return scroller.autoScroll(x, y);\n      }\n\n      return {\n        scrollerX: 0,\n        scrollerY: 0\n      };\n    }\n  }, {\n    key: \"adjustSelection\",\n    value: function adjustSelection(evt) {\n      var e = this.normalizeEvent(evt);\n      var eventData = this.getEventData(e);\n      var action = eventData.action;\n\n      switch (action) {\n        case 'selecting':\n          {\n            var data = eventData;\n\n            if (data.moving !== true) {\n              this.$container.appendTo(this.graph.container);\n              this.showRubberband();\n              data.moving = true;\n            }\n\n            var _this$autoScrollGraph = this.autoScrollGraph(e.clientX, e.clientY),\n                scrollerX = _this$autoScrollGraph.scrollerX,\n                scrollerY = _this$autoScrollGraph.scrollerY;\n\n            data.scrollerX += scrollerX;\n            data.scrollerY += scrollerY;\n            var dx = e.clientX - data.clientX + data.scrollerX;\n            var dy = e.clientY - data.clientY + data.scrollerY;\n            var left = parseInt(this.$container.css('left'), 10);\n            var top = parseInt(this.$container.css('top'), 10);\n            this.$container.css({\n              left: dx < 0 ? data.offsetX + dx : left,\n              top: dy < 0 ? data.offsetY + dy : top,\n              width: Math.abs(dx),\n              height: Math.abs(dy)\n            });\n            break;\n          }\n\n        case 'translating':\n          {\n            var client = this.graph.snapToGrid(e.clientX, e.clientY);\n            var _data = eventData;\n            var offset = this.getSelectionOffset(client, _data);\n\n            if (this.options.following) {\n              this.updateSelectedNodesPosition(offset);\n            } else {\n              this.updateContainerPosition(offset);\n            }\n\n            if (offset.dx) {\n              _data.clientX = client.x;\n            }\n\n            if (offset.dy) {\n              _data.clientY = client.y;\n            }\n\n            this.notifyBoxEvent('box:mousemove', evt, client.x, client.y);\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      this.boxesUpdated = false;\n    }\n  }, {\n    key: \"translateSelectedNodes\",\n    value: function translateSelectedNodes(dx, dy, exclude, otherOptions) {\n      var _this3 = this;\n\n      var map = {};\n      var excluded = [];\n\n      if (exclude) {\n        map[exclude.id] = true;\n      }\n\n      this.collection.toArray().forEach(function (cell) {\n        cell.getDescendants({\n          deep: true\n        }).forEach(function (child) {\n          map[child.id] = true;\n        });\n      });\n\n      if (otherOptions && otherOptions.translateBy) {\n        var currentCell = this.graph.getCellById(otherOptions.translateBy);\n\n        if (currentCell) {\n          map[currentCell.id] = true;\n          currentCell.getDescendants({\n            deep: true\n          }).forEach(function (child) {\n            map[child.id] = true;\n          });\n          excluded.push(currentCell);\n        }\n      }\n\n      this.collection.toArray().forEach(function (cell) {\n        if (!map[cell.id]) {\n          var options = Object.assign(Object.assign({}, otherOptions), {\n            selection: _this3.cid,\n            exclude: excluded\n          });\n          cell.translate(dx, dy, options);\n\n          _this3.graph.model.getConnectedEdges(cell).forEach(function (edge) {\n            if (!map[edge.id]) {\n              edge.translate(dx, dy, options);\n              map[edge.id] = true;\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getCellViewsInArea\",\n    value: function getCellViewsInArea(rect) {\n      var graph = this.graph;\n      var options = {\n        strict: this.options.strict\n      };\n      var views = [];\n\n      if (this.options.rubberNode) {\n        if (this.options.useCellGeometry) {\n          views = views.concat(graph.model.getNodesInArea(rect, options).map(function (node) {\n            return graph.renderer.findViewByCell(node);\n          }).filter(function (view) {\n            return view != null;\n          }));\n        } else {\n          views = views.concat(graph.renderer.findViewsInArea(rect, options));\n        }\n      }\n\n      if (this.options.rubberEdge) {\n        if (this.options.useCellGeometry) {\n          views = views.concat(graph.model.getEdgesInArea(rect, options).map(function (edge) {\n            return graph.renderer.findViewByCell(edge);\n          }).filter(function (view) {\n            return view != null;\n          }));\n        } else {\n          views = views.concat(graph.renderer.findEdgeViewsInArea(rect, options));\n        }\n      }\n\n      return views;\n    }\n  }, {\n    key: \"notifyBoxEvent\",\n    value: function notifyBoxEvent(name, e, x, y) {\n      var data = this.getEventData(e);\n      var view = data.activeView;\n      this.trigger(name, {\n        e: e,\n        view: view,\n        x: x,\n        y: y,\n        cell: view.cell\n      });\n    }\n  }, {\n    key: \"getSelectedClassName\",\n    value: function getSelectedClassName(cell) {\n      return this.prefixClassName(\"\".concat(cell.isNode() ? 'node' : 'edge', \"-selected\"));\n    }\n  }, {\n    key: \"addCellSelectedClassName\",\n    value: function addCellSelectedClassName(cell) {\n      var view = this.graph.renderer.findViewByCell(cell);\n\n      if (view) {\n        view.addClass(this.getSelectedClassName(cell));\n      }\n    }\n  }, {\n    key: \"removeCellUnSelectedClassName\",\n    value: function removeCellUnSelectedClassName(cell) {\n      var view = this.graph.renderer.findViewByCell(cell);\n\n      if (view) {\n        view.removeClass(this.getSelectedClassName(cell));\n      }\n    }\n  }, {\n    key: \"destroySelectionBox\",\n    value: function destroySelectionBox(cell) {\n      this.removeCellUnSelectedClassName(cell);\n\n      if (this.canShowSelectionBox(cell)) {\n        this.$container.find(\"[data-cell-id=\\\"\".concat(cell.id, \"\\\"]\")).remove();\n\n        if (this.$boxes.length === 0) {\n          this.hide();\n        }\n\n        this.boxCount = Math.max(0, this.boxCount - 1);\n      }\n    }\n  }, {\n    key: \"destroyAllSelectionBoxes\",\n    value: function destroyAllSelectionBoxes(cells) {\n      var _this4 = this;\n\n      cells.forEach(function (cell) {\n        return _this4.removeCellUnSelectedClassName(cell);\n      });\n      this.hide();\n      this.$boxes.remove();\n      this.boxCount = 0;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband)).removeClass(this.prefixClassName(Private.classNames.selected));\n    }\n  }, {\n    key: \"showRubberband\",\n    value: function showRubberband() {\n      this.$container.addClass(this.prefixClassName(Private.classNames.rubberband));\n    }\n  }, {\n    key: \"hideRubberband\",\n    value: function hideRubberband() {\n      this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband));\n    }\n  }, {\n    key: \"showSelected\",\n    value: function showSelected() {\n      this.$container.removeAttr('style').addClass(this.prefixClassName(Private.classNames.selected));\n    }\n  }, {\n    key: \"createContainer\",\n    value: function createContainer() {\n      this.container = document.createElement('div');\n      this.$container = this.$(this.container);\n      this.$container.addClass(this.prefixClassName(Private.classNames.root));\n\n      if (this.options.className) {\n        this.$container.addClass(this.options.className);\n      }\n\n      this.$selectionContainer = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.inner));\n      this.$selectionContent = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.content));\n      this.$selectionContainer.append(this.$selectionContent);\n      this.$selectionContainer.attr('data-selection-length', this.collection.length);\n      this.$container.prepend(this.$selectionContainer);\n      this.$handleContainer = this.$selectionContainer;\n    }\n  }, {\n    key: \"updateContainerPosition\",\n    value: function updateContainerPosition(offset) {\n      if (offset.dx || offset.dy) {\n        this.$selectionContainer.css({\n          left: \"+=\".concat(offset.dx),\n          top: \"+=\".concat(offset.dy)\n        });\n      }\n    }\n  }, {\n    key: \"updateContainer\",\n    value: function updateContainer() {\n      var _this5 = this;\n\n      var origin = {\n        x: Infinity,\n        y: Infinity\n      };\n      var corner = {\n        x: 0,\n        y: 0\n      };\n      var cells = this.collection.toArray().filter(function (cell) {\n        return _this5.canShowSelectionBox(cell);\n      });\n      cells.forEach(function (cell) {\n        var view = _this5.graph.renderer.findViewByCell(cell);\n\n        if (view) {\n          var bbox = view.getBBox({\n            useCellGeometry: _this5.options.useCellGeometry\n          });\n          origin.x = Math.min(origin.x, bbox.x);\n          origin.y = Math.min(origin.y, bbox.y);\n          corner.x = Math.max(corner.x, bbox.x + bbox.width);\n          corner.y = Math.max(corner.y, bbox.y + bbox.height);\n        }\n      });\n      this.$selectionContainer.css({\n        position: 'absolute',\n        pointerEvents: 'none',\n        left: origin.x,\n        top: origin.y,\n        width: corner.x - origin.x,\n        height: corner.y - origin.y\n      }).attr('data-selection-length', this.collection.length);\n      var boxContent = this.options.content;\n\n      if (boxContent) {\n        if (typeof boxContent === 'function') {\n          var content = FunctionExt.call(boxContent, this.graph, this, this.$selectionContent[0]);\n\n          if (content) {\n            this.$selectionContent.html(content);\n          }\n        } else {\n          this.$selectionContent.html(boxContent);\n        }\n      }\n\n      if (this.collection.length > 0 && !this.container.parentNode) {\n        this.$container.appendTo(this.graph.container);\n      } else if (this.collection.length <= 0 && this.container.parentNode) {\n        this.container.parentNode.removeChild(this.container);\n      }\n    }\n  }, {\n    key: \"canShowSelectionBox\",\n    value: function canShowSelectionBox(cell) {\n      return cell.isNode() && this.options.showNodeSelectionBox === true || cell.isEdge() && this.options.showEdgeSelectionBox === true;\n    }\n  }, {\n    key: \"createSelectionBox\",\n    value: function createSelectionBox(cell) {\n      this.addCellSelectedClassName(cell);\n\n      if (this.canShowSelectionBox(cell)) {\n        var view = this.graph.renderer.findViewByCell(cell);\n\n        if (view) {\n          var bbox = view.getBBox({\n            useCellGeometry: this.options.useCellGeometry\n          });\n          var className = this.boxClassName;\n          this.$('<div/>').addClass(className).addClass(\"\".concat(className, \"-\").concat(cell.isNode() ? 'node' : 'edge')).attr('data-cell-id', cell.id).css({\n            position: 'absolute',\n            left: bbox.x,\n            top: bbox.y,\n            width: bbox.width,\n            height: bbox.height,\n            pointerEvents: this.options.pointerEvents || 'auto'\n          }).appendTo(this.container);\n          this.showSelected();\n          this.boxCount += 1;\n        }\n      }\n    }\n  }, {\n    key: \"updateSelectionBoxes\",\n    value: function updateSelectionBoxes() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.collection.length > 0) {\n        this.boxesUpdated = true;\n        this.graph.renderer.requestViewUpdate(this, 1, 2, options);\n      }\n    }\n  }, {\n    key: \"confirmUpdate\",\n    value: function confirmUpdate() {\n      var _this6 = this;\n\n      if (this.boxCount) {\n        this.hide();\n        this.$boxes.each(function (_, elem) {\n          var cellId = _this6.$(elem).remove().attr('data-cell-id');\n\n          var cell = _this6.collection.get(cellId);\n\n          if (cell) {\n            _this6.createSelectionBox(cell);\n          }\n        });\n        this.updateContainer();\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"getCellViewFromElem\",\n    value: function getCellViewFromElem(elem) {\n      var id = elem.getAttribute('data-cell-id');\n\n      if (id) {\n        var cell = this.collection.get(id);\n\n        if (cell) {\n          return this.graph.renderer.findViewByCell(cell);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"onCellRemoved\",\n    value: function onCellRemoved(_ref3) {\n      var cell = _ref3.cell;\n      this.destroySelectionBox(cell);\n      this.updateContainer();\n    }\n  }, {\n    key: \"onReseted\",\n    value: function onReseted(_ref4) {\n      var _this7 = this;\n\n      var previous = _ref4.previous,\n          current = _ref4.current;\n      this.destroyAllSelectionBoxes(previous);\n      current.forEach(function (cell) {\n        _this7.listenCellRemoveEvent(cell);\n\n        _this7.createSelectionBox(cell);\n      });\n      this.updateContainer();\n    }\n  }, {\n    key: \"onCellAdded\",\n    value: function onCellAdded(_ref5) {\n      var cell = _ref5.cell;\n      // The collection do not known the cell was removed when cell was\n      // removed by interaction(such as, by \"delete\" shortcut), so we should\n      // manually listen to cell's remove evnet.\n      this.listenCellRemoveEvent(cell);\n      this.createSelectionBox(cell);\n      this.updateContainer();\n    }\n  }, {\n    key: \"listenCellRemoveEvent\",\n    value: function listenCellRemoveEvent(cell) {\n      cell.off('removed', this.onCellRemoved, this);\n      cell.on('removed', this.onCellRemoved, this);\n    }\n  }, {\n    key: \"onCollectionUpdated\",\n    value: function onCollectionUpdated(_ref6) {\n      var _this8 = this;\n\n      var added = _ref6.added,\n          removed = _ref6.removed,\n          options = _ref6.options;\n      added.forEach(function (cell) {\n        _this8.trigger('cell:selected', {\n          cell: cell,\n          options: options\n        });\n\n        _this8.graph.trigger('cell:selected', {\n          cell: cell,\n          options: options\n        });\n\n        if (cell.isNode()) {\n          _this8.trigger('node:selected', {\n            cell: cell,\n            options: options,\n            node: cell\n          });\n\n          _this8.graph.trigger('node:selected', {\n            cell: cell,\n            options: options,\n            node: cell\n          });\n        } else if (cell.isEdge()) {\n          _this8.trigger('edge:selected', {\n            cell: cell,\n            options: options,\n            edge: cell\n          });\n\n          _this8.graph.trigger('edge:selected', {\n            cell: cell,\n            options: options,\n            edge: cell\n          });\n        }\n      });\n      removed.forEach(function (cell) {\n        _this8.trigger('cell:unselected', {\n          cell: cell,\n          options: options\n        });\n\n        _this8.graph.trigger('cell:unselected', {\n          cell: cell,\n          options: options\n        });\n\n        if (cell.isNode()) {\n          _this8.trigger('node:unselected', {\n            cell: cell,\n            options: options,\n            node: cell\n          });\n\n          _this8.graph.trigger('node:unselected', {\n            cell: cell,\n            options: options,\n            node: cell\n          });\n        } else if (cell.isEdge()) {\n          _this8.trigger('edge:unselected', {\n            cell: cell,\n            options: options,\n            edge: cell\n          });\n\n          _this8.graph.trigger('edge:unselected', {\n            cell: cell,\n            options: options,\n            edge: cell\n          });\n        }\n      });\n      var args = {\n        added: added,\n        removed: removed,\n        options: options,\n        selected: this.cells\n      };\n      this.trigger('selection:changed', args);\n      this.graph.trigger('selection:changed', args);\n    } // #region handle\n\n  }, {\n    key: \"deleteSelectedCells\",\n    value: function deleteSelectedCells() {\n      var cells = this.collection.toArray();\n      this.clean();\n      this.graph.model.removeCells(cells, {\n        selection: this.cid\n      });\n    }\n  }, {\n    key: \"startRotate\",\n    value: function startRotate(_ref7) {\n      var e = _ref7.e;\n      var cells = this.collection.toArray();\n      var center = Cell.getCellsBBox(cells).getCenter();\n      var client = this.graph.snapToGrid(e.clientX, e.clientY);\n      var angles = cells.reduce(function (memo, cell) {\n        memo[cell.id] = Angle.normalize(cell.getAngle());\n        return memo;\n      }, {});\n      this.setEventData(e, {\n        center: center,\n        angles: angles,\n        start: client.theta(center)\n      });\n    }\n  }, {\n    key: \"doRotate\",\n    value: function doRotate(_ref8) {\n      var _this9 = this;\n\n      var e = _ref8.e;\n      var data = this.getEventData(e);\n      var grid = this.graph.options.rotating.grid;\n      var gridSize = typeof grid === 'function' ? FunctionExt.call(grid, this.graph, null) : grid;\n      var client = this.graph.snapToGrid(e.clientX, e.clientY);\n      var delta = data.start - client.theta(data.center);\n\n      if (!data.rotated) {\n        data.rotated = true;\n      }\n\n      if (Math.abs(delta) > 0.001) {\n        this.collection.toArray().forEach(function (node) {\n          var angle = Util.snapToGrid(data.angles[node.id] + delta, gridSize || 15);\n          node.rotate(angle, {\n            absolute: true,\n            center: data.center,\n            selection: _this9.cid\n          });\n        });\n        this.updateSelectionBoxes();\n      }\n    }\n  }, {\n    key: \"stopRotate\",\n    value: function stopRotate(_ref9) {\n      var _this10 = this;\n\n      var e = _ref9.e;\n      var data = this.getEventData(e);\n\n      if (data.rotated) {\n        data.rotated = false;\n        this.collection.toArray().forEach(function (node) {\n          notify('node:rotated', e, _this10.graph.findViewByCell(node));\n        });\n      }\n    }\n  }, {\n    key: \"startResize\",\n    value: function startResize(_ref10) {\n      var e = _ref10.e;\n      var gridSize = this.graph.getGridSize();\n      var cells = this.collection.toArray();\n      var bbox = Cell.getCellsBBox(cells);\n      var bboxes = cells.map(function (cell) {\n        return cell.getBBox();\n      });\n      var maxWidth = bboxes.reduce(function (maxWidth, bbox) {\n        return bbox.width < maxWidth ? bbox.width : maxWidth;\n      }, Infinity);\n      var maxHeight = bboxes.reduce(function (maxHeight, bbox) {\n        return bbox.height < maxHeight ? bbox.height : maxHeight;\n      }, Infinity);\n      this.setEventData(e, {\n        bbox: bbox,\n        cells: this.graph.model.getSubGraph(cells),\n        minWidth: gridSize * bbox.width / maxWidth,\n        minHeight: gridSize * bbox.height / maxHeight\n      });\n    }\n  }, {\n    key: \"doResize\",\n    value: function doResize(_ref11) {\n      var e = _ref11.e,\n          dx = _ref11.dx,\n          dy = _ref11.dy;\n      var data = this.eventData(e);\n      var bbox = data.bbox;\n      var width = bbox.width;\n      var height = bbox.height;\n      var newWidth = Math.max(width + dx, data.minWidth);\n      var newHeight = Math.max(height + dy, data.minHeight);\n\n      if (!data.resized) {\n        data.resized = true;\n      }\n\n      if (Math.abs(width - newWidth) > 0.001 || Math.abs(height - newHeight) > 0.001) {\n        this.graph.model.resizeCells(newWidth, newHeight, data.cells, {\n          selection: this.cid\n        });\n        bbox.width = newWidth;\n        bbox.height = newHeight;\n        this.updateSelectionBoxes();\n      }\n    }\n  }, {\n    key: \"stopResize\",\n    value: function stopResize(_ref12) {\n      var _this11 = this;\n\n      var e = _ref12.e;\n      var data = this.eventData(e);\n\n      if (data.resized) {\n        data.resized = false;\n        this.collection.toArray().forEach(function (node) {\n          notify('node:resized', e, _this11.graph.findViewByCell(node));\n        });\n      }\n    } // #endregion\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.clean();\n      this.remove();\n    }\n  }, {\n    key: \"graph\",\n    get: function get() {\n      return this.options.graph;\n    }\n  }, {\n    key: \"boxClassName\",\n    get: function get() {\n      return this.prefixClassName(Private.classNames.box);\n    }\n  }, {\n    key: \"$boxes\",\n    get: function get() {\n      return this.$container.children(\".\".concat(this.boxClassName));\n    }\n  }, {\n    key: \"handleOptions\",\n    get: function get() {\n      return this.options;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.collection.length;\n    }\n  }, {\n    key: \"cells\",\n    get: function get() {\n      return this.collection.toArray();\n    }\n  }]);\n\n  return Selection;\n}(View);\n\n__decorate([View.dispose()], Selection.prototype, \"dispose\", null);\n\nObjectExt.applyMixins(Selection, Handle); // private\n// -------\n\nvar Private;\n\n(function (Private) {\n  var base = 'widget-selection';\n  Private.classNames = {\n    root: base,\n    inner: \"\".concat(base, \"-inner\"),\n    box: \"\".concat(base, \"-box\"),\n    content: \"\".concat(base, \"-content\"),\n    rubberband: \"\".concat(base, \"-rubberband\"),\n    selected: \"\".concat(base, \"-selected\")\n  };\n  Private.documentEvents = {\n    mousemove: 'adjustSelection',\n    touchmove: 'adjustSelection',\n    mouseup: 'onMouseUp',\n    touchend: 'onMouseUp',\n    touchcancel: 'onMouseUp'\n  };\n  Private.defaultOptions = {\n    movable: true,\n    following: true,\n    strict: false,\n    useCellGeometry: false,\n    content: function content(selection) {\n      return StringExt.template('<%= length %> node<%= length > 1 ? \"s\":\"\" %> selected.')({\n        length: selection.length\n      });\n    },\n    handles: [{\n      name: 'remove',\n      position: 'nw',\n      events: {\n        mousedown: 'deleteSelectedCells'\n      }\n    }, {\n      name: 'rotate',\n      position: 'sw',\n      events: {\n        mousedown: 'startRotate',\n        mousemove: 'doRotate',\n        mouseup: 'stopRotate'\n      }\n    }, {\n      name: 'resize',\n      position: 'se',\n      events: {\n        mousedown: 'startResize',\n        mousemove: 'doResize',\n        mouseup: 'stopResize'\n      }\n    }]\n  };\n\n  function depthComparator(cell) {\n    return cell.getAncestors().length;\n  }\n\n  Private.depthComparator = depthComparator;\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}