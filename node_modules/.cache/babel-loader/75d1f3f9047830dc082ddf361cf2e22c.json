{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Base } from \"../base\";\nimport { getEdgeTerminal, isArray, isNumber, isObject } from \"../../util\";\nimport Body from './body';\nimport Quad from './quad';\nimport QuadTree from './quadTree';\nexport var ForceAtlas2Layout = /*#__PURE__*/function (_Base) {\n  _inherits(ForceAtlas2Layout, _Base);\n\n  function ForceAtlas2Layout(options) {\n    var _this;\n\n    _classCallCheck(this, ForceAtlas2Layout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ForceAtlas2Layout).call(this));\n    /** 布局中心 */\n\n    _this.center = [0, 0];\n    /** 宽度 */\n\n    _this.width = 300;\n    /** 高度 */\n\n    _this.height = 300;\n    _this.nodes = [];\n    _this.edges = [];\n    /**\n     * the parameter for repulsive forces,\n     * it will scale the layout but won't change the layout\n     * larger the kr, looser the layout\n     * @type  {number}\n     */\n\n    _this.kr = 5;\n    /**\n     * the parameter for gravity forces\n     * @type  {number}\n     */\n\n    _this.kg = 1;\n    /**\n     * modes:\n     * 'normal' for normal using\n     * 'linlog' for compact clusters.\n     * @type  {string}\n     */\n\n    _this.mode = 'normal';\n    /**\n     * whether preventing the node overlapping\n     * @type  {boolean}\n     */\n\n    _this.preventOverlap = false;\n    /**\n     * whether active the dissuade hub mode\n     * true: grant authorities (nodes with a high indegree)\n     * a more central position than hubs (nodes with a high outdegree)\n     * @type  {boolean}\n     */\n\n    _this.dissuadeHubs = false;\n    /**\n     * whether active the barnes hut optimization on computing repulsive forces\n     * @type  {boolean}\n     */\n\n    _this.barnesHut = undefined;\n    /**\n     * the max iteration number\n     * @type  {number}\n     */\n\n    _this.maxIteration = 0;\n    /**\n     * control the global velocity\n     * defualt: 0.1(gephi)\n     * @type  {number}\n     */\n\n    _this.ks = 0.1;\n    /**\n     * the max global velocity\n     * @type  {number}\n     */\n\n    _this.ksmax = 10;\n    /**\n     * the tolerance for the global swinging\n     * @type  {number}\n     */\n\n    _this.tao = 0.1;\n    /**\n     * the function of layout complete listener, display the legend and minimap after layout\n     * @type  {function}\n     */\n\n    _this.onLayoutEnd = function () {};\n    /**\n     * activate prune or not.\n     * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n     * if prune === '', it will be activated when the nodes number > 100\n     * note that it will reduce the quality of the layout\n     * @type  {boolean}\n     */\n\n\n    _this.prune = undefined;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(ForceAtlas2Layout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {};\n    } // execute the layout\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes,\n          onLayoutEnd = self.onLayoutEnd,\n          prune = self.prune;\n      var maxIteration = self.maxIteration;\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      } // the whidth of each nodes\n\n\n      var sizes = [];\n      var nodeNum = nodes.length;\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        var node = nodes[i];\n        var nodeWidth = 10;\n        var nodeHeight = 10;\n\n        if (isNumber(node.size)) {\n          nodeWidth = node.size;\n          nodeHeight = node.size;\n        }\n\n        if (isArray(node.size)) {\n          if (!isNaN(node.size[0])) nodeWidth = node.size[0];\n          if (!isNaN(node.size[1])) nodeHeight = node.size[1];\n        } else if (isObject(node.size)) {\n          nodeWidth = node.size.width;\n          nodeHeight = node.size.height;\n        }\n\n        if (self.getWidth && !isNaN(self.getWidth(node))) nodeHeight = self.getWidth(node);\n        if (self.getHeight && !isNaN(self.getHeight(node))) nodeWidth = self.getHeight(node);\n        var maxSize = Math.max(nodeWidth, nodeHeight);\n        sizes.push(maxSize);\n      }\n\n      if (self.barnesHut === undefined && nodeNum > 250) self.barnesHut = true;\n      if (self.prune === undefined && nodeNum > 100) self.prune = true;\n\n      if (this.maxIteration === 0 && !self.prune) {\n        maxIteration = 250;\n        if (nodeNum <= 200 && nodeNum > 100) maxIteration = 1000;else if (nodeNum > 200) maxIteration = 1200;\n        this.maxIteration = maxIteration;\n      } else if (this.maxIteration === 0 && prune) {\n        maxIteration = 100;\n        if (nodeNum <= 200 && nodeNum > 100) maxIteration = 500;else if (nodeNum > 200) maxIteration = 950;\n        this.maxIteration = maxIteration;\n      }\n\n      if (!self.kr) {\n        self.kr = 50;\n        if (nodeNum > 100 && nodeNum <= 500) self.kr = 20;else if (nodeNum > 500) self.kr = 1;\n      }\n\n      if (!self.kg) {\n        self.kg = 20;\n        if (nodeNum > 100 && nodeNum <= 500) self.kg = 10;else if (nodeNum > 500) self.kg = 1;\n      }\n\n      this.nodes = self.updateNodesByForces(sizes);\n      onLayoutEnd();\n    }\n  }, {\n    key: \"updateNodesByForces\",\n    value: function updateNodesByForces(sizes) {\n      var self = this;\n      var edges = self.edges,\n          maxIteration = self.maxIteration;\n      var nodes = self.nodes;\n      var nonLoopEdges = edges.filter(function (edge) {\n        var source = getEdgeTerminal(edge, 'source');\n        var target = getEdgeTerminal(edge, 'target');\n        return source !== target;\n      });\n      var size = nodes.length;\n      var esize = nonLoopEdges.length;\n      var degrees = [];\n      var idMap = {};\n      var edgeEndsIdMap = {}; // tslint:disable-next-line\n\n      var Es = [];\n\n      for (var i = 0; i < size; i += 1) {\n        idMap[nodes[i].id] = i;\n        degrees[i] = 0;\n\n        if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n          nodes[i].x = Math.random() * 1000;\n        }\n\n        if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n          nodes[i].y = Math.random() * 1000;\n        }\n\n        Es.push({\n          x: nodes[i].x,\n          y: nodes[i].y\n        });\n      }\n\n      for (var _i = 0; _i < esize; _i += 1) {\n        var node1 = void 0;\n        var node2 = void 0;\n        var sIdx = 0;\n        var tIdx = 0;\n\n        for (var j = 0; j < size; j += 1) {\n          var source = getEdgeTerminal(nonLoopEdges[_i], 'source');\n          var target = getEdgeTerminal(nonLoopEdges[_i], 'target');\n\n          if (nodes[j].id === source) {\n            node1 = nodes[j];\n            sIdx = j;\n          } else if (nodes[j].id === target) {\n            node2 = nodes[j];\n            tIdx = j;\n          }\n\n          edgeEndsIdMap[_i] = {\n            sourceIdx: sIdx,\n            targetIdx: tIdx\n          };\n        }\n\n        if (node1) degrees[idMap[node1.id]] += 1;\n        if (node2) degrees[idMap[node2.id]] += 1;\n      }\n\n      var iteration = maxIteration;\n      nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes); // if prune, place the leaves around their parents, and then re-layout for several iterations.\n\n      if (self.prune) {\n        for (var _j = 0; _j < esize; _j += 1) {\n          if (degrees[edgeEndsIdMap[_j].sourceIdx] <= 1) {\n            nodes[edgeEndsIdMap[_j].sourceIdx].x = nodes[edgeEndsIdMap[_j].targetIdx].x;\n            nodes[edgeEndsIdMap[_j].sourceIdx].y = nodes[edgeEndsIdMap[_j].targetIdx].y;\n          } else if (degrees[edgeEndsIdMap[_j].targetIdx] <= 1) {\n            nodes[edgeEndsIdMap[_j].targetIdx].x = nodes[edgeEndsIdMap[_j].sourceIdx].x;\n            nodes[edgeEndsIdMap[_j].targetIdx].y = nodes[edgeEndsIdMap[_j].sourceIdx].y;\n          }\n        }\n\n        self.prune = false;\n        self.barnesHut = false;\n        iteration = 100;\n        nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"iterate\",\n    value: function iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {\n      var self = this;\n      var nodes = self.nodes;\n      var kr = self.kr,\n          preventOverlap = self.preventOverlap;\n      var barnesHut = self.barnesHut;\n      var nodeNum = nodes.length;\n      var sg = 0;\n      var krPrime = 100;\n      var iter = iteration;\n      var prevoIter = 50;\n      var forces = [];\n      var preForces = [];\n      var bodies = [];\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        forces[2 * i] = 0;\n        forces[2 * i + 1] = 0;\n\n        if (barnesHut) {\n          var params = {\n            id: i,\n            rx: nodes[i].x,\n            ry: nodes[i].y,\n            mass: 1,\n            g: kr,\n            degree: degrees[i]\n          };\n          bodies[i] = new Body(params);\n        }\n      }\n\n      while (iter > 0) {\n        for (var _i2 = 0; _i2 < nodeNum; _i2 += 1) {\n          preForces[2 * _i2] = forces[2 * _i2];\n          preForces[2 * _i2 + 1] = forces[2 * _i2 + 1];\n          forces[2 * _i2] = 0;\n          forces[2 * _i2 + 1] = 0;\n        } // attractive forces, existing on every actual edge\n\n\n        forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces); // repulsive forces and Gravity, existing on every node pair\n        // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n\n        if (barnesHut && (preventOverlap && iter > prevoIter || !preventOverlap)) {\n          forces = this.getOptRepGraForces(forces, bodies, degrees);\n        } else {\n          forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n        } // update the positions\n\n\n        var res = this.updatePos(forces, preForces, sg, degrees);\n        nodes = res.nodes;\n        sg = res.sg;\n        iter--;\n        if (self.tick) self.tick();\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"getAttrForces\",\n    value: function getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {\n      var self = this;\n      var nodes = self.nodes,\n          preventOverlap = self.preventOverlap,\n          dissuadeHubs = self.dissuadeHubs,\n          mode = self.mode,\n          prune = self.prune;\n\n      for (var i = 0; i < esize; i += 1) {\n        var sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n        var sourceIdx = edgeEndsIdMap[i].sourceIdx;\n        var targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n        var targetIdx = edgeEndsIdMap[i].targetIdx;\n        if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1)) continue;\n        var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n        var eucliDis = Math.hypot(dir[0], dir[1]);\n        eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n        if (preventOverlap && iter < prevoIter) eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n        var Fa1 = eucliDis; // tslint:disable-line\n\n        var Fa2 = Fa1; // tslint:disable-line\n\n        if (mode === 'linlog') {\n          Fa1 = Math.log(1 + eucliDis);\n          Fa2 = Fa1;\n        }\n\n        if (dissuadeHubs) {\n          Fa1 = eucliDis / degrees[sourceIdx];\n          Fa2 = eucliDis / degrees[targetIdx];\n        }\n\n        if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n          Fa1 = 0;\n          Fa2 = 0;\n        } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n          Fa1 = eucliDis;\n          Fa2 = eucliDis;\n        }\n\n        forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n        forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n        forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n        forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n      }\n\n      return forces;\n    }\n  }, {\n    key: \"getRepGraForces\",\n    value: function getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees) {\n      var self = this;\n      var nodes = self.nodes,\n          preventOverlap = self.preventOverlap,\n          kr = self.kr,\n          kg = self.kg,\n          center = self.center,\n          prune = self.prune;\n      var nodeNum = nodes.length;\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        for (var j = i + 1; j < nodeNum; j += 1) {\n          if (prune && (degrees[i] <= 1 || degrees[j] <= 1)) continue;\n          var _dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n\n          var _eucliDis = Math.hypot(_dir[0], _dir[1]);\n\n          _eucliDis = _eucliDis < 0.0001 ? 0.0001 : _eucliDis;\n          _dir[0] = _dir[0] / _eucliDis;\n          _dir[1] = _dir[1] / _eucliDis;\n          if (preventOverlap && iter < prevoIter) _eucliDis = _eucliDis - sizes[i] - sizes[j];\n          var Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / _eucliDis; // tslint:disable-line\n\n          if (preventOverlap && iter < prevoIter && _eucliDis < 0) {\n            Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n          } else if (preventOverlap && iter < prevoIter && _eucliDis === 0) {\n            Fr = 0;\n          } else if (preventOverlap && iter < prevoIter && _eucliDis > 0) {\n            Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / _eucliDis;\n          }\n\n          forces[2 * i] -= Fr * _dir[0];\n          forces[2 * j] += Fr * _dir[0];\n          forces[2 * i + 1] -= Fr * _dir[1];\n          forces[2 * j + 1] += Fr * _dir[1];\n        } // gravity\n\n\n        var dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n        var eucliDis = Math.hypot(dir[0], dir[1]);\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n        var Fg = kg * (degrees[i] + 1); // tslint:disable-line\n\n        forces[2 * i] -= Fg * dir[0];\n        forces[2 * i + 1] -= Fg * dir[1];\n      }\n\n      return forces;\n    }\n  }, {\n    key: \"getOptRepGraForces\",\n    value: function getOptRepGraForces(forces, bodies, degrees) {\n      var self = this;\n      var nodes = self.nodes,\n          kg = self.kg,\n          center = self.center,\n          prune = self.prune;\n      var nodeNum = nodes.length;\n      var minx = 9e10;\n      var maxx = -9e10;\n      var miny = 9e10;\n      var maxy = -9e10;\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        if (prune && degrees[i] <= 1) continue;\n        bodies[i].setPos(nodes[i].x, nodes[i].y);\n        if (nodes[i].x >= maxx) maxx = nodes[i].x;\n        if (nodes[i].x <= minx) minx = nodes[i].x;\n        if (nodes[i].y >= maxy) maxy = nodes[i].y;\n        if (nodes[i].y <= miny) miny = nodes[i].y;\n      }\n\n      var width = Math.max(maxx - minx, maxy - miny);\n      var quadParams = {\n        xmid: (maxx + minx) / 2,\n        ymid: (maxy + miny) / 2,\n        length: width,\n        massCenter: center,\n        mass: nodeNum\n      };\n      var quad = new Quad(quadParams);\n      var quadTree = new QuadTree(quad); // build the tree, insert the nodes(quads) into the tree\n\n      for (var _i3 = 0; _i3 < nodeNum; _i3 += 1) {\n        if (prune && degrees[_i3] <= 1) continue;\n        if (bodies[_i3].in(quad)) quadTree.insert(bodies[_i3]);\n      } // update the repulsive forces and the gravity.\n\n\n      for (var _i4 = 0; _i4 < nodeNum; _i4 += 1) {\n        if (prune && degrees[_i4] <= 1) continue;\n\n        bodies[_i4].resetForce();\n\n        quadTree.updateForce(bodies[_i4]);\n        forces[2 * _i4] -= bodies[_i4].fx;\n        forces[2 * _i4 + 1] -= bodies[_i4].fy; // gravity\n\n        var dir = [nodes[_i4].x - center[0], nodes[_i4].y - center[1]];\n        var eucliDis = Math.hypot(dir[0], dir[1]);\n        eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n        var Fg = kg * (degrees[_i4] + 1); // tslint:disable-line\n\n        forces[2 * _i4] -= Fg * dir[0];\n        forces[2 * _i4 + 1] -= Fg * dir[1];\n      }\n\n      return forces;\n    }\n  }, {\n    key: \"updatePos\",\n    value: function updatePos(forces, preForces, sg, degrees) {\n      var self = this;\n      var nodes = self.nodes,\n          ks = self.ks,\n          tao = self.tao,\n          prune = self.prune,\n          ksmax = self.ksmax;\n      var nodeNum = nodes.length;\n      var swgns = [];\n      var trans = []; // swg(G) and tra(G)\n\n      var swgG = 0;\n      var traG = 0;\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        if (prune && degrees[i] <= 1) continue;\n        var minus = [forces[2 * i] - preForces[2 * i], forces[2 * i + 1] - preForces[2 * i + 1]];\n        var minusNorm = Math.hypot(minus[0], minus[1]);\n        var add = [forces[2 * i] + preForces[2 * i], forces[2 * i + 1] + preForces[2 * i + 1]];\n        var addNorm = Math.hypot(add[0], add[1]);\n        swgns[i] = minusNorm;\n        trans[i] = addNorm / 2;\n        swgG += (degrees[i] + 1) * swgns[i];\n        traG += (degrees[i] + 1) * trans[i];\n      }\n\n      var preSG = sg;\n      sg = tao * traG / swgG; // tslint:disable-line\n\n      if (preSG !== 0) {\n        sg = sg > 1.5 * preSG ? 1.5 * preSG : sg; // tslint:disable-line\n      } // update the node positions\n\n\n      for (var _i5 = 0; _i5 < nodeNum; _i5 += 1) {\n        if (prune && degrees[_i5] <= 1) continue;\n        var sn = ks * sg / (1 + sg * Math.sqrt(swgns[_i5]));\n        var absForce = Math.hypot(forces[2 * _i5], forces[2 * _i5 + 1]);\n        absForce = absForce < 0.0001 ? 0.0001 : absForce;\n        var max = ksmax / absForce;\n        sn = sn > max ? max : sn;\n        var dnx = sn * forces[2 * _i5];\n        var dny = sn * forces[2 * _i5 + 1];\n        nodes[_i5].x += dnx;\n        nodes[_i5].y += dny;\n      }\n\n      return {\n        nodes: nodes,\n        sg: sg\n      };\n    }\n  }]);\n\n  return ForceAtlas2Layout;\n}(Base);","map":null,"metadata":{},"sourceType":"module"}