{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"../util\");\n\nvar sort = function sort(entries, biasRight, usePrev) {\n  var parts = (0, util_1.partition)(entries, function (entry) {\n    // NOTE: 有fixorder的也可以排\n    return entry.hasOwnProperty(\"fixorder\") && !isNaN(entry.fixorder) || entry.hasOwnProperty(\"barycenter\");\n  });\n  var sortable = parts.lhs;\n  var unsortable = parts.rhs.sort(function (a, b) {\n    return -a.i - -b.i;\n  });\n  var vs = [];\n  var sum = 0;\n  var weight = 0;\n  var vsIndex = 0;\n  sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  sortable === null || sortable === void 0 ? void 0 : sortable.forEach(function (entry) {\n    var _a;\n\n    vsIndex += (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter * entry.weight;\n    weight += entry.weight;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n  var result = {\n    vs: vs.flat()\n  };\n\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n\n  return result;\n};\n\nvar consumeUnsortable = function consumeUnsortable(vs, unsortable, index) {\n  var iindex = index;\n  var last;\n\n  while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= iindex) {\n    unsortable.pop();\n    vs === null || vs === void 0 ? void 0 : vs.push(last.vs);\n    iindex++;\n  }\n\n  return iindex;\n};\n/**\n * 配置是否考虑使用之前的布局结果\n */\n\n\nvar compareWithBias = function compareWithBias(bias, usePrev) {\n  return function (entryV, entryW) {\n    // 排序的时候先判断fixorder，不行再判断重心\n    if (entryV.fixorder !== undefined && entryW.fixorder !== undefined) {\n      return entryV.fixorder - entryW.fixorder;\n    }\n\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1;\n    }\n\n    if (entryV.barycenter > entryW.barycenter) {\n      return 1;\n    } // 重心相同，考虑之前排好的顺序\n\n\n    if (usePrev && entryV.order !== undefined && entryW.order !== undefined) {\n      if (entryV.order < entryW.order) {\n        return -1;\n      }\n\n      if (entryV.order > entryW.order) {\n        return 1;\n      }\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n};\n\nexports.default = sort;","map":null,"metadata":{},"sourceType":"script"}