{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.minBy = exports.notime = exports.time = exports.partition = exports.maxRank = exports.addBorderNode = exports.removeEmptyRanks = exports.normalizeRanks = exports.buildLayerMatrix = exports.intersectRect = exports.predecessorWeights = exports.successorWeights = exports.zipObject = exports.asNonCompoundGraph = exports.simplify = exports.addDummyNode = void 0;\n\nvar util_1 = require(\"../../../util\");\n\nvar graph_1 = require(\"../graph\");\n\nvar safeSort = function safeSort(valueA, valueB) {\n  return Number(valueA) - Number(valueB);\n};\n/*\n * Adds a dummy node to the graph and return v.\n */\n\n\nvar addDummyNode = function addDummyNode(g, type, attrs, name) {\n  var v;\n\n  do {\n    v = \"\".concat(name).concat(Math.random());\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n};\n\nexports.addDummyNode = addDummyNode;\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\n\nvar simplify = function simplify(g) {\n  var simplified = new graph_1.Graph().setGraph(g.graph());\n  g.nodes().forEach(function (v) {\n    simplified.setNode(v, g.node(v));\n  });\n  g.edges().forEach(function (e) {\n    var simpleLabel = simplified.edgeFromArgs(e.v, e.w) || {\n      weight: 0,\n      minlen: 1\n    };\n    var label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n};\n\nexports.simplify = simplify;\n\nvar asNonCompoundGraph = function asNonCompoundGraph(g) {\n  var simplified = new graph_1.Graph({\n    multigraph: g.isMultigraph()\n  }).setGraph(g.graph());\n  g.nodes().forEach(function (node) {\n    var _a;\n\n    if (!((_a = g.children(node)) === null || _a === void 0 ? void 0 : _a.length)) {\n      simplified.setNode(node, g.node(node));\n    }\n  });\n  g.edges().forEach(function (edge) {\n    simplified.setEdgeObj(edge, g.edge(edge));\n  });\n  return simplified;\n};\n\nexports.asNonCompoundGraph = asNonCompoundGraph;\n\nvar zipObject = function zipObject(keys, values) {\n  return keys === null || keys === void 0 ? void 0 : keys.reduce(function (obj, key, i) {\n    obj[key] = values[i];\n    return obj;\n  }, {});\n};\n\nexports.zipObject = zipObject;\n\nvar successorWeights = function successorWeights(g) {\n  var weightsMap = {};\n  g.nodes().forEach(function (node) {\n    var _a;\n\n    var sucs = {};\n    (_a = g.outEdges(node)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n      var _a;\n\n      sucs[e.w] = (sucs[e.w] || 0) + (((_a = g.edge(e)) === null || _a === void 0 ? void 0 : _a.weight) || 0);\n    });\n    weightsMap[node] = sucs;\n  });\n  return weightsMap;\n};\n\nexports.successorWeights = successorWeights;\n\nvar predecessorWeights = function predecessorWeights(g) {\n  var nodes = g.nodes();\n  var weightMap = nodes.map(function (v) {\n    var _a;\n\n    var preds = {};\n    (_a = g.inEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return (0, exports.zipObject)(nodes, weightMap);\n};\n\nexports.predecessorWeights = predecessorWeights;\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\n\nvar intersectRect = function intersectRect(rect, point) {\n  var x = Number(rect.x);\n  var y = Number(rect.y); // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n\n  var dx = Number(point.x) - x;\n  var dy = Number(point.y) - y;\n  var w = Number(rect.width) / 2;\n  var h = Number(rect.height) / 2;\n\n  if (!dx && !dy) {\n    // completely overlapped directly, then return points its self\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var sx;\n  var sy;\n\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return {\n    x: x + sx,\n    y: y + sy\n  };\n};\n\nexports.intersectRect = intersectRect;\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * const will produce a matrix with the ids of each node.\n */\n\nvar buildLayerMatrix = function buildLayerMatrix(g) {\n  var layeringNodes = [];\n  var rankMax = (0, exports.maxRank)(g) + 1;\n\n  for (var i = 0; i < rankMax; i++) {\n    layeringNodes.push([]);\n  } // const layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n\n\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n    var rank = node.rank;\n\n    if (rank !== undefined && layeringNodes[rank]) {\n      layeringNodes[rank].push(v);\n    }\n  });\n\n  for (var i = 0; i < rankMax; i++) {\n    layeringNodes[i] = layeringNodes[i].sort(function (va, vb) {\n      var _a, _b;\n\n      return safeSort((_a = g.node(va)) === null || _a === void 0 ? void 0 : _a.order, (_b = g.node(vb)) === null || _b === void 0 ? void 0 : _b.order);\n    });\n  }\n\n  return layeringNodes;\n};\n\nexports.buildLayerMatrix = buildLayerMatrix;\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\n\nvar normalizeRanks = function normalizeRanks(g) {\n  var nodeRanks = g.nodes().filter(function (v) {\n    var _a;\n\n    return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) !== undefined;\n  }).map(function (v) {\n    return g.node(v).rank;\n  });\n  var min = Math.min.apply(Math, nodeRanks);\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n\n    if (node.hasOwnProperty(\"rank\") && min !== Infinity) {\n      node.rank -= min;\n    }\n  });\n};\n\nexports.normalizeRanks = normalizeRanks;\n\nvar removeEmptyRanks = function removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var nodes = g.nodes();\n  var nodeRanks = nodes.filter(function (v) {\n    var _a;\n\n    return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) !== undefined;\n  }).map(function (v) {\n    return g.node(v).rank;\n  });\n  var offset = Math.min.apply(Math, nodeRanks);\n  var layers = [];\n  nodes.forEach(function (v) {\n    var _a;\n\n    var rank = (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) || 0) - offset;\n\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n\n    layers[rank].push(v);\n  });\n  var delta = 0;\n  var nodeRankFactor = g.graph().nodeRankFactor || 0;\n\n  for (var i = 0; i < layers.length; i++) {\n    var vs = layers[i];\n\n    if (vs === undefined) {\n      if (i % nodeRankFactor !== 0) {\n        delta -= 1;\n      }\n    } else if (delta) {\n      vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n        var node = g.node(v);\n\n        if (node) {\n          node.rank = node.rank || 0;\n          node.rank += delta;\n        }\n      });\n    }\n  }\n};\n\nexports.removeEmptyRanks = removeEmptyRanks;\n\nvar addBorderNode = function addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0\n  };\n\n  if ((0, util_1.isNumber)(rank) && (0, util_1.isNumber)(order)) {\n    node.rank = rank;\n    node.order = order;\n  }\n\n  return (0, exports.addDummyNode)(g, \"border\", node, prefix);\n};\n\nexports.addBorderNode = addBorderNode;\n\nvar maxRank = function maxRank(g) {\n  var maxRank;\n  g.nodes().forEach(function (v) {\n    var _a;\n\n    var rank = (_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank;\n\n    if (rank !== undefined) {\n      if (maxRank === undefined || rank > maxRank) {\n        maxRank = rank;\n      }\n    }\n  });\n\n  if (!maxRank) {\n    maxRank = 0;\n  }\n\n  return maxRank;\n};\n\nexports.maxRank = maxRank;\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * const returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\n\nvar partition = function partition(collection, fn) {\n  var result = {\n    lhs: [],\n    rhs: []\n  };\n  collection === null || collection === void 0 ? void 0 : collection.forEach(function (value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n};\n\nexports.partition = partition;\n/*\n * Returns a new const that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\n\nvar time = function time(name, fn) {\n  var start = Date.now();\n\n  try {\n    return fn();\n  } finally {\n    console.log(\"\".concat(name, \" time: \").concat(Date.now() - start, \"ms\"));\n  }\n};\n\nexports.time = time;\n\nvar notime = function notime(name, fn) {\n  return fn();\n};\n\nexports.notime = notime;\n\nvar minBy = function minBy(array, func) {\n  return array.reduce(function (a, b) {\n    var valA = func(a);\n    var valB = func(b);\n    return valA > valB ? b : a;\n  });\n};\n\nexports.minBy = minBy;","map":null,"metadata":{},"sourceType":"script"}