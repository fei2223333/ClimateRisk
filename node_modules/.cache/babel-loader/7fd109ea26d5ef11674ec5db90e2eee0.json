{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt, StringExt } from '../util';\nimport { Point, Polyline } from '../geometry';\nimport { Registry } from '../registry';\nimport { Markup } from '../view/markup';\nimport { ShareRegistry } from './registry';\nimport { Cell } from './cell';\nexport var Edge = /*#__PURE__*/function (_Cell) {\n  _inherits(Edge, _Cell);\n\n  function Edge() {\n    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Edge);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Edge).call(this, metadata));\n  }\n\n  _createClass(Edge, [{\n    key: \"preprocess\",\n    value: function preprocess(metadata, ignoreIdCheck) {\n      var source = metadata.source,\n          sourceCell = metadata.sourceCell,\n          sourcePort = metadata.sourcePort,\n          sourcePoint = metadata.sourcePoint,\n          target = metadata.target,\n          targetCell = metadata.targetCell,\n          targetPort = metadata.targetPort,\n          targetPoint = metadata.targetPoint,\n          others = __rest(metadata, [\"source\", \"sourceCell\", \"sourcePort\", \"sourcePoint\", \"target\", \"targetCell\", \"targetPort\", \"targetPoint\"]);\n\n      var data = others;\n\n      var isValidId = function isValidId(val) {\n        return typeof val === 'string' || typeof val === 'number';\n      };\n\n      if (source != null) {\n        if (Cell.isCell(source)) {\n          data.source = {\n            cell: source.id\n          };\n        } else if (isValidId(source)) {\n          data.source = {\n            cell: source\n          };\n        } else if (Point.isPoint(source)) {\n          data.source = source.toJSON();\n        } else if (Array.isArray(source)) {\n          data.source = {\n            x: source[0],\n            y: source[1]\n          };\n        } else {\n          var cell = source.cell;\n\n          if (Cell.isCell(cell)) {\n            data.source = Object.assign(Object.assign({}, source), {\n              cell: cell.id\n            });\n          } else {\n            data.source = source;\n          }\n        }\n      }\n\n      if (sourceCell != null || sourcePort != null) {\n        var terminal = data.source;\n\n        if (sourceCell != null) {\n          var id = isValidId(sourceCell) ? sourceCell : sourceCell.id;\n\n          if (terminal) {\n            terminal.cell = id;\n          } else {\n            terminal = data.source = {\n              cell: id\n            };\n          }\n        }\n\n        if (sourcePort != null && terminal) {\n          terminal.port = sourcePort;\n        }\n      } else if (sourcePoint != null) {\n        data.source = Point.create(sourcePoint).toJSON();\n      }\n\n      if (target != null) {\n        if (Cell.isCell(target)) {\n          data.target = {\n            cell: target.id\n          };\n        } else if (isValidId(target)) {\n          data.target = {\n            cell: target\n          };\n        } else if (Point.isPoint(target)) {\n          data.target = target.toJSON();\n        } else if (Array.isArray(target)) {\n          data.target = {\n            x: target[0],\n            y: target[1]\n          };\n        } else {\n          var _cell = target.cell;\n\n          if (Cell.isCell(_cell)) {\n            data.target = Object.assign(Object.assign({}, target), {\n              cell: _cell.id\n            });\n          } else {\n            data.target = target;\n          }\n        }\n      }\n\n      if (targetCell != null || targetPort != null) {\n        var _terminal = data.target;\n\n        if (targetCell != null) {\n          var _id = isValidId(targetCell) ? targetCell : targetCell.id;\n\n          if (_terminal) {\n            _terminal.cell = _id;\n          } else {\n            _terminal = data.target = {\n              cell: _id\n            };\n          }\n        }\n\n        if (targetPort != null && _terminal) {\n          _terminal.port = targetPort;\n        }\n      } else if (targetPoint != null) {\n        data.target = Point.create(targetPoint).toJSON();\n      }\n\n      return _get(_getPrototypeOf(Edge.prototype), \"preprocess\", this).call(this, data, ignoreIdCheck);\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this = this;\n\n      _get(_getPrototypeOf(Edge.prototype), \"setup\", this).call(this);\n\n      this.on('change:labels', function (args) {\n        return _this.onLabelsChanged(args);\n      });\n      this.on('change:vertices', function (args) {\n        return _this.onVertexsChanged(args);\n      });\n    }\n  }, {\n    key: \"isEdge\",\n    value: function isEdge() {\n      return true;\n    } // #region terminal\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.set({\n        source: {\n          x: 0,\n          y: 0\n        },\n        target: {\n          x: 0,\n          y: 0\n        }\n      }, options);\n      return this;\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.getTerminal('source');\n    }\n  }, {\n    key: \"getSourceCellId\",\n    value: function getSourceCellId() {\n      return this.source.cell;\n    }\n  }, {\n    key: \"getSourcePortId\",\n    value: function getSourcePortId() {\n      return this.source.port;\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(source, args) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.setTerminal('source', source, args, options);\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget() {\n      return this.getTerminal('target');\n    }\n  }, {\n    key: \"getTargetCellId\",\n    value: function getTargetCellId() {\n      return this.target.cell;\n    }\n  }, {\n    key: \"getTargetPortId\",\n    value: function getTargetPortId() {\n      return this.target.port;\n    }\n  }, {\n    key: \"setTarget\",\n    value: function setTarget(target, args) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.setTerminal('target', target, args, options);\n    }\n  }, {\n    key: \"getTerminal\",\n    value: function getTerminal(type) {\n      return Object.assign({}, this.store.get(type));\n    }\n  }, {\n    key: \"setTerminal\",\n    value: function setTerminal(type, terminal, args) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      // `terminal` is a cell\n      if (Cell.isCell(terminal)) {\n        this.store.set(type, ObjectExt.merge({}, args, {\n          cell: terminal.id\n        }), options);\n        return this;\n      } // `terminal` is a point-like object\n\n\n      var p = terminal;\n\n      if (Point.isPoint(terminal) || p.x != null && p.y != null) {\n        this.store.set(type, ObjectExt.merge({}, args, {\n          x: p.x,\n          y: p.y\n        }), options);\n        return this;\n      } // `terminal` is an object\n\n\n      this.store.set(type, ObjectExt.cloneDeep(terminal), options);\n      return this;\n    }\n  }, {\n    key: \"getSourcePoint\",\n    value: function getSourcePoint() {\n      return this.getTerminalPoint('source');\n    }\n  }, {\n    key: \"getTargetPoint\",\n    value: function getTargetPoint() {\n      return this.getTerminalPoint('target');\n    }\n  }, {\n    key: \"getTerminalPoint\",\n    value: function getTerminalPoint(type) {\n      var terminal = this[type];\n\n      if (Point.isPointLike(terminal)) {\n        return Point.create(terminal);\n      }\n\n      var cell = this.getTerminalCell(type);\n\n      if (cell) {\n        return cell.getConnectionPoint(this, type);\n      }\n\n      return new Point();\n    }\n  }, {\n    key: \"getSourceCell\",\n    value: function getSourceCell() {\n      return this.getTerminalCell('source');\n    }\n  }, {\n    key: \"getTargetCell\",\n    value: function getTargetCell() {\n      return this.getTerminalCell('target');\n    }\n  }, {\n    key: \"getTerminalCell\",\n    value: function getTerminalCell(type) {\n      if (this.model) {\n        var cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();\n\n        if (cellId) {\n          return this.model.getCell(cellId);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getSourceNode\",\n    value: function getSourceNode() {\n      return this.getTerminalNode('source');\n    }\n  }, {\n    key: \"getTargetNode\",\n    value: function getTargetNode() {\n      return this.getTerminalNode('target');\n    }\n  }, {\n    key: \"getTerminalNode\",\n    value: function getTerminalNode(type) {\n      var cell = this; // eslint-disable-line\n\n      var visited = {};\n\n      while (cell && cell.isEdge()) {\n        if (visited[cell.id]) {\n          return null;\n        }\n\n        visited[cell.id] = true;\n        cell = cell.getTerminalCell(type);\n      }\n\n      return cell && cell.isNode() ? cell : null;\n    } // #endregion\n    // #region router\n\n  }, {\n    key: \"getRouter\",\n    value: function getRouter() {\n      return this.store.get('router');\n    }\n  }, {\n    key: \"setRouter\",\n    value: function setRouter(name, args, options) {\n      if (typeof name === 'object') {\n        this.store.set('router', name, args);\n      } else {\n        this.store.set('router', {\n          name: name,\n          args: args\n        }, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeRouter\",\n    value: function removeRouter() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('router', options);\n      return this;\n    } // #endregion\n    // #region connector\n\n  }, {\n    key: \"getConnector\",\n    value: function getConnector() {\n      return this.store.get('connector');\n    }\n  }, {\n    key: \"setConnector\",\n    value: function setConnector(name, args, options) {\n      if (typeof name === 'object') {\n        this.store.set('connector', name, args);\n      } else {\n        this.store.set('connector', {\n          name: name,\n          args: args\n        }, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeConnector\",\n    value: function removeConnector() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.store.remove('connector', options);\n    } // #endregion\n    // #region strategy\n\n  }, {\n    key: \"getStrategy\",\n    value: function getStrategy() {\n      return this.store.get('strategy');\n    }\n  }, {\n    key: \"setStrategy\",\n    value: function setStrategy(name, args, options) {\n      if (typeof name === 'object') {\n        this.store.set('strategy', name, args);\n      } else {\n        this.store.set('strategy', {\n          name: name,\n          args: args\n        }, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeStrategy\",\n    value: function removeStrategy() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.store.remove('strategy', options);\n    } // #endregion\n    // #region labels\n\n  }, {\n    key: \"getDefaultLabel\",\n    value: function getDefaultLabel() {\n      var ctor = this.constructor;\n      var defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};\n      return ObjectExt.cloneDeep(defaults);\n    }\n  }, {\n    key: \"getLabels\",\n    value: function getLabels() {\n      var _this2 = this;\n\n      return _toConsumableArray(this.store.get('labels', [])).map(function (item) {\n        return _this2.parseLabel(item);\n      });\n    }\n  }, {\n    key: \"setLabels\",\n    value: function setLabels(labels) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);\n      return this;\n    }\n  }, {\n    key: \"insertLabel\",\n    value: function insertLabel(label, index) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var labels = this.getLabels();\n      var len = labels.length;\n      var idx = index != null && Number.isFinite(index) ? index : len;\n\n      if (idx < 0) {\n        idx = len + idx + 1;\n      }\n\n      labels.splice(idx, 0, this.parseLabel(label));\n      return this.setLabels(labels, options);\n    }\n  }, {\n    key: \"appendLabel\",\n    value: function appendLabel(label) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.insertLabel(label, -1, options);\n    }\n  }, {\n    key: \"getLabelAt\",\n    value: function getLabelAt(index) {\n      var labels = this.getLabels();\n\n      if (index != null && Number.isFinite(index)) {\n        return this.parseLabel(labels[index]);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"setLabelAt\",\n    value: function setLabelAt(index, label) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (index != null && Number.isFinite(index)) {\n        var labels = this.getLabels();\n        labels[index] = this.parseLabel(label);\n        this.setLabels(labels, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeLabelAt\",\n    value: function removeLabelAt(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var labels = this.getLabels();\n      var idx = index != null && Number.isFinite(index) ? index : -1;\n      var removed = labels.splice(idx, 1);\n      this.setLabels(labels, options);\n      return removed.length ? removed[0] : null;\n    }\n  }, {\n    key: \"parseLabel\",\n    value: function parseLabel(label) {\n      if (typeof label === 'string') {\n        var ctor = this.constructor;\n        return ctor.parseStringLabel(label);\n      }\n\n      return label;\n    }\n  }, {\n    key: \"onLabelsChanged\",\n    value: function onLabelsChanged(_ref) {\n      var previous = _ref.previous,\n          current = _ref.current;\n      var added = previous && current ? current.filter(function (label1) {\n        if (!previous.find(function (label2) {\n          return label1 === label2 || ObjectExt.isEqual(label1, label2);\n        })) {\n          return label1;\n        }\n\n        return null;\n      }) : current ? _toConsumableArray(current) : [];\n      var removed = previous && current ? previous.filter(function (label1) {\n        if (!current.find(function (label2) {\n          return label1 === label2 || ObjectExt.isEqual(label1, label2);\n        })) {\n          return label1;\n        }\n\n        return null;\n      }) : previous ? _toConsumableArray(previous) : [];\n\n      if (added.length > 0) {\n        this.notify('labels:added', {\n          added: added,\n          cell: this,\n          edge: this\n        });\n      }\n\n      if (removed.length > 0) {\n        this.notify('labels:removed', {\n          removed: removed,\n          cell: this,\n          edge: this\n        });\n      }\n    } // #endregion\n    // #region vertices\n\n  }, {\n    key: \"getDefaultVertexMarkup\",\n    value: function getDefaultVertexMarkup() {\n      return this.store.get('defaultVertexMarkup') || Markup.getEdgeVertexMarkup();\n    }\n  }, {\n    key: \"getVertexMarkup\",\n    value: function getVertexMarkup() {\n      return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();\n    }\n  }, {\n    key: \"setVertexMarkup\",\n    value: function setVertexMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('vertexMarkup', Markup.clone(markup), options);\n      return this;\n    }\n  }, {\n    key: \"getVertices\",\n    value: function getVertices() {\n      return _toConsumableArray(this.store.get('vertices', []));\n    }\n  }, {\n    key: \"setVertices\",\n    value: function setVertices(vertices) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var points = Array.isArray(vertices) ? vertices : [vertices];\n      this.store.set('vertices', points.map(function (p) {\n        return Point.toJSON(p);\n      }), options);\n      return this;\n    }\n  }, {\n    key: \"insertVertex\",\n    value: function insertVertex(vertice, index) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var vertices = this.getVertices();\n      var len = vertices.length;\n      var idx = index != null && Number.isFinite(index) ? index : len;\n\n      if (idx < 0) {\n        idx = len + idx + 1;\n      }\n\n      vertices.splice(idx, 0, Point.toJSON(vertice));\n      return this.setVertices(vertices, options);\n    }\n  }, {\n    key: \"appendVertex\",\n    value: function appendVertex(vertex) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.insertVertex(vertex, -1, options);\n    }\n  }, {\n    key: \"getVertexAt\",\n    value: function getVertexAt(index) {\n      if (index != null && Number.isFinite(index)) {\n        var vertices = this.getVertices();\n        return vertices[index];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"setVertexAt\",\n    value: function setVertexAt(index, vertice) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (index != null && Number.isFinite(index)) {\n        var vertices = this.getVertices();\n        vertices[index] = vertice;\n        this.setVertices(vertices, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeVertexAt\",\n    value: function removeVertexAt(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var vertices = this.getVertices();\n      var idx = index != null && Number.isFinite(index) ? index : -1;\n      vertices.splice(idx, 1);\n      return this.setVertices(vertices, options);\n    }\n  }, {\n    key: \"onVertexsChanged\",\n    value: function onVertexsChanged(_ref2) {\n      var previous = _ref2.previous,\n          current = _ref2.current;\n      var added = previous && current ? current.filter(function (p1) {\n        if (!previous.find(function (p2) {\n          return Point.equals(p1, p2);\n        })) {\n          return p1;\n        }\n\n        return null;\n      }) : current ? _toConsumableArray(current) : [];\n      var removed = previous && current ? previous.filter(function (p1) {\n        if (!current.find(function (p2) {\n          return Point.equals(p1, p2);\n        })) {\n          return p1;\n        }\n\n        return null;\n      }) : previous ? _toConsumableArray(previous) : [];\n\n      if (added.length > 0) {\n        this.notify('vertexs:added', {\n          added: added,\n          cell: this,\n          edge: this\n        });\n      }\n\n      if (removed.length > 0) {\n        this.notify('vertexs:removed', {\n          removed: removed,\n          cell: this,\n          edge: this\n        });\n      }\n    } // #endregion\n    // #region markup\n\n  }, {\n    key: \"getDefaultMarkup\",\n    value: function getDefaultMarkup() {\n      return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();\n    }\n  }, {\n    key: \"getMarkup\",\n    value: function getMarkup() {\n      return _get(_getPrototypeOf(Edge.prototype), \"getMarkup\", this).call(this) || this.getDefaultMarkup();\n    } // #endregion\n    // #region toolMarkup\n\n  }, {\n    key: \"getDefaultToolMarkup\",\n    value: function getDefaultToolMarkup() {\n      return this.store.get('defaultToolMarkup') || Markup.getEdgeToolMarkup();\n    }\n  }, {\n    key: \"getToolMarkup\",\n    value: function getToolMarkup() {\n      return this.store.get('toolMarkup') || this.getDefaultToolMarkup();\n    }\n  }, {\n    key: \"setToolMarkup\",\n    value: function setToolMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('toolMarkup', markup, options);\n      return this;\n    }\n  }, {\n    key: \"getDefaultDoubleToolMarkup\",\n    value: function getDefaultDoubleToolMarkup() {\n      return this.store.get('defaultDoubleToolMarkup');\n    }\n  }, {\n    key: \"getDoubleToolMarkup\",\n    value: function getDoubleToolMarkup() {\n      return this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup();\n    }\n  }, {\n    key: \"setDoubleToolMarkup\",\n    value: function setDoubleToolMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('doubleToolMarkup', markup, options);\n      return this;\n    } // #endregion\n    // #region arrowheadMarkup\n\n  }, {\n    key: \"getDefaultArrowheadMarkup\",\n    value: function getDefaultArrowheadMarkup() {\n      return this.store.get('defaultArrowheadMarkup') || Markup.getEdgeArrowheadMarkup();\n    }\n  }, {\n    key: \"getArrowheadMarkup\",\n    value: function getArrowheadMarkup() {\n      return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();\n    }\n  }, {\n    key: \"setArrowheadMarkup\",\n    value: function setArrowheadMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('arrowheadMarkup', markup, options);\n      return this;\n    } // #endregion\n    // #region transform\n\n    /**\n     * Translate the edge vertices (and source and target if they are points)\n     * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      options.translateBy = options.translateBy || this.id;\n      options.tx = tx;\n      options.ty = ty;\n      return this.applyToPoints(function (p) {\n        return {\n          x: (p.x || 0) + tx,\n          y: (p.y || 0) + ty\n        };\n      }, options);\n    }\n    /**\n     * Scales the edge's points (vertices) relative to the given origin.\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return this.applyToPoints(function (p) {\n        return Point.create(p).scale(sx, sy, origin).toJSON();\n      }, options);\n    }\n  }, {\n    key: \"applyToPoints\",\n    value: function applyToPoints(worker) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var attrs = {};\n      var source = this.getSource();\n      var target = this.getTarget();\n\n      if (Point.isPointLike(source)) {\n        attrs.source = worker(source);\n      }\n\n      if (Point.isPointLike(target)) {\n        attrs.target = worker(target);\n      }\n\n      var vertices = this.getVertices();\n\n      if (vertices.length > 0) {\n        attrs.vertices = vertices.map(worker);\n      }\n\n      this.store.set(attrs, options);\n      return this;\n    } // #endregion\n    // #region common\n\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.getPolyline().bbox();\n    }\n  }, {\n    key: \"getConnectionPoint\",\n    value: function getConnectionPoint() {\n      return this.getPolyline().pointAt(0.5);\n    }\n  }, {\n    key: \"getPolyline\",\n    value: function getPolyline() {\n      var points = [this.getSourcePoint()].concat(_toConsumableArray(this.getVertices().map(function (vertice) {\n        return Point.create(vertice);\n      })), [this.getTargetPoint()]);\n      return new Polyline(points);\n    }\n  }, {\n    key: \"updateParent\",\n    value: function updateParent(options) {\n      var newParent = null;\n      var source = this.getSourceCell();\n      var target = this.getTargetCell();\n      var prevParent = this.getParent();\n\n      if (source && target) {\n        if (source === target || source.isDescendantOf(target)) {\n          newParent = target;\n        } else if (target.isDescendantOf(source)) {\n          newParent = source;\n        } else {\n          newParent = Cell.getCommonAncestor(source, target);\n        }\n      } // Unembeds the edge if source and target has no common\n      // ancestor or common ancestor changed\n\n\n      if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n        prevParent.unembed(this, options);\n      }\n\n      if (newParent) {\n        newParent.embed(this, options);\n      }\n\n      return newParent;\n    }\n  }, {\n    key: \"hasLoop\",\n    value: function hasLoop() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var source = this.getSource();\n      var target = this.getTarget();\n      var sourceId = source.cell;\n      var targetId = target.cell;\n\n      if (!sourceId || !targetId) {\n        return false;\n      }\n\n      var loop = sourceId === targetId; // Note that there in the deep mode a edge can have a loop,\n      // even if it connects only a parent and its embed.\n      // A loop \"target equals source\" is valid in both shallow and deep mode.\n      // eslint-disable-next-line\n\n      if (!loop && options.deep && this._model) {\n        var sourceCell = this.getSourceCell();\n        var targetCell = this.getTargetCell();\n\n        if (sourceCell && targetCell) {\n          loop = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);\n        }\n      }\n\n      return loop;\n    }\n  }, {\n    key: \"getFragmentAncestor\",\n    value: function getFragmentAncestor() {\n      var cells = [this, this.getSourceNode(), this.getTargetNode()].filter(function (item) {\n        return item != null;\n      });\n      return this.getCommonAncestor.apply(this, _toConsumableArray(cells));\n    }\n  }, {\n    key: \"isFragmentDescendantOf\",\n    value: function isFragmentDescendantOf(cell) {\n      var ancestor = this.getFragmentAncestor();\n      return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Edge.toStringTag;\n    }\n  }, {\n    key: \"source\",\n    get: function get() {\n      return this.getSource();\n    },\n    set: function set(data) {\n      this.setSource(data);\n    }\n  }, {\n    key: \"target\",\n    get: function get() {\n      return this.getTarget();\n    },\n    set: function set(data) {\n      this.setTarget(data);\n    }\n  }, {\n    key: \"router\",\n    get: function get() {\n      return this.getRouter();\n    },\n    set: function set(data) {\n      if (data == null) {\n        this.removeRouter();\n      } else {\n        this.setRouter(data);\n      }\n    }\n  }, {\n    key: \"connector\",\n    get: function get() {\n      return this.getConnector();\n    },\n    set: function set(data) {\n      if (data == null) {\n        this.removeConnector();\n      } else {\n        this.setConnector(data);\n      }\n    }\n  }, {\n    key: \"strategy\",\n    get: function get() {\n      return this.getStrategy();\n    },\n    set: function set(data) {\n      if (data == null) {\n        this.removeStrategy();\n      } else {\n        this.setStrategy(data);\n      }\n    }\n  }, {\n    key: \"labels\",\n    get: function get() {\n      return this.getLabels();\n    },\n    set: function set(labels) {\n      this.setLabels(labels);\n    }\n  }, {\n    key: \"vertexMarkup\",\n    get: function get() {\n      return this.getVertexMarkup();\n    },\n    set: function set(markup) {\n      this.setVertexMarkup(markup);\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      return this.getVertices();\n    },\n    set: function set(vertices) {\n      this.setVertices(vertices);\n    }\n  }, {\n    key: \"toolMarkup\",\n    get: function get() {\n      return this.getToolMarkup();\n    },\n    set: function set(markup) {\n      this.setToolMarkup(markup);\n    }\n  }, {\n    key: \"doubleToolMarkup\",\n    get: function get() {\n      return this.getDoubleToolMarkup();\n    },\n    set: function set(markup) {\n      this.setDoubleToolMarkup(markup);\n    }\n  }, {\n    key: \"arrowheadMarkup\",\n    get: function get() {\n      return this.getArrowheadMarkup();\n    },\n    set: function set(markup) {\n      this.setArrowheadMarkup(markup);\n    }\n  }]);\n\n  return Edge;\n}(Cell);\nEdge.defaults = {};\n\n(function (Edge) {\n  function equalTerminals(a, b) {\n    var a1 = a;\n    var b1 = b;\n\n    if (a1.cell === b1.cell) {\n      return a1.port === b1.port || a1.port == null && b1.port == null;\n    }\n\n    return false;\n  }\n\n  Edge.equalTerminals = equalTerminals;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.defaultLabel = {\n    markup: [{\n      tagName: 'rect',\n      selector: 'body'\n    }, {\n      tagName: 'text',\n      selector: 'label'\n    }],\n    attrs: {\n      text: {\n        fill: '#000',\n        fontSize: 14,\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n        pointerEvents: 'none'\n      },\n      rect: {\n        ref: 'label',\n        fill: '#fff',\n        rx: 3,\n        ry: 3,\n        refWidth: 1,\n        refHeight: 1,\n        refX: 0,\n        refY: 0\n      }\n    },\n    position: {\n      distance: 0.5\n    }\n  };\n\n  function parseStringLabel(text) {\n    return {\n      attrs: {\n        label: {\n          text: text\n        }\n      }\n    };\n  }\n\n  Edge.parseStringLabel = parseStringLabel;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.toStringTag = \"X6.\".concat(Edge.name);\n\n  function isEdge(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Edge) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var edge = instance;\n\n    if ((tag == null || tag === Edge.toStringTag) && typeof edge.isNode === 'function' && typeof edge.isEdge === 'function' && typeof edge.prop === 'function' && typeof edge.attr === 'function' && typeof edge.disconnect === 'function' && typeof edge.getSource === 'function' && typeof edge.getTarget === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Edge.isEdge = isEdge;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.registry = Registry.create({\n    type: 'edge',\n    process: function process(shape, options) {\n      if (ShareRegistry.exist(shape, false)) {\n        throw new Error(\"Edge with name '\".concat(shape, \"' was registered by anthor Node\"));\n      }\n\n      if (typeof options === 'function') {\n        options.config({\n          shape: shape\n        });\n        return options;\n      }\n\n      var parent = Edge; // default inherit from 'dege'\n\n      var _options$inherit = options.inherit,\n          inherit = _options$inherit === void 0 ? 'edge' : _options$inherit,\n          others = __rest(options, [\"inherit\"]);\n\n      if (typeof inherit === 'string') {\n        var base = this.get(inherit || 'edge');\n\n        if (base == null && inherit) {\n          this.onNotFound(inherit, 'inherited');\n        } else {\n          parent = base;\n        }\n      } else {\n        parent = inherit;\n      }\n\n      if (others.constructorName == null) {\n        others.constructorName = shape;\n      }\n\n      var ctor = parent.define.call(parent, others);\n      ctor.config({\n        shape: shape\n      });\n      return ctor;\n    }\n  });\n  ShareRegistry.setEdgeRegistry(Edge.registry);\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  var counter = 0;\n\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n\n    counter += 1;\n    return \"CustomEdge\".concat(counter);\n  }\n\n  function define(config) {\n    var constructorName = config.constructorName,\n        overwrite = config.overwrite,\n        others = __rest(config, [\"constructorName\", \"overwrite\"]);\n\n    var ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n\n    if (others.shape) {\n      Edge.registry.register(others.shape, ctor, overwrite);\n    }\n\n    return ctor;\n  }\n\n  Edge.define = define;\n\n  function create(options) {\n    var shape = options.shape || 'edge';\n    var Ctor = Edge.registry.get(shape);\n\n    if (Ctor) {\n      return new Ctor(options);\n    }\n\n    return Edge.registry.onNotFound(shape);\n  }\n\n  Edge.create = create;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  var shape = 'basic.edge';\n  Edge.config({\n    shape: shape,\n    propHooks: function propHooks(metadata) {\n      var label = metadata.label,\n          vertices = metadata.vertices,\n          others = __rest(metadata, [\"label\", \"vertices\"]);\n\n      if (label) {\n        if (others.labels == null) {\n          others.labels = [];\n        }\n\n        var formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;\n        others.labels.push(formated);\n      }\n\n      if (vertices) {\n        if (Array.isArray(vertices)) {\n          others.vertices = vertices.map(function (item) {\n            return Point.create(item).toJSON();\n          });\n        }\n      }\n\n      return others;\n    }\n  });\n  Edge.registry.register(shape, Edge);\n})(Edge || (Edge = {}));","map":null,"metadata":{},"sourceType":"module"}