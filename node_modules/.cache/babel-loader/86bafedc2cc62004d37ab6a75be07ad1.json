{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar barycenter_1 = __importDefault(require(\"./barycenter\"));\n\nvar resolve_conflicts_1 = __importDefault(require(\"./resolve-conflicts\"));\n\nvar sort_1 = __importDefault(require(\"./sort\"));\n\nvar sortSubgraph = function sortSubgraph(g, v, cg, biasRight, usePrev) {\n  var _a, _b, _c, _d;\n\n  var movable = g.children(v); // fixorder的点不参与排序（这个方案不合适，只排了新增节点，和原来的分离）\n\n  var node = g.node(v);\n  var bl = node ? node.borderLeft : undefined;\n  var br = node ? node.borderRight : undefined;\n  var subgraphs = {};\n\n  if (bl) {\n    movable = movable === null || movable === void 0 ? void 0 : movable.filter(function (w) {\n      return w !== bl && w !== br;\n    });\n  }\n\n  var barycenters = (0, barycenter_1.default)(g, movable || []);\n  barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach(function (entry) {\n    var _a;\n\n    if ((_a = g.children(entry.v)) === null || _a === void 0 ? void 0 : _a.length) {\n      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n\n      if (subgraphResult.hasOwnProperty(\"barycenter\")) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n  var entries = (0, resolve_conflicts_1.default)(barycenters, cg);\n  expandSubgraphs(entries, subgraphs); // 添加fixorder信息到entries里边\n  // TODO: 不考虑复合情况，只用第一个点的fixorder信息，后续考虑更完备的实现\n\n  (_a = entries.filter(function (e) {\n    return e.vs.length > 0;\n  })) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n    var node = g.node(e.vs[0]);\n\n    if (node) {\n      e.fixorder = node.fixorder;\n      e.order = node.order;\n    }\n  });\n  var result = (0, sort_1.default)(entries, biasRight, usePrev);\n\n  if (bl) {\n    result.vs = [bl, result.vs, br].flat();\n\n    if ((_b = g.predecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {\n      var blPred = g.node(((_c = g.predecessors(bl)) === null || _c === void 0 ? void 0 : _c[0]) || \"\");\n      var brPred = g.node(((_d = g.predecessors(br)) === null || _d === void 0 ? void 0 : _d[0]) || \"\");\n\n      if (!result.hasOwnProperty(\"barycenter\")) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n\n      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);\n      result.weight += 2;\n    }\n  }\n\n  return result;\n};\n\nvar expandSubgraphs = function expandSubgraphs(entries, subgraphs) {\n  entries === null || entries === void 0 ? void 0 : entries.forEach(function (entry) {\n    var _a;\n\n    var vss = (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.map(function (v) {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs;\n      }\n\n      return v;\n    });\n    entry.vs = vss.flat();\n  });\n};\n\nvar mergeBarycenters = function mergeBarycenters(target, other) {\n  if (target.barycenter !== undefined) {\n    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);\n    target.weight += other.weight;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n};\n\nexports.default = sortSubgraph;","map":null,"metadata":{},"sourceType":"script"}