{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ArrayExt } from '../../../util';\nimport { Point } from '../../../geometry';\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\n\nexport var ObstacleMap = /*#__PURE__*/function () {\n  function ObstacleMap(options) {\n    _classCallCheck(this, ObstacleMap);\n\n    this.options = options;\n    this.mapGridSize = 100;\n    this.map = {};\n  }\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n\n\n  _createClass(ObstacleMap, [{\n    key: \"build\",\n    value: function build(model, edge) {\n      var options = this.options; // source or target node could be excluded from set of obstacles\n\n      var excludedTerminals = options.excludeTerminals.reduce(function (memo, type) {\n        var terminal = edge[type];\n\n        if (terminal) {\n          var cell = model.getCell(terminal.cell);\n\n          if (cell) {\n            memo.push(cell);\n          }\n        }\n\n        return memo;\n      }, []);\n      var excludedAncestors = [];\n      var source = model.getCell(edge.getSourceCellId());\n\n      if (source) {\n        excludedAncestors = ArrayExt.union(excludedAncestors, source.getAncestors().map(function (cell) {\n          return cell.id;\n        }));\n      }\n\n      var target = model.getCell(edge.getTargetCellId());\n\n      if (target) {\n        excludedAncestors = ArrayExt.union(excludedAncestors, target.getAncestors().map(function (cell) {\n          return cell.id;\n        }));\n      } // The graph is divided into smaller cells, where each holds information\n      // about which node belong to it. When we query whether a point lies\n      // inside an obstacle we don't need to go through all obstacles, we check\n      // only those in a particular cell.\n\n\n      var mapGridSize = this.mapGridSize;\n      model.getNodes().reduce(function (map, node) {\n        var shape = node.shape;\n        var excludeShapes = options.excludeShapes;\n        var excType = shape ? excludeShapes.includes(shape) : false;\n        var excTerminal = excludedTerminals.some(function (cell) {\n          return cell.id === node.id;\n        });\n        var excAncestor = excludedAncestors.includes(node.id);\n        var excHidden = options.excludeHiddenNodes && !node.isVisible();\n        var excluded = excType || excTerminal || excAncestor || excHidden;\n\n        if (!excluded) {\n          var bbox = node.getBBox().moveAndExpand(options.paddingBox);\n          var origin = bbox.getOrigin().snapToGrid(mapGridSize);\n          var corner = bbox.getCorner().snapToGrid(mapGridSize);\n\n          for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n            for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n              var key = new Point(x, y).toString();\n\n              if (map[key] == null) {\n                map[key] = [];\n              }\n\n              map[key].push(bbox);\n            }\n          }\n        }\n\n        return map;\n      }, this.map);\n      return this;\n    }\n  }, {\n    key: \"isAccessible\",\n    value: function isAccessible(point) {\n      var key = point.clone().snapToGrid(this.mapGridSize).toString();\n      var rects = this.map[key];\n      return rects ? rects.every(function (rect) {\n        return !rect.containsPoint(point);\n      }) : true;\n    }\n  }]);\n\n  return ObstacleMap;\n}();","map":null,"metadata":{},"sourceType":"module"}