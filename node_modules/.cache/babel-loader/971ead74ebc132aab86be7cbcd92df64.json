{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _slicedToArray from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e6) { throw _e6; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e7) { didErr = true; err = _e7; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar e = {\n  graph: {\n    meta: {\n      rankDir: \"TB\",\n      nodeSep: 50,\n      rankSep: 50,\n      edgeSep: 5,\n      align: void 0\n    }\n  },\n  subScene: {\n    meta: {\n      paddingTop: 20,\n      paddingBottom: 20,\n      paddingLeft: 20,\n      paddingRight: 20,\n      labelHeight: 20\n    }\n  },\n  nodeSize: {\n    meta: {\n      width: 100,\n      maxLabelWidth: 0,\n      height: 20\n    },\n    node: {\n      width: 80,\n      height: 20,\n      labelOffset: 10,\n      maxLabelWidth: 40\n    },\n    bridge: {\n      width: 5,\n      height: 5,\n      radius: 2,\n      labelOffset: 0\n    }\n  }\n};\n\nfunction n() {\n  var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e;\n  var r, o, i, a;\n  var u = JSON.parse(JSON.stringify(t)),\n      c = (null === (r = null == n ? void 0 : n.graph) || void 0 === r ? void 0 : r.meta) || {},\n      s = (null === (o = null == n ? void 0 : n.subScene) || void 0 === o ? void 0 : o.meta) || {},\n      d = (null === (i = null == n ? void 0 : n.nodeSize) || void 0 === i ? void 0 : i.meta) || {},\n      f = (null === (a = null == n ? void 0 : n.nodeSize) || void 0 === a ? void 0 : a.node) || {},\n      h = u.nodeSize.bridge;\n  return {\n    graph: {\n      meta: Object.assign(u.graph.meta, c)\n    },\n    subScene: {\n      meta: Object.assign(u.subScene.meta, s)\n    },\n    nodeSize: {\n      meta: Object.assign(u.nodeSize.meta, d),\n      node: Object.assign(u.nodeSize.node, f),\n      bridge: h\n    }\n  };\n}\n\nfunction t(e) {\n  return \"\\u25EC\".concat(e, \"\\u25EC\");\n}\n\nvar r = t(\"ROOT\"),\n    o = t(\"BRIDGE_GRAPH\");\nvar i, a, u, c;\n!function (e) {\n  e[e.META = 0] = \"META\", e[e.NODE = 1] = \"NODE\", e[e.BRIDGE = 2] = \"BRIDGE\";\n}(i || (i = {})), function (e) {\n  e[e.INCLUDE = 0] = \"INCLUDE\", e[e.EXCLUDE = 1] = \"EXCLUDE\", e[e.UNSPECIFIED = 2] = \"UNSPECIFIED\";\n}(a || (a = {})), function (e) {\n  e[e.META = 0] = \"META\", e[e.CORE = 1] = \"CORE\", e[e.BRIDGE = 2] = \"BRIDGE\";\n}(u || (u = {})), function (e) {\n  e[e.META = 0] = \"META\", e[e.OP = 1] = \"OP\", e[e.SERIES = 2] = \"SERIES\";\n}(c || (c = {}));\nvar s = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\n\nfunction d(e, n) {\n  return e(n = {\n    exports: {}\n  }, n.exports), n.exports;\n}\n\nvar f = function f() {\n  this.__data__ = [], this.size = 0;\n};\n\nvar h = function h(e, n) {\n  return e === n || e != e && n != n;\n};\n\nvar l = function l(e, n) {\n  for (var t = e.length; t--;) {\n    if (h(e[t][0], n)) return t;\n  }\n\n  return -1;\n},\n    v = Array.prototype.splice;\n\nvar p = function p(e) {\n  var n = this.__data__,\n      t = l(n, e);\n  return !(t < 0) && (t == n.length - 1 ? n.pop() : v.call(n, t, 1), --this.size, !0);\n};\n\nvar g = function g(e) {\n  var n = this.__data__,\n      t = l(n, e);\n  return t < 0 ? void 0 : n[t][1];\n};\n\nvar y = function y(e) {\n  return l(this.__data__, e) > -1;\n};\n\nvar b = function b(e, n) {\n  var t = this.__data__,\n      r = l(t, e);\n  return r < 0 ? (++this.size, t.push([e, n])) : t[r][1] = n, this;\n};\n\nfunction m(e) {\n  var n = -1,\n      t = null == e ? 0 : e.length;\n\n  for (this.clear(); ++n < t;) {\n    var r = e[n];\n    this.set(r[0], r[1]);\n  }\n}\n\nm.prototype.clear = f, m.prototype.delete = p, m.prototype.get = g, m.prototype.has = y, m.prototype.set = b;\nvar w = m;\n\nvar E = function E() {\n  this.__data__ = new w(), this.size = 0;\n};\n\nvar _ = function _(e) {\n  var n = this.__data__,\n      t = n.delete(e);\n  return this.size = n.size, t;\n};\n\nvar j = function j(e) {\n  return this.__data__.get(e);\n};\n\nvar x = function x(e) {\n  return this.__data__.has(e);\n},\n    N = \"object\" == typeof s && s && s.Object === Object && s,\n    O = \"object\" == typeof self && self && self.Object === Object && self,\n    k = N || O || Function(\"return this\")(),\n    I = k.Symbol,\n    S = Object.prototype,\n    M = S.hasOwnProperty,\n    C = S.toString,\n    G = I ? I.toStringTag : void 0;\n\nvar B = function B(e) {\n  var n = M.call(e, G),\n      t = e[G];\n\n  try {\n    e[G] = void 0;\n    var r = !0;\n  } catch (e) {}\n\n  var o = C.call(e);\n  return r && (n ? e[G] = t : delete e[G]), o;\n},\n    A = Object.prototype.toString;\n\nvar L = function L(e) {\n  return A.call(e);\n},\n    R = I ? I.toStringTag : void 0;\n\nvar T = function T(e) {\n  return null == e ? void 0 === e ? \"[object Undefined]\" : \"[object Null]\" : R && R in Object(e) ? B(e) : L(e);\n};\n\nvar D = function D(e) {\n  var n = typeof e;\n  return null != e && (\"object\" == n || \"function\" == n);\n};\n\nvar P,\n    z = function z(e) {\n  if (!D(e)) return !1;\n  var n = T(e);\n  return \"[object Function]\" == n || \"[object GeneratorFunction]\" == n || \"[object AsyncFunction]\" == n || \"[object Proxy]\" == n;\n},\n    F = k[\"__core-js_shared__\"],\n    U = (P = /[^.]+$/.exec(F && F.keys && F.keys.IE_PROTO || \"\")) ? \"Symbol(src)_1.\" + P : \"\";\n\nvar V = function V(e) {\n  return !!U && U in e;\n},\n    $ = Function.prototype.toString;\n\nvar H = function H(e) {\n  if (null != e) {\n    try {\n      return $.call(e);\n    } catch (e) {}\n\n    try {\n      return e + \"\";\n    } catch (e) {}\n  }\n\n  return \"\";\n},\n    W = /^\\[object .+?Constructor\\]$/,\n    q = Function.prototype,\n    Y = Object.prototype,\n    J = q.toString,\n    X = Y.hasOwnProperty,\n    K = RegExp(\"^\" + J.call(X).replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n\nvar Q = function Q(e) {\n  return !(!D(e) || V(e)) && (z(e) ? K : W).test(H(e));\n};\n\nvar Z = function Z(e, n) {\n  return null == e ? void 0 : e[n];\n};\n\nvar ee = function ee(e, n) {\n  var t = Z(e, n);\n  return Q(t) ? t : void 0;\n},\n    ne = ee(k, \"Map\"),\n    te = ee(Object, \"create\");\n\nvar re = function re() {\n  this.__data__ = te ? te(null) : {}, this.size = 0;\n};\n\nvar oe = function oe(e) {\n  var n = this.has(e) && delete this.__data__[e];\n  return this.size -= n ? 1 : 0, n;\n},\n    ie = Object.prototype.hasOwnProperty;\n\nvar ae = function ae(e) {\n  var n = this.__data__;\n\n  if (te) {\n    var t = n[e];\n    return \"__lodash_hash_undefined__\" === t ? void 0 : t;\n  }\n\n  return ie.call(n, e) ? n[e] : void 0;\n},\n    ue = Object.prototype.hasOwnProperty;\n\nvar ce = function ce(e) {\n  var n = this.__data__;\n  return te ? void 0 !== n[e] : ue.call(n, e);\n};\n\nvar se = function se(e, n) {\n  var t = this.__data__;\n  return this.size += this.has(e) ? 0 : 1, t[e] = te && void 0 === n ? \"__lodash_hash_undefined__\" : n, this;\n};\n\nfunction de(e) {\n  var n = -1,\n      t = null == e ? 0 : e.length;\n\n  for (this.clear(); ++n < t;) {\n    var r = e[n];\n    this.set(r[0], r[1]);\n  }\n}\n\nde.prototype.clear = re, de.prototype.delete = oe, de.prototype.get = ae, de.prototype.has = ce, de.prototype.set = se;\nvar fe = de;\n\nvar he = function he() {\n  this.size = 0, this.__data__ = {\n    hash: new fe(),\n    map: new (ne || w)(),\n    string: new fe()\n  };\n};\n\nvar le = function le(e) {\n  var n = typeof e;\n  return \"string\" == n || \"number\" == n || \"symbol\" == n || \"boolean\" == n ? \"__proto__\" !== e : null === e;\n};\n\nvar ve = function ve(e, n) {\n  var t = e.__data__;\n  return le(n) ? t[\"string\" == typeof n ? \"string\" : \"hash\"] : t.map;\n};\n\nvar pe = function pe(e) {\n  var n = ve(this, e).delete(e);\n  return this.size -= n ? 1 : 0, n;\n};\n\nvar ge = function ge(e) {\n  return ve(this, e).get(e);\n};\n\nvar ye = function ye(e) {\n  return ve(this, e).has(e);\n};\n\nvar be = function be(e, n) {\n  var t = ve(this, e),\n      r = t.size;\n  return t.set(e, n), this.size += t.size == r ? 0 : 1, this;\n};\n\nfunction me(e) {\n  var n = -1,\n      t = null == e ? 0 : e.length;\n\n  for (this.clear(); ++n < t;) {\n    var r = e[n];\n    this.set(r[0], r[1]);\n  }\n}\n\nme.prototype.clear = he, me.prototype.delete = pe, me.prototype.get = ge, me.prototype.has = ye, me.prototype.set = be;\nvar we = me;\n\nvar Ee = function Ee(e, n) {\n  var t = this.__data__;\n\n  if (t instanceof w) {\n    var r = t.__data__;\n    if (!ne || r.length < 199) return r.push([e, n]), this.size = ++t.size, this;\n    t = this.__data__ = new we(r);\n  }\n\n  return t.set(e, n), this.size = t.size, this;\n};\n\nfunction _e(e) {\n  var n = this.__data__ = new w(e);\n  this.size = n.size;\n}\n\n_e.prototype.clear = E, _e.prototype.delete = _, _e.prototype.get = j, _e.prototype.has = x, _e.prototype.set = Ee;\nvar je = _e;\n\nvar xe = function xe(e, n) {\n  for (var t = -1, r = null == e ? 0 : e.length; ++t < r && !1 !== n(e[t], t, e);) {\n    ;\n  }\n\n  return e;\n},\n    Ne = function () {\n  try {\n    var e = ee(Object, \"defineProperty\");\n    return e({}, \"\", {}), e;\n  } catch (e) {}\n}();\n\nvar Oe = function Oe(e, n, t) {\n  \"__proto__\" == n && Ne ? Ne(e, n, {\n    configurable: !0,\n    enumerable: !0,\n    value: t,\n    writable: !0\n  }) : e[n] = t;\n},\n    ke = Object.prototype.hasOwnProperty;\n\nvar Ie = function Ie(e, n, t) {\n  var r = e[n];\n  ke.call(e, n) && h(r, t) && (void 0 !== t || n in e) || Oe(e, n, t);\n};\n\nvar Se = function Se(e, n, t, r) {\n  var o = !t;\n  t || (t = {});\n\n  for (var i = -1, a = n.length; ++i < a;) {\n    var u = n[i],\n        c = r ? r(t[u], e[u], u, t, e) : void 0;\n    void 0 === c && (c = e[u]), o ? Oe(t, u, c) : Ie(t, u, c);\n  }\n\n  return t;\n};\n\nvar Me = function Me(e, n) {\n  for (var t = -1, r = Array(e); ++t < e;) {\n    r[t] = n(t);\n  }\n\n  return r;\n};\n\nvar Ce = function Ce(e) {\n  return null != e && \"object\" == typeof e;\n};\n\nvar Ge = function Ge(e) {\n  return Ce(e) && \"[object Arguments]\" == T(e);\n},\n    Be = Object.prototype,\n    Ae = Be.hasOwnProperty,\n    Le = Be.propertyIsEnumerable,\n    Re = Ge(function () {\n  return arguments;\n}()) ? Ge : function (e) {\n  return Ce(e) && Ae.call(e, \"callee\") && !Le.call(e, \"callee\");\n},\n    Te = Array.isArray;\n\nvar De = function De() {\n  return !1;\n},\n    Pe = d(function (e, n) {\n  var t = n && !n.nodeType && n,\n      r = t && e && !e.nodeType && e,\n      o = r && r.exports === t ? k.Buffer : void 0,\n      i = (o ? o.isBuffer : void 0) || De;\n  e.exports = i;\n}),\n    ze = /^(?:0|[1-9]\\d*)$/;\n\nvar Fe = function Fe(e, n) {\n  var t = typeof e;\n  return !!(n = null == n ? 9007199254740991 : n) && (\"number\" == t || \"symbol\" != t && ze.test(e)) && e > -1 && e % 1 == 0 && e < n;\n};\n\nvar Ue = function Ue(e) {\n  return \"number\" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991;\n},\n    Ve = {};\n\nVe[\"[object Float32Array]\"] = Ve[\"[object Float64Array]\"] = Ve[\"[object Int8Array]\"] = Ve[\"[object Int16Array]\"] = Ve[\"[object Int32Array]\"] = Ve[\"[object Uint8Array]\"] = Ve[\"[object Uint8ClampedArray]\"] = Ve[\"[object Uint16Array]\"] = Ve[\"[object Uint32Array]\"] = !0, Ve[\"[object Arguments]\"] = Ve[\"[object Array]\"] = Ve[\"[object ArrayBuffer]\"] = Ve[\"[object Boolean]\"] = Ve[\"[object DataView]\"] = Ve[\"[object Date]\"] = Ve[\"[object Error]\"] = Ve[\"[object Function]\"] = Ve[\"[object Map]\"] = Ve[\"[object Number]\"] = Ve[\"[object Object]\"] = Ve[\"[object RegExp]\"] = Ve[\"[object Set]\"] = Ve[\"[object String]\"] = Ve[\"[object WeakMap]\"] = !1;\n\nvar $e = function $e(e) {\n  return Ce(e) && Ue(e.length) && !!Ve[T(e)];\n};\n\nvar He = function He(e) {\n  return function (n) {\n    return e(n);\n  };\n},\n    We = d(function (e, n) {\n  var t = n && !n.nodeType && n,\n      r = t && e && !e.nodeType && e,\n      o = r && r.exports === t && N.process,\n      i = function () {\n    try {\n      var e = r && r.require && r.require(\"util\").types;\n\n      return e || o && o.binding && o.binding(\"util\");\n    } catch (e) {}\n  }();\n\n  e.exports = i;\n}),\n    qe = We && We.isTypedArray,\n    Ye = qe ? He(qe) : $e,\n    Je = Object.prototype.hasOwnProperty;\n\nvar Xe = function Xe(e, n) {\n  var t = Te(e),\n      r = !t && Re(e),\n      o = !t && !r && Pe(e),\n      i = !t && !r && !o && Ye(e),\n      a = t || r || o || i,\n      u = a ? Me(e.length, String) : [],\n      c = u.length;\n\n  for (var s in e) {\n    !n && !Je.call(e, s) || a && (\"length\" == s || o && (\"offset\" == s || \"parent\" == s) || i && (\"buffer\" == s || \"byteLength\" == s || \"byteOffset\" == s) || Fe(s, c)) || u.push(s);\n  }\n\n  return u;\n},\n    Ke = Object.prototype;\n\nvar Qe = function Qe(e) {\n  var n = e && e.constructor;\n  return e === (\"function\" == typeof n && n.prototype || Ke);\n};\n\nvar Ze = function Ze(e, n) {\n  return function (t) {\n    return e(n(t));\n  };\n},\n    en = Ze(Object.keys, Object),\n    nn = Object.prototype.hasOwnProperty;\n\nvar tn = function tn(e) {\n  if (!Qe(e)) return en(e);\n  var n = [];\n\n  for (var t in Object(e)) {\n    nn.call(e, t) && \"constructor\" != t && n.push(t);\n  }\n\n  return n;\n};\n\nvar rn = function rn(e) {\n  return null != e && Ue(e.length) && !z(e);\n};\n\nvar on = function on(e) {\n  return rn(e) ? Xe(e) : tn(e);\n};\n\nvar an = function an(e, n) {\n  return e && Se(n, on(n), e);\n};\n\nvar un = function un(e) {\n  var n = [];\n  if (null != e) for (var t in Object(e)) {\n    n.push(t);\n  }\n  return n;\n},\n    cn = Object.prototype.hasOwnProperty;\n\nvar sn = function sn(e) {\n  if (!D(e)) return un(e);\n  var n = Qe(e),\n      t = [];\n\n  for (var r in e) {\n    (\"constructor\" != r || !n && cn.call(e, r)) && t.push(r);\n  }\n\n  return t;\n};\n\nvar dn = function dn(e) {\n  return rn(e) ? Xe(e, !0) : sn(e);\n};\n\nvar fn = function fn(e, n) {\n  return e && Se(n, dn(n), e);\n},\n    hn = d(function (e, n) {\n  var t = n && !n.nodeType && n,\n      r = t && e && !e.nodeType && e,\n      o = r && r.exports === t ? k.Buffer : void 0,\n      i = o ? o.allocUnsafe : void 0;\n\n  e.exports = function (e, n) {\n    if (n) return e.slice();\n    var t = e.length,\n        r = i ? i(t) : new e.constructor(t);\n    return e.copy(r), r;\n  };\n});\n\nvar ln = function ln(e, n) {\n  var t = -1,\n      r = e.length;\n\n  for (n || (n = Array(r)); ++t < r;) {\n    n[t] = e[t];\n  }\n\n  return n;\n};\n\nvar vn = function vn(e, n) {\n  for (var t = -1, r = null == e ? 0 : e.length, o = 0, i = []; ++t < r;) {\n    var a = e[t];\n    n(a, t, e) && (i[o++] = a);\n  }\n\n  return i;\n};\n\nvar pn = function pn() {\n  return [];\n},\n    gn = Object.prototype.propertyIsEnumerable,\n    yn = Object.getOwnPropertySymbols,\n    bn = yn ? function (e) {\n  return null == e ? [] : (e = Object(e), vn(yn(e), function (n) {\n    return gn.call(e, n);\n  }));\n} : pn;\n\nvar mn = function mn(e, n) {\n  return Se(e, bn(e), n);\n};\n\nvar wn = function wn(e, n) {\n  for (var t = -1, r = n.length, o = e.length; ++t < r;) {\n    e[o + t] = n[t];\n  }\n\n  return e;\n},\n    En = Ze(Object.getPrototypeOf, Object),\n    _n = Object.getOwnPropertySymbols ? function (e) {\n  for (var n = []; e;) {\n    wn(n, bn(e)), e = En(e);\n  }\n\n  return n;\n} : pn;\n\nvar jn = function jn(e, n) {\n  return Se(e, _n(e), n);\n};\n\nvar xn = function xn(e, n, t) {\n  var r = n(e);\n  return Te(e) ? r : wn(r, t(e));\n};\n\nvar Nn = function Nn(e) {\n  return xn(e, on, bn);\n};\n\nvar On = function On(e) {\n  return xn(e, dn, _n);\n},\n    kn = ee(k, \"DataView\"),\n    In = ee(k, \"Promise\"),\n    Sn = ee(k, \"Set\"),\n    Mn = ee(k, \"WeakMap\"),\n    Cn = H(kn),\n    Gn = H(ne),\n    Bn = H(In),\n    An = H(Sn),\n    Ln = H(Mn),\n    Rn = T;\n\n(kn && \"[object DataView]\" != Rn(new kn(new ArrayBuffer(1))) || ne && \"[object Map]\" != Rn(new ne()) || In && \"[object Promise]\" != Rn(In.resolve()) || Sn && \"[object Set]\" != Rn(new Sn()) || Mn && \"[object WeakMap]\" != Rn(new Mn())) && (Rn = function Rn(e) {\n  var n = T(e),\n      t = \"[object Object]\" == n ? e.constructor : void 0,\n      r = t ? H(t) : \"\";\n  if (r) switch (r) {\n    case Cn:\n      return \"[object DataView]\";\n\n    case Gn:\n      return \"[object Map]\";\n\n    case Bn:\n      return \"[object Promise]\";\n\n    case An:\n      return \"[object Set]\";\n\n    case Ln:\n      return \"[object WeakMap]\";\n  }\n  return n;\n});\nvar Tn = Rn,\n    Dn = Object.prototype.hasOwnProperty;\n\nvar Pn = function Pn(e) {\n  var n = e.length,\n      t = new e.constructor(n);\n  return n && \"string\" == typeof e[0] && Dn.call(e, \"index\") && (t.index = e.index, t.input = e.input), t;\n},\n    zn = k.Uint8Array;\n\nvar Fn = function Fn(e) {\n  var n = new e.constructor(e.byteLength);\n  return new zn(n).set(new zn(e)), n;\n};\n\nvar Un = function Un(e, n) {\n  var t = n ? Fn(e.buffer) : e.buffer;\n  return new e.constructor(t, e.byteOffset, e.byteLength);\n},\n    Vn = /\\w*$/;\n\nvar $n = function $n(e) {\n  var n = new e.constructor(e.source, Vn.exec(e));\n  return n.lastIndex = e.lastIndex, n;\n},\n    Hn = I ? I.prototype : void 0,\n    Wn = Hn ? Hn.valueOf : void 0;\n\nvar qn = function qn(e) {\n  return Wn ? Object(Wn.call(e)) : {};\n};\n\nvar Yn = function Yn(e, n) {\n  var t = n ? Fn(e.buffer) : e.buffer;\n  return new e.constructor(t, e.byteOffset, e.length);\n};\n\nvar Jn = function Jn(e, n, t) {\n  var r = e.constructor;\n\n  switch (n) {\n    case \"[object ArrayBuffer]\":\n      return Fn(e);\n\n    case \"[object Boolean]\":\n    case \"[object Date]\":\n      return new r(+e);\n\n    case \"[object DataView]\":\n      return Un(e, t);\n\n    case \"[object Float32Array]\":\n    case \"[object Float64Array]\":\n    case \"[object Int8Array]\":\n    case \"[object Int16Array]\":\n    case \"[object Int32Array]\":\n    case \"[object Uint8Array]\":\n    case \"[object Uint8ClampedArray]\":\n    case \"[object Uint16Array]\":\n    case \"[object Uint32Array]\":\n      return Yn(e, t);\n\n    case \"[object Map]\":\n      return new r();\n\n    case \"[object Number]\":\n    case \"[object String]\":\n      return new r(e);\n\n    case \"[object RegExp]\":\n      return $n(e);\n\n    case \"[object Set]\":\n      return new r();\n\n    case \"[object Symbol]\":\n      return qn(e);\n  }\n},\n    Xn = Object.create,\n    Kn = function () {\n  function e() {}\n\n  return function (n) {\n    if (!D(n)) return {};\n    if (Xn) return Xn(n);\n    e.prototype = n;\n    var t = new e();\n    return e.prototype = void 0, t;\n  };\n}();\n\nvar Qn = function Qn(e) {\n  return \"function\" != typeof e.constructor || Qe(e) ? {} : Kn(En(e));\n};\n\nvar Zn = function Zn(e) {\n  return Ce(e) && \"[object Map]\" == Tn(e);\n},\n    et = We && We.isMap,\n    nt = et ? He(et) : Zn;\n\nvar tt = function tt(e) {\n  return Ce(e) && \"[object Set]\" == Tn(e);\n},\n    rt = We && We.isSet,\n    ot = rt ? He(rt) : tt,\n    it = {};\n\nit[\"[object Arguments]\"] = it[\"[object Array]\"] = it[\"[object ArrayBuffer]\"] = it[\"[object DataView]\"] = it[\"[object Boolean]\"] = it[\"[object Date]\"] = it[\"[object Float32Array]\"] = it[\"[object Float64Array]\"] = it[\"[object Int8Array]\"] = it[\"[object Int16Array]\"] = it[\"[object Int32Array]\"] = it[\"[object Map]\"] = it[\"[object Number]\"] = it[\"[object Object]\"] = it[\"[object RegExp]\"] = it[\"[object Set]\"] = it[\"[object String]\"] = it[\"[object Symbol]\"] = it[\"[object Uint8Array]\"] = it[\"[object Uint8ClampedArray]\"] = it[\"[object Uint16Array]\"] = it[\"[object Uint32Array]\"] = !0, it[\"[object Error]\"] = it[\"[object Function]\"] = it[\"[object WeakMap]\"] = !1;\n\nvar at = function e(n, t, r, o, i, a) {\n  var u,\n      c = 1 & t,\n      s = 2 & t,\n      d = 4 & t;\n  if (r && (u = i ? r(n, o, i, a) : r(n)), void 0 !== u) return u;\n  if (!D(n)) return n;\n  var f = Te(n);\n\n  if (f) {\n    if (u = Pn(n), !c) return ln(n, u);\n  } else {\n    var h = Tn(n),\n        l = \"[object Function]\" == h || \"[object GeneratorFunction]\" == h;\n    if (Pe(n)) return hn(n, c);\n\n    if (\"[object Object]\" == h || \"[object Arguments]\" == h || l && !i) {\n      if (u = s || l ? {} : Qn(n), !c) return s ? jn(n, fn(u, n)) : mn(n, an(u, n));\n    } else {\n      if (!it[h]) return i ? n : {};\n      u = Jn(n, h, c);\n    }\n  }\n\n  a || (a = new je());\n  var v = a.get(n);\n  if (v) return v;\n  a.set(n, u), ot(n) ? n.forEach(function (o) {\n    u.add(e(o, t, r, o, n, a));\n  }) : nt(n) && n.forEach(function (o, i) {\n    u.set(i, e(o, t, r, i, n, a));\n  });\n  var p = f ? void 0 : (d ? s ? On : Nn : s ? dn : on)(n);\n  return xe(p || n, function (o, i) {\n    p && (o = n[i = o]), Ie(u, i, e(o, t, r, i, n, a));\n  }), u;\n};\n\nvar ut = function ut(e) {\n  return at(e, 4);\n};\n\nvar ct = function ct(e) {\n  return function () {\n    return e;\n  };\n};\n\nvar st = function (e) {\n  return function (n, t, r) {\n    for (var o = -1, i = Object(n), a = r(n), u = a.length; u--;) {\n      var c = a[e ? u : ++o];\n      if (!1 === t(i[c], c, i)) break;\n    }\n\n    return n;\n  };\n}();\n\nvar dt = function dt(e, n) {\n  return e && st(e, n, on);\n};\n\nvar ft = function (e, n) {\n  return function (t, r) {\n    if (null == t) return t;\n    if (!rn(t)) return e(t, r);\n\n    for (var o = t.length, i = n ? o : -1, a = Object(t); (n ? i-- : ++i < o) && !1 !== r(a[i], i, a);) {\n      ;\n    }\n\n    return t;\n  };\n}(dt);\n\nvar ht = function ht(e) {\n  return e;\n};\n\nvar lt = function lt(e) {\n  return \"function\" == typeof e ? e : ht;\n};\n\nvar vt = function vt(e, n) {\n  return (Te(e) ? xe : ft)(e, lt(n));\n},\n    pt = vt;\n\nvar gt = function gt(e, n) {\n  var t = [];\n  return ft(e, function (e, r, o) {\n    n(e, r, o) && t.push(e);\n  }), t;\n};\n\nvar yt = function yt(e) {\n  return this.__data__.set(e, \"__lodash_hash_undefined__\"), this;\n};\n\nvar bt = function bt(e) {\n  return this.__data__.has(e);\n};\n\nfunction mt(e) {\n  var n = -1,\n      t = null == e ? 0 : e.length;\n\n  for (this.__data__ = new we(); ++n < t;) {\n    this.add(e[n]);\n  }\n}\n\nmt.prototype.add = mt.prototype.push = yt, mt.prototype.has = bt;\nvar wt = mt;\n\nvar Et = function Et(e, n) {\n  for (var t = -1, r = null == e ? 0 : e.length; ++t < r;) {\n    if (n(e[t], t, e)) return !0;\n  }\n\n  return !1;\n};\n\nvar _t = function _t(e, n) {\n  return e.has(n);\n};\n\nvar jt = function jt(e, n, t, r, o, i) {\n  var a = 1 & t,\n      u = e.length,\n      c = n.length;\n  if (u != c && !(a && c > u)) return !1;\n  var s = i.get(e),\n      d = i.get(n);\n  if (s && d) return s == n && d == e;\n  var f = -1,\n      h = !0,\n      l = 2 & t ? new wt() : void 0;\n\n  for (i.set(e, n), i.set(n, e); ++f < u;) {\n    var v = e[f],\n        p = n[f];\n    if (r) var g = a ? r(p, v, f, n, e, i) : r(v, p, f, e, n, i);\n\n    if (void 0 !== g) {\n      if (g) continue;\n      h = !1;\n      break;\n    }\n\n    if (l) {\n      if (!Et(n, function (e, n) {\n        if (!_t(l, n) && (v === e || o(v, e, t, r, i))) return l.push(n);\n      })) {\n        h = !1;\n        break;\n      }\n    } else if (v !== p && !o(v, p, t, r, i)) {\n      h = !1;\n      break;\n    }\n  }\n\n  return i.delete(e), i.delete(n), h;\n};\n\nvar xt = function xt(e) {\n  var n = -1,\n      t = Array(e.size);\n  return e.forEach(function (e, r) {\n    t[++n] = [r, e];\n  }), t;\n};\n\nvar Nt = function Nt(e) {\n  var n = -1,\n      t = Array(e.size);\n  return e.forEach(function (e) {\n    t[++n] = e;\n  }), t;\n},\n    Ot = I ? I.prototype : void 0,\n    kt = Ot ? Ot.valueOf : void 0;\n\nvar It = function It(e, n, t, r, o, i, a) {\n  switch (t) {\n    case \"[object DataView]\":\n      if (e.byteLength != n.byteLength || e.byteOffset != n.byteOffset) return !1;\n      e = e.buffer, n = n.buffer;\n\n    case \"[object ArrayBuffer]\":\n      return !(e.byteLength != n.byteLength || !i(new zn(e), new zn(n)));\n\n    case \"[object Boolean]\":\n    case \"[object Date]\":\n    case \"[object Number]\":\n      return h(+e, +n);\n\n    case \"[object Error]\":\n      return e.name == n.name && e.message == n.message;\n\n    case \"[object RegExp]\":\n    case \"[object String]\":\n      return e == n + \"\";\n\n    case \"[object Map]\":\n      var u = xt;\n\n    case \"[object Set]\":\n      var c = 1 & r;\n      if (u || (u = Nt), e.size != n.size && !c) return !1;\n      var s = a.get(e);\n      if (s) return s == n;\n      r |= 2, a.set(e, n);\n      var d = jt(u(e), u(n), r, o, i, a);\n      return a.delete(e), d;\n\n    case \"[object Symbol]\":\n      if (kt) return kt.call(e) == kt.call(n);\n  }\n\n  return !1;\n},\n    St = Object.prototype.hasOwnProperty;\n\nvar Mt = function Mt(e, n, t, r, o, i) {\n  var a = 1 & t,\n      u = Nn(e),\n      c = u.length;\n  if (c != Nn(n).length && !a) return !1;\n\n  for (var s = c; s--;) {\n    var d = u[s];\n    if (!(a ? d in n : St.call(n, d))) return !1;\n  }\n\n  var f = i.get(e),\n      h = i.get(n);\n  if (f && h) return f == n && h == e;\n  var l = !0;\n  i.set(e, n), i.set(n, e);\n\n  for (var v = a; ++s < c;) {\n    var p = e[d = u[s]],\n        g = n[d];\n    if (r) var y = a ? r(g, p, d, n, e, i) : r(p, g, d, e, n, i);\n\n    if (!(void 0 === y ? p === g || o(p, g, t, r, i) : y)) {\n      l = !1;\n      break;\n    }\n\n    v || (v = \"constructor\" == d);\n  }\n\n  if (l && !v) {\n    var b = e.constructor,\n        m = n.constructor;\n    b == m || !(\"constructor\" in e) || !(\"constructor\" in n) || \"function\" == typeof b && b instanceof b && \"function\" == typeof m && m instanceof m || (l = !1);\n  }\n\n  return i.delete(e), i.delete(n), l;\n},\n    Ct = Object.prototype.hasOwnProperty;\n\nvar Gt = function Gt(e, n, t, r, o, i) {\n  var a = Te(e),\n      u = Te(n),\n      c = a ? \"[object Array]\" : Tn(e),\n      s = u ? \"[object Array]\" : Tn(n),\n      d = \"[object Object]\" == (c = \"[object Arguments]\" == c ? \"[object Object]\" : c),\n      f = \"[object Object]\" == (s = \"[object Arguments]\" == s ? \"[object Object]\" : s),\n      h = c == s;\n\n  if (h && Pe(e)) {\n    if (!Pe(n)) return !1;\n    a = !0, d = !1;\n  }\n\n  if (h && !d) return i || (i = new je()), a || Ye(e) ? jt(e, n, t, r, o, i) : It(e, n, c, t, r, o, i);\n\n  if (!(1 & t)) {\n    var l = d && Ct.call(e, \"__wrapped__\"),\n        v = f && Ct.call(n, \"__wrapped__\");\n\n    if (l || v) {\n      var p = l ? e.value() : e,\n          g = v ? n.value() : n;\n      return i || (i = new je()), o(p, g, t, r, i);\n    }\n  }\n\n  return !!h && (i || (i = new je()), Mt(e, n, t, r, o, i));\n};\n\nvar Bt = function e(n, t, r, o, i) {\n  return n === t || (null == n || null == t || !Ce(n) && !Ce(t) ? n != n && t != t : Gt(n, t, r, o, e, i));\n};\n\nvar At = function At(e, n, t, r) {\n  var o = t.length,\n      i = o,\n      a = !r;\n  if (null == e) return !i;\n\n  for (e = Object(e); o--;) {\n    var u = t[o];\n    if (a && u[2] ? u[1] !== e[u[0]] : !(u[0] in e)) return !1;\n  }\n\n  for (; ++o < i;) {\n    var c = (u = t[o])[0],\n        s = e[c],\n        d = u[1];\n\n    if (a && u[2]) {\n      if (void 0 === s && !(c in e)) return !1;\n    } else {\n      var f = new je();\n      if (r) var h = r(s, d, c, e, n, f);\n      if (!(void 0 === h ? Bt(d, s, 3, r, f) : h)) return !1;\n    }\n  }\n\n  return !0;\n};\n\nvar Lt = function Lt(e) {\n  return e == e && !D(e);\n};\n\nvar Rt = function Rt(e) {\n  for (var n = on(e), t = n.length; t--;) {\n    var r = n[t],\n        o = e[r];\n    n[t] = [r, o, Lt(o)];\n  }\n\n  return n;\n};\n\nvar Tt = function Tt(e, n) {\n  return function (t) {\n    return null != t && t[e] === n && (void 0 !== n || e in Object(t));\n  };\n};\n\nvar Dt = function Dt(e) {\n  var n = Rt(e);\n  return 1 == n.length && n[0][2] ? Tt(n[0][0], n[0][1]) : function (t) {\n    return t === e || At(t, e, n);\n  };\n};\n\nvar Pt = function Pt(e) {\n  return \"symbol\" == typeof e || Ce(e) && \"[object Symbol]\" == T(e);\n},\n    zt = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    Ft = /^\\w*$/;\n\nvar Ut = function Ut(e, n) {\n  if (Te(e)) return !1;\n  var t = typeof e;\n  return !(\"number\" != t && \"symbol\" != t && \"boolean\" != t && null != e && !Pt(e)) || Ft.test(e) || !zt.test(e) || null != n && e in Object(n);\n};\n\nfunction Vt(e, n) {\n  if (\"function\" != typeof e || null != n && \"function\" != typeof n) throw new TypeError(\"Expected a function\");\n\n  var t = function t() {\n    var r = arguments,\n        o = n ? n.apply(this, r) : r[0],\n        i = t.cache;\n    if (i.has(o)) return i.get(o);\n    var a = e.apply(this, r);\n    return t.cache = i.set(o, a) || i, a;\n  };\n\n  return t.cache = new (Vt.Cache || we)(), t;\n}\n\nVt.Cache = we;\nvar $t = Vt;\n\nvar Ht = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n    Wt = /\\\\(\\\\)?/g,\n    qt = function (e) {\n  var n = $t(e, function (e) {\n    return 500 === t.size && t.clear(), e;\n  }),\n      t = n.cache;\n  return n;\n}(function (e) {\n  var n = [];\n  return 46 === e.charCodeAt(0) && n.push(\"\"), e.replace(Ht, function (e, t, r, o) {\n    n.push(r ? o.replace(Wt, \"$1\") : t || e);\n  }), n;\n});\n\nvar Yt = function Yt(e, n) {\n  for (var t = -1, r = null == e ? 0 : e.length, o = Array(r); ++t < r;) {\n    o[t] = n(e[t], t, e);\n  }\n\n  return o;\n},\n    Jt = I ? I.prototype : void 0,\n    Xt = Jt ? Jt.toString : void 0;\n\nvar Kt = function e(n) {\n  if (\"string\" == typeof n) return n;\n  if (Te(n)) return Yt(n, e) + \"\";\n  if (Pt(n)) return Xt ? Xt.call(n) : \"\";\n  var t = n + \"\";\n  return \"0\" == t && 1 / n == -Infinity ? \"-0\" : t;\n};\n\nvar Qt = function Qt(e) {\n  return null == e ? \"\" : Kt(e);\n};\n\nvar Zt = function Zt(e, n) {\n  return Te(e) ? e : Ut(e, n) ? [e] : qt(Qt(e));\n};\n\nvar er = function er(e) {\n  if (\"string\" == typeof e || Pt(e)) return e;\n  var n = e + \"\";\n  return \"0\" == n && 1 / e == -Infinity ? \"-0\" : n;\n};\n\nvar nr = function nr(e, n) {\n  for (var t = 0, r = (n = Zt(n, e)).length; null != e && t < r;) {\n    e = e[er(n[t++])];\n  }\n\n  return t && t == r ? e : void 0;\n};\n\nvar tr = function tr(e, n, t) {\n  var r = null == e ? void 0 : nr(e, n);\n  return void 0 === r ? t : r;\n};\n\nvar rr = function rr(e, n) {\n  return null != e && n in Object(e);\n};\n\nvar or = function or(e, n, t) {\n  for (var r = -1, o = (n = Zt(n, e)).length, i = !1; ++r < o;) {\n    var a = er(n[r]);\n    if (!(i = null != e && t(e, a))) break;\n    e = e[a];\n  }\n\n  return i || ++r != o ? i : !!(o = null == e ? 0 : e.length) && Ue(o) && Fe(a, o) && (Te(e) || Re(e));\n};\n\nvar ir = function ir(e, n) {\n  return null != e && or(e, n, rr);\n};\n\nvar ar = function ar(e, n) {\n  return Ut(e) && Lt(n) ? Tt(er(e), n) : function (t) {\n    var r = tr(t, e);\n    return void 0 === r && r === n ? ir(t, e) : Bt(n, r, 3);\n  };\n};\n\nvar ur = function ur(e) {\n  return function (n) {\n    return null == n ? void 0 : n[e];\n  };\n};\n\nvar cr = function cr(e) {\n  return function (n) {\n    return nr(n, e);\n  };\n};\n\nvar sr = function sr(e) {\n  return Ut(e) ? ur(er(e)) : cr(e);\n};\n\nvar dr = function dr(e) {\n  return \"function\" == typeof e ? e : null == e ? ht : \"object\" == typeof e ? Te(e) ? ar(e[0], e[1]) : Dt(e) : sr(e);\n};\n\nvar fr = function fr(e, n) {\n  return (Te(e) ? vn : gt)(e, dr(n));\n},\n    hr = Object.prototype.hasOwnProperty;\n\nvar lr = function lr(e, n) {\n  return null != e && hr.call(e, n);\n};\n\nvar vr = function vr(e, n) {\n  return null != e && or(e, n, lr);\n},\n    pr = Object.prototype.hasOwnProperty;\n\nvar gr = function gr(e) {\n  if (null == e) return !0;\n  if (rn(e) && (Te(e) || \"string\" == typeof e || \"function\" == typeof e.splice || Pe(e) || Ye(e) || Re(e))) return !e.length;\n  var n = Tn(e);\n  if (\"[object Map]\" == n || \"[object Set]\" == n) return !e.size;\n  if (Qe(e)) return !tn(e).length;\n\n  for (var t in e) {\n    if (pr.call(e, t)) return !1;\n  }\n\n  return !0;\n};\n\nvar yr = function yr(e) {\n  return void 0 === e;\n};\n\nvar br = function br(e, n) {\n  var t = -1,\n      r = rn(e) ? Array(e.length) : [];\n  return ft(e, function (e, o, i) {\n    r[++t] = n(e, o, i);\n  }), r;\n};\n\nvar mr = function mr(e, n) {\n  return (Te(e) ? Yt : br)(e, dr(n));\n};\n\nvar wr = function wr(e, n, t, r) {\n  var o = -1,\n      i = null == e ? 0 : e.length;\n\n  for (r && i && (t = e[++o]); ++o < i;) {\n    t = n(t, e[o], o, e);\n  }\n\n  return t;\n};\n\nvar Er = function Er(e, n, t, r, o) {\n  return o(e, function (e, o, i) {\n    t = r ? (r = !1, e) : n(t, e, o, i);\n  }), t;\n};\n\nvar _r = function _r(e, n, t) {\n  var r = Te(e) ? wr : Er,\n      o = arguments.length < 3;\n  return r(e, dr(n), t, o, ft);\n};\n\nvar jr = function jr(e) {\n  return \"string\" == typeof e || !Te(e) && Ce(e) && \"[object String]\" == T(e);\n},\n    xr = ur(\"length\"),\n    Nr = RegExp(\"[\\\\u200d\\\\ud800-\\\\udfff\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe2f\\\\u20d0-\\\\u20ff\\\\ufe0e\\\\ufe0f]\");\n\nvar Or = function Or(e) {\n  return Nr.test(e);\n},\n    kr = \"[\\\\ud800-\\\\udfff]\",\n    Ir = \"[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe2f\\\\u20d0-\\\\u20ff]\",\n    Sr = \"\\\\ud83c[\\\\udffb-\\\\udfff]\",\n    Mr = \"[^\\\\ud800-\\\\udfff]\",\n    Cr = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\",\n    Gr = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\",\n    Br = \"(?:\" + Ir + \"|\" + Sr + \")\" + \"?\",\n    Ar = \"[\\\\ufe0e\\\\ufe0f]?\" + Br + (\"(?:\\\\u200d(?:\" + [Mr, Cr, Gr].join(\"|\") + \")[\\\\ufe0e\\\\ufe0f]?\" + Br + \")*\"),\n    Lr = \"(?:\" + [Mr + Ir + \"?\", Ir, Cr, Gr, kr].join(\"|\") + \")\",\n    Rr = RegExp(Sr + \"(?=\" + Sr + \")|\" + Lr + Ar, \"g\");\n\nvar Tr = function Tr(e) {\n  for (var n = Rr.lastIndex = 0; Rr.test(e);) {\n    ++n;\n  }\n\n  return n;\n};\n\nvar Dr = function Dr(e) {\n  return Or(e) ? Tr(e) : xr(e);\n};\n\nvar Pr = function Pr(e) {\n  if (null == e) return 0;\n  if (rn(e)) return jr(e) ? Dr(e) : e.length;\n  var n = Tn(e);\n  return \"[object Map]\" == n || \"[object Set]\" == n ? e.size : tn(e).length;\n};\n\nvar zr = function zr(e, n, t) {\n  var r = Te(e),\n      o = r || Pe(e) || Ye(e);\n\n  if (n = dr(n), null == t) {\n    var i = e && e.constructor;\n    t = o ? r ? new i() : [] : D(e) && z(i) ? Kn(En(e)) : {};\n  }\n\n  return (o ? xe : dt)(e, function (e, r, o) {\n    return n(t, e, r, o);\n  }), t;\n},\n    Fr = I ? I.isConcatSpreadable : void 0;\n\nvar Ur = function Ur(e) {\n  return Te(e) || Re(e) || !!(Fr && e && e[Fr]);\n};\n\nvar Vr = function e(n, t, r, o, i) {\n  var a = -1,\n      u = n.length;\n\n  for (r || (r = Ur), i || (i = []); ++a < u;) {\n    var c = n[a];\n    t > 0 && r(c) ? t > 1 ? e(c, t - 1, r, o, i) : wn(i, c) : o || (i[i.length] = c);\n  }\n\n  return i;\n};\n\nvar $r = function $r(e, n, t) {\n  switch (t.length) {\n    case 0:\n      return e.call(n);\n\n    case 1:\n      return e.call(n, t[0]);\n\n    case 2:\n      return e.call(n, t[0], t[1]);\n\n    case 3:\n      return e.call(n, t[0], t[1], t[2]);\n  }\n\n  return e.apply(n, t);\n},\n    Hr = Math.max;\n\nvar Wr = function Wr(e, n, t) {\n  return n = Hr(void 0 === n ? e.length - 1 : n, 0), function () {\n    for (var r = arguments, o = -1, i = Hr(r.length - n, 0), a = Array(i); ++o < i;) {\n      a[o] = r[n + o];\n    }\n\n    o = -1;\n\n    for (var u = Array(n + 1); ++o < n;) {\n      u[o] = r[o];\n    }\n\n    return u[n] = t(a), $r(e, this, u);\n  };\n},\n    qr = Ne ? function (e, n) {\n  return Ne(e, \"toString\", {\n    configurable: !0,\n    enumerable: !1,\n    value: ct(n),\n    writable: !0\n  });\n} : ht,\n    Yr = Date.now;\n\nvar Jr = function (e) {\n  var n = 0,\n      t = 0;\n  return function () {\n    var r = Yr(),\n        o = 16 - (r - t);\n\n    if (t = r, o > 0) {\n      if (++n >= 800) return arguments[0];\n    } else n = 0;\n\n    return e.apply(void 0, arguments);\n  };\n}(qr);\n\nvar Xr = function Xr(e, n) {\n  return Jr(Wr(e, n, ht), e + \"\");\n};\n\nvar Kr = function Kr(e, n, t, r) {\n  for (var o = e.length, i = t + (r ? 1 : -1); r ? i-- : ++i < o;) {\n    if (n(e[i], i, e)) return i;\n  }\n\n  return -1;\n};\n\nvar Qr = function Qr(e) {\n  return e != e;\n};\n\nvar Zr = function Zr(e, n, t) {\n  for (var r = t - 1, o = e.length; ++r < o;) {\n    if (e[r] === n) return r;\n  }\n\n  return -1;\n};\n\nvar eo = function eo(e, n, t) {\n  return n == n ? Zr(e, n, t) : Kr(e, Qr, t);\n};\n\nvar no = function no(e, n) {\n  return !!(null == e ? 0 : e.length) && eo(e, n, 0) > -1;\n};\n\nvar to = function to(e, n, t) {\n  for (var r = -1, o = null == e ? 0 : e.length; ++r < o;) {\n    if (t(n, e[r])) return !0;\n  }\n\n  return !1;\n};\n\nvar ro = function ro() {},\n    oo = Sn && 1 / Nt(new Sn([, -0]))[1] == 1 / 0 ? function (e) {\n  return new Sn(e);\n} : ro;\n\nvar io = function io(e, n, t) {\n  var r = -1,\n      o = no,\n      i = e.length,\n      a = !0,\n      u = [],\n      c = u;\n  if (t) a = !1, o = to;else if (i >= 200) {\n    var s = n ? null : oo(e);\n    if (s) return Nt(s);\n    a = !1, o = _t, c = new wt();\n  } else c = n ? [] : u;\n\n  e: for (; ++r < i;) {\n    var d = e[r],\n        f = n ? n(d) : d;\n\n    if (d = t || 0 !== d ? d : 0, a && f == f) {\n      for (var h = c.length; h--;) {\n        if (c[h] === f) continue e;\n      }\n\n      n && c.push(f), u.push(d);\n    } else o(c, f, t) || (c !== u && c.push(f), u.push(d));\n  }\n\n  return u;\n};\n\nvar ao = function ao(e) {\n  return Ce(e) && rn(e);\n},\n    uo = Xr(function (e) {\n  return io(Vr(e, 1, ao, !0));\n});\n\nvar co = function co(e, n) {\n  return Yt(n, function (n) {\n    return e[n];\n  });\n};\n\nvar so,\n    fo = function fo(e) {\n  return null == e ? [] : co(e, on(e));\n};\n\ntry {\n  so = {\n    clone: ut,\n    constant: ct,\n    each: pt,\n    filter: fr,\n    has: vr,\n    isArray: Te,\n    isEmpty: gr,\n    isFunction: z,\n    isUndefined: yr,\n    keys: on,\n    map: mr,\n    reduce: _r,\n    size: Pr,\n    transform: zr,\n    union: uo,\n    values: fo\n  };\n} catch (e) {}\n\nso || (so = window._);\nvar ho = so,\n    lo = vo;\n\nfunction vo(e) {\n  this._isDirected = !ho.has(e, \"directed\") || e.directed, this._isMultigraph = !!ho.has(e, \"multigraph\") && e.multigraph, this._isCompound = !!ho.has(e, \"compound\") && e.compound, this._label = void 0, this._defaultNodeLabelFn = ho.constant(void 0), this._defaultEdgeLabelFn = ho.constant(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[\"\\0\"] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};\n}\n\nfunction po(e, n) {\n  e[n] ? e[n]++ : e[n] = 1;\n}\n\nfunction go(e, n) {\n  --e[n] || delete e[n];\n}\n\nfunction yo(e, n, t, r) {\n  var o = \"\" + n,\n      i = \"\" + t;\n\n  if (!e && o > i) {\n    var a = o;\n    o = i, i = a;\n  }\n\n  return o + \"\u0001\" + i + \"\u0001\" + (ho.isUndefined(r) ? \"\\0\" : r);\n}\n\nfunction bo(e, n, t, r) {\n  var o = \"\" + n,\n      i = \"\" + t;\n\n  if (!e && o > i) {\n    var a = o;\n    o = i, i = a;\n  }\n\n  var u = {\n    v: o,\n    w: i\n  };\n  return r && (u.name = r), u;\n}\n\nfunction mo(e, n) {\n  return yo(e, n.v, n.w, n.name);\n}\n\nvo.prototype._nodeCount = 0, vo.prototype._edgeCount = 0, vo.prototype.isDirected = function () {\n  return this._isDirected;\n}, vo.prototype.isMultigraph = function () {\n  return this._isMultigraph;\n}, vo.prototype.isCompound = function () {\n  return this._isCompound;\n}, vo.prototype.setGraph = function (e) {\n  return this._label = e, this;\n}, vo.prototype.graph = function () {\n  return this._label;\n}, vo.prototype.setDefaultNodeLabel = function (e) {\n  return ho.isFunction(e) || (e = ho.constant(e)), this._defaultNodeLabelFn = e, this;\n}, vo.prototype.nodeCount = function () {\n  return this._nodeCount;\n}, vo.prototype.nodes = function () {\n  return ho.keys(this._nodes);\n}, vo.prototype.sources = function () {\n  var e = this;\n  return ho.filter(this.nodes(), function (n) {\n    return ho.isEmpty(e._in[n]);\n  });\n}, vo.prototype.sinks = function () {\n  var e = this;\n  return ho.filter(this.nodes(), function (n) {\n    return ho.isEmpty(e._out[n]);\n  });\n}, vo.prototype.setNodes = function (e, n) {\n  var t = arguments,\n      r = this;\n  return ho.each(e, function (e) {\n    t.length > 1 ? r.setNode(e, n) : r.setNode(e);\n  }), this;\n}, vo.prototype.setNode = function (e, n) {\n  return ho.has(this._nodes, e) ? (arguments.length > 1 && (this._nodes[e] = n), this) : (this._nodes[e] = arguments.length > 1 ? n : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = \"\\0\", this._children[e] = {}, this._children[\"\\0\"][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount, this);\n}, vo.prototype.node = function (e) {\n  return this._nodes[e];\n}, vo.prototype.hasNode = function (e) {\n  return ho.has(this._nodes, e);\n}, vo.prototype.removeNode = function (e) {\n  var n = this;\n\n  if (ho.has(this._nodes, e)) {\n    var t = function t(e) {\n      n.removeEdge(n._edgeObjs[e]);\n    };\n\n    delete this._nodes[e], this._isCompound && (this._removeFromParentsChildList(e), delete this._parent[e], ho.each(this.children(e), function (e) {\n      n.setParent(e);\n    }), delete this._children[e]), ho.each(ho.keys(this._in[e]), t), delete this._in[e], delete this._preds[e], ho.each(ho.keys(this._out[e]), t), delete this._out[e], delete this._sucs[e], --this._nodeCount;\n  }\n\n  return this;\n}, vo.prototype.setParent = function (e, n) {\n  if (!this._isCompound) throw new Error(\"Cannot set parent in a non-compound graph\");\n  if (ho.isUndefined(n)) n = \"\\0\";else {\n    for (var t = n += \"\"; !ho.isUndefined(t); t = this.parent(t)) {\n      if (t === e) throw new Error(\"Setting \" + n + \" as parent of \" + e + \" would create a cycle\");\n    }\n\n    this.setNode(n);\n  }\n  return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = n, this._children[n][e] = !0, this;\n}, vo.prototype._removeFromParentsChildList = function (e) {\n  delete this._children[this._parent[e]][e];\n}, vo.prototype.parent = function (e) {\n  if (this._isCompound) {\n    var n = this._parent[e];\n    if (\"\\0\" !== n) return n;\n  }\n}, vo.prototype.children = function (e) {\n  if (ho.isUndefined(e) && (e = \"\\0\"), this._isCompound) {\n    var n = this._children[e];\n    if (n) return ho.keys(n);\n  } else {\n    if (\"\\0\" === e) return this.nodes();\n    if (this.hasNode(e)) return [];\n  }\n}, vo.prototype.predecessors = function (e) {\n  var n = this._preds[e];\n  if (n) return ho.keys(n);\n}, vo.prototype.successors = function (e) {\n  var n = this._sucs[e];\n  if (n) return ho.keys(n);\n}, vo.prototype.neighbors = function (e) {\n  var n = this.predecessors(e);\n  if (n) return ho.union(n, this.successors(e));\n}, vo.prototype.isLeaf = function (e) {\n  return 0 === (this.isDirected() ? this.successors(e) : this.neighbors(e)).length;\n}, vo.prototype.filterNodes = function (e) {\n  var n = new this.constructor({\n    directed: this._isDirected,\n    multigraph: this._isMultigraph,\n    compound: this._isCompound\n  });\n  n.setGraph(this.graph());\n  var t = this;\n  ho.each(this._nodes, function (t, r) {\n    e(r) && n.setNode(r, t);\n  }), ho.each(this._edgeObjs, function (e) {\n    n.hasNode(e.v) && n.hasNode(e.w) && n.setEdge(e, t.edge(e));\n  });\n  var r = {};\n\n  function o(e) {\n    var i = t.parent(e);\n    return void 0 === i || n.hasNode(i) ? (r[e] = i, i) : i in r ? r[i] : o(i);\n  }\n\n  return this._isCompound && ho.each(n.nodes(), function (e) {\n    n.setParent(e, o(e));\n  }), n;\n}, vo.prototype.setDefaultEdgeLabel = function (e) {\n  return ho.isFunction(e) || (e = ho.constant(e)), this._defaultEdgeLabelFn = e, this;\n}, vo.prototype.edgeCount = function () {\n  return this._edgeCount;\n}, vo.prototype.edges = function () {\n  return ho.values(this._edgeObjs);\n}, vo.prototype.setPath = function (e, n) {\n  var t = this,\n      r = arguments;\n  return ho.reduce(e, function (e, o) {\n    return r.length > 1 ? t.setEdge(e, o, n) : t.setEdge(e, o), o;\n  }), this;\n}, vo.prototype.setEdge = function () {\n  var e,\n      n,\n      t,\n      r,\n      o = !1,\n      i = arguments[0];\n  \"object\" == typeof i && null !== i && \"v\" in i ? (e = i.v, n = i.w, t = i.name, 2 === arguments.length && (r = arguments[1], o = !0)) : (e = i, n = arguments[1], t = arguments[3], arguments.length > 2 && (r = arguments[2], o = !0)), e = \"\" + e, n = \"\" + n, ho.isUndefined(t) || (t = \"\" + t);\n  var a = yo(this._isDirected, e, n, t);\n  if (ho.has(this._edgeLabels, a)) return o && (this._edgeLabels[a] = r), this;\n  if (!ho.isUndefined(t) && !this._isMultigraph) throw new Error(\"Cannot set a named edge when isMultigraph = false\");\n  this.setNode(e), this.setNode(n), this._edgeLabels[a] = o ? r : this._defaultEdgeLabelFn(e, n, t);\n  var u = bo(this._isDirected, e, n, t);\n  return e = u.v, n = u.w, Object.freeze(u), this._edgeObjs[a] = u, po(this._preds[n], e), po(this._sucs[e], n), this._in[n][a] = u, this._out[e][a] = u, this._edgeCount++, this;\n}, vo.prototype.edge = function (e, n, t) {\n  var r = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e, n, t);\n  return this._edgeLabels[r];\n}, vo.prototype.hasEdge = function (e, n, t) {\n  var r = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e, n, t);\n  return ho.has(this._edgeLabels, r);\n}, vo.prototype.removeEdge = function (e, n, t) {\n  var r = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e, n, t),\n      o = this._edgeObjs[r];\n  return o && (e = o.v, n = o.w, delete this._edgeLabels[r], delete this._edgeObjs[r], go(this._preds[n], e), go(this._sucs[e], n), delete this._in[n][r], delete this._out[e][r], this._edgeCount--), this;\n}, vo.prototype.inEdges = function (e, n) {\n  var t = this._in[e];\n\n  if (t) {\n    var r = ho.values(t);\n    return n ? ho.filter(r, function (e) {\n      return e.v === n;\n    }) : r;\n  }\n}, vo.prototype.outEdges = function (e, n) {\n  var t = this._out[e];\n\n  if (t) {\n    var r = ho.values(t);\n    return n ? ho.filter(r, function (e) {\n      return e.w === n;\n    }) : r;\n  }\n}, vo.prototype.nodeEdges = function (e, n) {\n  var t = this.inEdges(e, n);\n  if (t) return t.concat(this.outEdges(e, n));\n};\nvar wo = {\n  Graph: lo,\n  version: \"2.1.8\"\n},\n    Eo = {\n  write: function write(e) {\n    var n = {\n      options: {\n        directed: e.isDirected(),\n        multigraph: e.isMultigraph(),\n        compound: e.isCompound()\n      },\n      nodes: _o(e),\n      edges: jo(e)\n    };\n    ho.isUndefined(e.graph()) || (n.value = ho.clone(e.graph()));\n    return n;\n  },\n  read: function read(e) {\n    var n = new lo(e.options).setGraph(e.value);\n    return ho.each(e.nodes, function (e) {\n      n.setNode(e.v, e.value), e.parent && n.setParent(e.v, e.parent);\n    }), ho.each(e.edges, function (e) {\n      n.setEdge({\n        v: e.v,\n        w: e.w,\n        name: e.name\n      }, e.value);\n    }), n;\n  }\n};\n\nfunction _o(e) {\n  return ho.map(e.nodes(), function (n) {\n    var t = e.node(n),\n        r = e.parent(n),\n        o = {\n      v: n\n    };\n    return ho.isUndefined(t) || (o.value = t), ho.isUndefined(r) || (o.parent = r), o;\n  });\n}\n\nfunction jo(e) {\n  return ho.map(e.edges(), function (n) {\n    var t = e.edge(n),\n        r = {\n      v: n.v,\n      w: n.w\n    };\n    return ho.isUndefined(n.name) || (r.name = n.name), ho.isUndefined(t) || (r.value = t), r;\n  });\n}\n\nvar xo = function xo(e) {\n  var n,\n      t = {},\n      r = [];\n\n  function o(r) {\n    ho.has(t, r) || (t[r] = !0, n.push(r), ho.each(e.successors(r), o), ho.each(e.predecessors(r), o));\n  }\n\n  return ho.each(e.nodes(), function (e) {\n    n = [], o(e), n.length && r.push(n);\n  }), r;\n};\n\nvar No = Oo;\n\nfunction Oo() {\n  this._arr = [], this._keyIndices = {};\n}\n\nOo.prototype.size = function () {\n  return this._arr.length;\n}, Oo.prototype.keys = function () {\n  return this._arr.map(function (e) {\n    return e.key;\n  });\n}, Oo.prototype.has = function (e) {\n  return ho.has(this._keyIndices, e);\n}, Oo.prototype.priority = function (e) {\n  var n = this._keyIndices[e];\n  if (void 0 !== n) return this._arr[n].priority;\n}, Oo.prototype.min = function () {\n  if (0 === this.size()) throw new Error(\"Queue underflow\");\n  return this._arr[0].key;\n}, Oo.prototype.add = function (e, n) {\n  var t = this._keyIndices;\n\n  if (e = String(e), !ho.has(t, e)) {\n    var r = this._arr,\n        o = r.length;\n    return t[e] = o, r.push({\n      key: e,\n      priority: n\n    }), this._decrease(o), !0;\n  }\n\n  return !1;\n}, Oo.prototype.removeMin = function () {\n  this._swap(0, this._arr.length - 1);\n\n  var e = this._arr.pop();\n\n  return delete this._keyIndices[e.key], this._heapify(0), e.key;\n}, Oo.prototype.decrease = function (e, n) {\n  var t = this._keyIndices[e];\n  if (n > this._arr[t].priority) throw new Error(\"New priority is greater than current priority. Key: \" + e + \" Old: \" + this._arr[t].priority + \" New: \" + n);\n  this._arr[t].priority = n, this._decrease(t);\n}, Oo.prototype._heapify = function (e) {\n  var n = this._arr,\n      t = 2 * e,\n      r = t + 1,\n      o = e;\n  t < n.length && (o = n[t].priority < n[o].priority ? t : o, r < n.length && (o = n[r].priority < n[o].priority ? r : o), o !== e && (this._swap(e, o), this._heapify(o)));\n}, Oo.prototype._decrease = function (e) {\n  for (var n, t = this._arr, r = t[e].priority; 0 !== e && !(t[n = e >> 1].priority < r);) {\n    this._swap(e, n), e = n;\n  }\n}, Oo.prototype._swap = function (e, n) {\n  var t = this._arr,\n      r = this._keyIndices,\n      o = t[e],\n      i = t[n];\n  t[e] = i, t[n] = o, r[i.key] = e, r[o.key] = n;\n};\n\nvar ko = function ko(e, n, t, r) {\n  return function (e, n, t, r) {\n    var o,\n        i,\n        a = {},\n        u = new No(),\n        c = function c(e) {\n      var n = e.v !== o ? e.v : e.w,\n          r = a[n],\n          c = t(e),\n          s = i.distance + c;\n      if (c < 0) throw new Error(\"dijkstra does not allow negative edge weights. Bad edge: \" + e + \" Weight: \" + c);\n      s < r.distance && (r.distance = s, r.predecessor = o, u.decrease(n, s));\n    };\n\n    e.nodes().forEach(function (e) {\n      var t = e === n ? 0 : Number.POSITIVE_INFINITY;\n      a[e] = {\n        distance: t\n      }, u.add(e, t);\n    });\n\n    for (; u.size() > 0 && (o = u.removeMin(), (i = a[o]).distance !== Number.POSITIVE_INFINITY);) {\n      r(o).forEach(c);\n    }\n\n    return a;\n  }(e, String(n), t || Io, r || function (n) {\n    return e.outEdges(n);\n  });\n},\n    Io = ho.constant(1);\n\nvar So = function So(e, n, t) {\n  return ho.transform(e.nodes(), function (r, o) {\n    r[o] = ko(e, o, n, t);\n  }, {});\n};\n\nvar Mo = function Mo(e) {\n  var n = 0,\n      t = [],\n      r = {},\n      o = [];\n\n  function i(a) {\n    var u = r[a] = {\n      onStack: !0,\n      lowlink: n,\n      index: n++\n    };\n\n    if (t.push(a), e.successors(a).forEach(function (e) {\n      ho.has(r, e) ? r[e].onStack && (u.lowlink = Math.min(u.lowlink, r[e].index)) : (i(e), u.lowlink = Math.min(u.lowlink, r[e].lowlink));\n    }), u.lowlink === u.index) {\n      var c,\n          s = [];\n\n      do {\n        c = t.pop(), r[c].onStack = !1, s.push(c);\n      } while (a !== c);\n\n      o.push(s);\n    }\n  }\n\n  return e.nodes().forEach(function (e) {\n    ho.has(r, e) || i(e);\n  }), o;\n};\n\nvar Co = function Co(e) {\n  return ho.filter(Mo(e), function (n) {\n    return n.length > 1 || 1 === n.length && e.hasEdge(n[0], n[0]);\n  });\n};\n\nvar Go = function Go(e, n, t) {\n  return function (e, n, t) {\n    var r = {},\n        o = e.nodes();\n    return o.forEach(function (e) {\n      r[e] = {}, r[e][e] = {\n        distance: 0\n      }, o.forEach(function (n) {\n        e !== n && (r[e][n] = {\n          distance: Number.POSITIVE_INFINITY\n        });\n      }), t(e).forEach(function (t) {\n        var o = t.v === e ? t.w : t.v,\n            i = n(t);\n        r[e][o] = {\n          distance: i,\n          predecessor: e\n        };\n      });\n    }), o.forEach(function (e) {\n      var n = r[e];\n      o.forEach(function (t) {\n        var i = r[t];\n        o.forEach(function (t) {\n          var r = i[e],\n              o = n[t],\n              a = i[t],\n              u = r.distance + o.distance;\n          u < a.distance && (a.distance = u, a.predecessor = o.predecessor);\n        });\n      });\n    }), r;\n  }(e, n || Bo, t || function (n) {\n    return e.outEdges(n);\n  });\n},\n    Bo = ho.constant(1);\n\nvar Ao = Lo;\n\nfunction Lo(e) {\n  var n = {},\n      t = {},\n      r = [];\n  if (ho.each(e.sinks(), function o(i) {\n    if (ho.has(t, i)) throw new Ro();\n    ho.has(n, i) || (t[i] = !0, n[i] = !0, ho.each(e.predecessors(i), o), delete t[i], r.push(i));\n  }), ho.size(n) !== e.nodeCount()) throw new Ro();\n  return r;\n}\n\nfunction Ro() {}\n\nLo.CycleException = Ro, Ro.prototype = new Error();\n\nvar To = function To(e, n, t) {\n  ho.isArray(n) || (n = [n]);\n  var r = (e.isDirected() ? e.successors : e.neighbors).bind(e),\n      o = [],\n      i = {};\n  return ho.each(n, function (n) {\n    if (!e.hasNode(n)) throw new Error(\"Graph does not have node: \" + n);\n    Do(e, n, \"post\" === t, i, r, o);\n  }), o;\n};\n\nfunction Do(e, n, t, r, o, i) {\n  ho.has(r, n) || (r[n] = !0, t || i.push(n), ho.each(o(n), function (n) {\n    Do(e, n, t, r, o, i);\n  }), t && i.push(n));\n}\n\nvar Po,\n    zo = {\n  Graph: wo.Graph,\n  json: Eo,\n  alg: {\n    components: xo,\n    dijkstra: ko,\n    dijkstraAll: So,\n    findCycles: Co,\n    floydWarshall: Go,\n    isAcyclic: function isAcyclic(e) {\n      try {\n        Ao(e);\n      } catch (e) {\n        if (e instanceof Ao.CycleException) return !1;\n        throw e;\n      }\n\n      return !0;\n    },\n    postorder: function postorder(e, n) {\n      return To(e, n, \"post\");\n    },\n    preorder: function preorder(e, n) {\n      return To(e, n, \"pre\");\n    },\n    prim: function prim(e, n) {\n      var t,\n          r = new lo(),\n          o = {},\n          i = new No();\n\n      function a(e) {\n        var r = e.v === t ? e.w : e.v,\n            a = i.priority(r);\n\n        if (void 0 !== a) {\n          var u = n(e);\n          u < a && (o[r] = t, i.decrease(r, u));\n        }\n      }\n\n      if (0 === e.nodeCount()) return r;\n      ho.each(e.nodes(), function (e) {\n        i.add(e, Number.POSITIVE_INFINITY), r.setNode(e);\n      }), i.decrease(e.nodes()[0], 0);\n      var u = !1;\n\n      for (; i.size() > 0;) {\n        if (t = i.removeMin(), ho.has(o, t)) r.setEdge(t, o[t]);else {\n          if (u) throw new Error(\"Input graph is not connected: \" + e);\n          u = !0;\n        }\n        e.nodeEdges(t).forEach(a);\n      }\n\n      return r;\n    },\n    tarjan: Mo,\n    topsort: Ao\n  },\n  version: wo.version\n};\n\ntry {\n  Po = zo;\n} catch (e) {}\n\nPo || (Po = window.graphlib);\nvar Fo = Po;\n\nvar Uo = function Uo(e) {\n  return at(e, 5);\n};\n\nvar Vo = function Vo(e, n, t) {\n  if (!D(t)) return !1;\n  var r = typeof n;\n  return !!(\"number\" == r ? rn(t) && Fe(n, t.length) : \"string\" == r && n in t) && h(t[n], e);\n},\n    $o = Object.prototype,\n    Ho = $o.hasOwnProperty,\n    Wo = Xr(function (e, n) {\n  e = Object(e);\n  var t = -1,\n      r = n.length,\n      o = r > 2 ? n[2] : void 0;\n\n  for (o && Vo(n[0], n[1], o) && (r = 1); ++t < r;) {\n    for (var i = n[t], a = dn(i), u = -1, c = a.length; ++u < c;) {\n      var s = a[u],\n          d = e[s];\n      (void 0 === d || h(d, $o[s]) && !Ho.call(e, s)) && (e[s] = i[s]);\n    }\n  }\n\n  return e;\n});\n\nvar qo = function qo(e) {\n  return function (n, t, r) {\n    var o = Object(n);\n\n    if (!rn(n)) {\n      var i = dr(t);\n      n = on(n), t = function t(e) {\n        return i(o[e], e, o);\n      };\n    }\n\n    var a = e(n, t, r);\n    return a > -1 ? o[i ? n[a] : a] : void 0;\n  };\n},\n    Yo = /^\\s+|\\s+$/g,\n    Jo = /^[-+]0x[0-9a-f]+$/i,\n    Xo = /^0b[01]+$/i,\n    Ko = /^0o[0-7]+$/i,\n    Qo = parseInt;\n\nvar Zo = function Zo(e) {\n  if (\"number\" == typeof e) return e;\n  if (Pt(e)) return NaN;\n\n  if (D(e)) {\n    var n = \"function\" == typeof e.valueOf ? e.valueOf() : e;\n    e = D(n) ? n + \"\" : n;\n  }\n\n  if (\"string\" != typeof e) return 0 === e ? e : +e;\n  e = e.replace(Yo, \"\");\n  var t = Xo.test(e);\n  return t || Ko.test(e) ? Qo(e.slice(2), t ? 2 : 8) : Jo.test(e) ? NaN : +e;\n};\n\nvar ei = function ei(e) {\n  return e ? Infinity === (e = Zo(e)) || -Infinity === e ? 17976931348623157e292 * (e < 0 ? -1 : 1) : e == e ? e : 0 : 0 === e ? e : 0;\n};\n\nvar ni = function ni(e) {\n  var n = ei(e),\n      t = n % 1;\n  return n == n ? t ? n - t : n : 0;\n},\n    ti = Math.max;\n\nvar ri = qo(function (e, n, t) {\n  var r = null == e ? 0 : e.length;\n  if (!r) return -1;\n  var o = null == t ? 0 : ni(t);\n  return o < 0 && (o = ti(r + o, 0)), Kr(e, dr(n), o);\n});\n\nvar oi = function oi(e) {\n  return (null == e ? 0 : e.length) ? Vr(e, 1) : [];\n};\n\nvar ii = function ii(e, n) {\n  return null == e ? e : st(e, lt(n), dn);\n};\n\nvar ai = function ai(e) {\n  var n = null == e ? 0 : e.length;\n  return n ? e[n - 1] : void 0;\n};\n\nvar ui = function ui(e, n) {\n  var t = {};\n  return n = dr(n), dt(e, function (e, r, o) {\n    Oe(t, r, n(e, r, o));\n  }), t;\n};\n\nvar ci = function ci(e, n, t) {\n  for (var r = -1, o = e.length; ++r < o;) {\n    var i = e[r],\n        a = n(i);\n    if (null != a && (void 0 === u ? a == a && !Pt(a) : t(a, u))) var u = a,\n        c = i;\n  }\n\n  return c;\n};\n\nvar si = function si(e, n) {\n  return e > n;\n};\n\nvar di = function di(e) {\n  return e && e.length ? ci(e, ht, si) : void 0;\n};\n\nvar fi = function fi(e, n, t) {\n  (void 0 !== t && !h(e[n], t) || void 0 === t && !(n in e)) && Oe(e, n, t);\n},\n    hi = Function.prototype,\n    li = Object.prototype,\n    vi = hi.toString,\n    pi = li.hasOwnProperty,\n    gi = vi.call(Object);\n\nvar yi = function yi(e) {\n  if (!Ce(e) || \"[object Object]\" != T(e)) return !1;\n  var n = En(e);\n  if (null === n) return !0;\n  var t = pi.call(n, \"constructor\") && n.constructor;\n  return \"function\" == typeof t && t instanceof t && vi.call(t) == gi;\n};\n\nvar bi = function bi(e, n) {\n  if ((\"constructor\" !== n || \"function\" != typeof e[n]) && \"__proto__\" != n) return e[n];\n};\n\nvar mi = function mi(e) {\n  return Se(e, dn(e));\n};\n\nvar wi = function wi(e, n, t, r, o, i, a) {\n  var u = bi(e, t),\n      c = bi(n, t),\n      s = a.get(c);\n  if (s) fi(e, t, s);else {\n    var d = i ? i(u, c, t + \"\", e, n, a) : void 0,\n        f = void 0 === d;\n\n    if (f) {\n      var h = Te(c),\n          l = !h && Pe(c),\n          v = !h && !l && Ye(c);\n      d = c, h || l || v ? Te(u) ? d = u : ao(u) ? d = ln(u) : l ? (f = !1, d = hn(c, !0)) : v ? (f = !1, d = Yn(c, !0)) : d = [] : yi(c) || Re(c) ? (d = u, Re(u) ? d = mi(u) : D(u) && !z(u) || (d = Qn(c))) : f = !1;\n    }\n\n    f && (a.set(c, d), o(d, c, r, i, a), a.delete(c)), fi(e, t, d);\n  }\n};\n\nvar Ei = function e(n, t, r, o, i) {\n  n !== t && st(t, function (a, u) {\n    if (i || (i = new je()), D(a)) wi(n, t, u, r, e, o, i);else {\n      var c = o ? o(bi(n, u), a, u + \"\", n, t, i) : void 0;\n      void 0 === c && (c = a), fi(n, u, c);\n    }\n  }, dn);\n};\n\nvar _i = function (e) {\n  return Xr(function (n, t) {\n    var r = -1,\n        o = t.length,\n        i = o > 1 ? t[o - 1] : void 0,\n        a = o > 2 ? t[2] : void 0;\n\n    for (i = e.length > 3 && \"function\" == typeof i ? (o--, i) : void 0, a && Vo(t[0], t[1], a) && (i = o < 3 ? void 0 : i, o = 1), n = Object(n); ++r < o;) {\n      var u = t[r];\n      u && e(n, u, r, i);\n    }\n\n    return n;\n  });\n}(function (e, n, t) {\n  Ei(e, n, t);\n});\n\nvar ji = function ji(e, n) {\n  return e < n;\n};\n\nvar xi = function xi(e) {\n  return e && e.length ? ci(e, ht, ji) : void 0;\n};\n\nvar Ni = function Ni(e, n) {\n  return e && e.length ? ci(e, dr(n), ji) : void 0;\n},\n    Oi = function Oi() {\n  return k.Date.now();\n};\n\nvar ki = function ki(e, n, t, r) {\n  if (!D(e)) return e;\n\n  for (var o = -1, i = (n = Zt(n, e)).length, a = i - 1, u = e; null != u && ++o < i;) {\n    var c = er(n[o]),\n        s = t;\n    if (\"__proto__\" === c || \"constructor\" === c || \"prototype\" === c) return e;\n\n    if (o != a) {\n      var d = u[c];\n      void 0 === (s = r ? r(d, c, u) : void 0) && (s = D(d) ? d : Fe(n[o + 1]) ? [] : {});\n    }\n\n    Ie(u, c, s), u = u[c];\n  }\n\n  return e;\n};\n\nvar Ii = function Ii(e, n, t) {\n  for (var r = -1, o = n.length, i = {}; ++r < o;) {\n    var a = n[r],\n        u = nr(e, a);\n    t(u, a) && ki(i, Zt(a, e), u);\n  }\n\n  return i;\n};\n\nvar Si = function Si(e, n) {\n  return Ii(e, n, function (n, t) {\n    return ir(e, t);\n  });\n};\n\nvar Mi = function (e) {\n  return Jr(Wr(e, void 0, oi), e + \"\");\n}(function (e, n) {\n  return null == e ? {} : Si(e, n);\n}),\n    Ci = Math.ceil,\n    Gi = Math.max;\n\nvar Bi = function Bi(e, n, t, r) {\n  for (var o = -1, i = Gi(Ci((n - e) / (t || 1)), 0), a = Array(i); i--;) {\n    a[r ? i : ++o] = e, e += t;\n  }\n\n  return a;\n};\n\nvar Ai = function (e) {\n  return function (n, t, r) {\n    return r && \"number\" != typeof r && Vo(n, t, r) && (t = r = void 0), n = ei(n), void 0 === t ? (t = n, n = 0) : t = ei(t), r = void 0 === r ? n < t ? 1 : -1 : ei(r), Bi(n, t, r, e);\n  };\n}();\n\nvar Li = function Li(e, n) {\n  var t = e.length;\n\n  for (e.sort(n); t--;) {\n    e[t] = e[t].value;\n  }\n\n  return e;\n};\n\nvar Ri = function Ri(e, n) {\n  if (e !== n) {\n    var t = void 0 !== e,\n        r = null === e,\n        o = e == e,\n        i = Pt(e),\n        a = void 0 !== n,\n        u = null === n,\n        c = n == n,\n        s = Pt(n);\n    if (!u && !s && !i && e > n || i && a && c && !u && !s || r && a && c || !t && c || !o) return 1;\n    if (!r && !i && !s && e < n || s && t && o && !r && !i || u && t && o || !a && o || !c) return -1;\n  }\n\n  return 0;\n};\n\nvar Ti = function Ti(e, n, t) {\n  for (var r = -1, o = e.criteria, i = n.criteria, a = o.length, u = t.length; ++r < a;) {\n    var c = Ri(o[r], i[r]);\n    if (c) return r >= u ? c : c * (\"desc\" == t[r] ? -1 : 1);\n  }\n\n  return e.index - n.index;\n};\n\nvar Di = function Di(e, n, t) {\n  n = n.length ? Yt(n, function (e) {\n    return Te(e) ? function (n) {\n      return nr(n, 1 === e.length ? e[0] : e);\n    } : e;\n  }) : [ht];\n  var r = -1;\n  n = Yt(n, He(dr));\n  var o = br(e, function (e, t, o) {\n    return {\n      criteria: Yt(n, function (n) {\n        return n(e);\n      }),\n      index: ++r,\n      value: e\n    };\n  });\n  return Li(o, function (e, n) {\n    return Ti(e, n, t);\n  });\n},\n    Pi = Xr(function (e, n) {\n  if (null == e) return [];\n  var t = n.length;\n  return t > 1 && Vo(e, n[0], n[1]) ? n = [] : t > 2 && Vo(n[0], n[1], n[2]) && (n = [n[0]]), Di(e, Vr(n, 1), []);\n}),\n    zi = 0;\n\nvar Fi = function Fi(e) {\n  var n = ++zi;\n  return Qt(e) + n;\n};\n\nvar Ui = function Ui(e, n, t) {\n  for (var r = -1, o = e.length, i = n.length, a = {}; ++r < o;) {\n    var u = r < i ? n[r] : void 0;\n    t(a, e[r], u);\n  }\n\n  return a;\n};\n\nvar Vi,\n    $i = function $i(e, n) {\n  return Ui(e || [], n || [], Ie);\n};\n\ntry {\n  Vi = {\n    cloneDeep: Uo,\n    constant: ct,\n    defaults: Wo,\n    each: pt,\n    filter: fr,\n    find: ri,\n    flatten: oi,\n    forEach: vt,\n    forIn: ii,\n    has: vr,\n    isUndefined: yr,\n    last: ai,\n    map: mr,\n    mapValues: ui,\n    max: di,\n    merge: _i,\n    min: xi,\n    minBy: Ni,\n    now: Oi,\n    pick: Mi,\n    range: Ai,\n    reduce: _r,\n    sortBy: Pi,\n    uniqueId: Fi,\n    values: fo,\n    zipObject: $i\n  };\n} catch (e) {}\n\nVi || (Vi = window._);\nvar Hi = Vi,\n    Wi = qi;\n\nfunction qi() {\n  var e = {};\n  e._next = e._prev = e, this._sentinel = e;\n}\n\nfunction Yi(e) {\n  e._prev._next = e._next, e._next._prev = e._prev, delete e._next, delete e._prev;\n}\n\nfunction Ji(e, n) {\n  if (\"_next\" !== e && \"_prev\" !== e) return n;\n}\n\nqi.prototype.dequeue = function () {\n  var e = this._sentinel,\n      n = e._prev;\n  if (n !== e) return Yi(n), n;\n}, qi.prototype.enqueue = function (e) {\n  var n = this._sentinel;\n  e._prev && e._next && Yi(e), e._next = n._next, n._next._prev = e, n._next = e, e._prev = n;\n}, qi.prototype.toString = function () {\n  for (var e = [], n = this._sentinel, t = n._prev; t !== n;) {\n    e.push(JSON.stringify(t, Ji)), t = t._prev;\n  }\n\n  return \"[\" + e.join(\", \") + \"]\";\n};\n\nvar Xi = Fo.Graph,\n    Ki = function Ki(e, n) {\n  if (e.nodeCount() <= 1) return [];\n\n  var t = function (e, n) {\n    var t = new Xi(),\n        r = 0,\n        o = 0;\n    Hi.forEach(e.nodes(), function (e) {\n      t.setNode(e, {\n        v: e,\n        in: 0,\n        out: 0\n      });\n    }), Hi.forEach(e.edges(), function (e) {\n      var i = t.edge(e.v, e.w) || 0,\n          a = n(e),\n          u = i + a;\n      t.setEdge(e.v, e.w, u), o = Math.max(o, t.node(e.v).out += a), r = Math.max(r, t.node(e.w).in += a);\n    });\n    var i = Hi.range(o + r + 3).map(function () {\n      return new Wi();\n    }),\n        a = r + 1;\n    return Hi.forEach(t.nodes(), function (e) {\n      ea(i, a, t.node(e));\n    }), {\n      graph: t,\n      buckets: i,\n      zeroIdx: a\n    };\n  }(e, n || Qi),\n      r = function (e, n, t) {\n    var r,\n        o = [],\n        i = n[n.length - 1],\n        a = n[0];\n\n    for (; e.nodeCount();) {\n      for (; r = a.dequeue();) {\n        Zi(e, n, t, r);\n      }\n\n      for (; r = i.dequeue();) {\n        Zi(e, n, t, r);\n      }\n\n      if (e.nodeCount()) for (var u = n.length - 2; u > 0; --u) {\n        if (r = n[u].dequeue()) {\n          o = o.concat(Zi(e, n, t, r, !0));\n          break;\n        }\n      }\n    }\n\n    return o;\n  }(t.graph, t.buckets, t.zeroIdx);\n\n  return Hi.flatten(Hi.map(r, function (n) {\n    return e.outEdges(n.v, n.w);\n  }), !0);\n},\n    Qi = Hi.constant(1);\n\nfunction Zi(e, n, t, r, o) {\n  var i = o ? [] : void 0;\n  return Hi.forEach(e.inEdges(r.v), function (r) {\n    var a = e.edge(r),\n        u = e.node(r.v);\n    o && i.push({\n      v: r.v,\n      w: r.w\n    }), u.out -= a, ea(n, t, u);\n  }), Hi.forEach(e.outEdges(r.v), function (r) {\n    var o = e.edge(r),\n        i = r.w,\n        a = e.node(i);\n    a.in -= o, ea(n, t, a);\n  }), e.removeNode(r.v), i;\n}\n\nfunction ea(e, n, t) {\n  t.out ? t.in ? e[t.out - t.in + n].enqueue(t) : e[e.length - 1].enqueue(t) : e[0].enqueue(t);\n}\n\nvar na = {\n  run: function run(e) {\n    var n = \"greedy\" === e.graph().acyclicer ? Ki(e, function (e) {\n      return function (n) {\n        return e.edge(n).weight;\n      };\n    }(e)) : function (e) {\n      var n = [],\n          t = {},\n          r = {};\n\n      function o(i) {\n        Hi.has(r, i) || (r[i] = !0, t[i] = !0, Hi.forEach(e.outEdges(i), function (e) {\n          Hi.has(t, e.w) ? n.push(e) : o(e.w);\n        }), delete t[i]);\n      }\n\n      return Hi.forEach(e.nodes(), o), n;\n    }(e);\n    Hi.forEach(n, function (n) {\n      var t = e.edge(n);\n      e.removeEdge(n), t.forwardName = n.name, t.reversed = !0, e.setEdge(n.w, n.v, t, Hi.uniqueId(\"rev\"));\n    });\n  },\n  undo: function undo(e) {\n    Hi.forEach(e.edges(), function (n) {\n      var t = e.edge(n);\n\n      if (t.reversed) {\n        e.removeEdge(n);\n        var r = t.forwardName;\n        delete t.reversed, delete t.forwardName, e.setEdge(n.w, n.v, t, r);\n      }\n    });\n  }\n};\nvar ta = Fo.Graph,\n    ra = {\n  addDummyNode: oa,\n  simplify: function simplify(e) {\n    var n = new ta().setGraph(e.graph());\n    return Hi.forEach(e.nodes(), function (t) {\n      n.setNode(t, e.node(t));\n    }), Hi.forEach(e.edges(), function (t) {\n      var r = n.edge(t.v, t.w) || {\n        weight: 0,\n        minlen: 1\n      },\n          o = e.edge(t);\n      n.setEdge(t.v, t.w, {\n        weight: r.weight + o.weight,\n        minlen: Math.max(r.minlen, o.minlen)\n      });\n    }), n;\n  },\n  asNonCompoundGraph: function asNonCompoundGraph(e) {\n    var n = new ta({\n      multigraph: e.isMultigraph()\n    }).setGraph(e.graph());\n    return Hi.forEach(e.nodes(), function (t) {\n      e.children(t).length || n.setNode(t, e.node(t));\n    }), Hi.forEach(e.edges(), function (t) {\n      n.setEdge(t, e.edge(t));\n    }), n;\n  },\n  successorWeights: function successorWeights(e) {\n    var n = Hi.map(e.nodes(), function (n) {\n      var t = {};\n      return Hi.forEach(e.outEdges(n), function (n) {\n        t[n.w] = (t[n.w] || 0) + e.edge(n).weight;\n      }), t;\n    });\n    return Hi.zipObject(e.nodes(), n);\n  },\n  predecessorWeights: function predecessorWeights(e) {\n    var n = Hi.map(e.nodes(), function (n) {\n      var t = {};\n      return Hi.forEach(e.inEdges(n), function (n) {\n        t[n.v] = (t[n.v] || 0) + e.edge(n).weight;\n      }), t;\n    });\n    return Hi.zipObject(e.nodes(), n);\n  },\n  intersectRect: function intersectRect(e, n) {\n    var t,\n        r,\n        o = e.x,\n        i = e.y,\n        a = n.x - o,\n        u = n.y - i,\n        c = e.width / 2,\n        s = e.height / 2;\n    if (!a && !u) throw new Error(\"Not possible to find intersection inside of the rectangle\");\n    Math.abs(u) * c > Math.abs(a) * s ? (u < 0 && (s = -s), t = s * a / u, r = s) : (a < 0 && (c = -c), t = c, r = c * u / a);\n    return {\n      x: o + t,\n      y: i + r\n    };\n  },\n  buildLayerMatrix: function buildLayerMatrix(e) {\n    var n = Hi.map(Hi.range(ia(e) + 1), function () {\n      return [];\n    });\n    return Hi.forEach(e.nodes(), function (t) {\n      var r = e.node(t),\n          o = r.rank;\n      Hi.isUndefined(o) || (n[o][r.order] = t);\n    }), n;\n  },\n  normalizeRanks: function normalizeRanks(e) {\n    var n = Hi.min(Hi.map(e.nodes(), function (n) {\n      return e.node(n).rank;\n    }));\n    Hi.forEach(e.nodes(), function (t) {\n      var r = e.node(t);\n      Hi.has(r, \"rank\") && (r.rank -= n);\n    });\n  },\n  removeEmptyRanks: function removeEmptyRanks(e) {\n    var n = Hi.min(Hi.map(e.nodes(), function (n) {\n      return e.node(n).rank;\n    })),\n        t = [];\n    Hi.forEach(e.nodes(), function (r) {\n      var o = e.node(r).rank - n;\n      t[o] || (t[o] = []), t[o].push(r);\n    });\n    var r = 0,\n        o = e.graph().nodeRankFactor;\n    Hi.forEach(t, function (n, t) {\n      Hi.isUndefined(n) && t % o != 0 ? --r : r && Hi.forEach(n, function (n) {\n        e.node(n).rank += r;\n      });\n    });\n  },\n  addBorderNode: function addBorderNode(e, n, t, r) {\n    var o = {\n      width: 0,\n      height: 0\n    };\n    arguments.length >= 4 && (o.rank = t, o.order = r);\n    return oa(e, \"border\", o, n);\n  },\n  maxRank: ia,\n  partition: function partition(e, n) {\n    var t = {\n      lhs: [],\n      rhs: []\n    };\n    return Hi.forEach(e, function (e) {\n      n(e) ? t.lhs.push(e) : t.rhs.push(e);\n    }), t;\n  },\n  time: function time(e, n) {\n    var t = Hi.now();\n\n    try {\n      return n();\n    } finally {\n      console.log(e + \" time: \" + (Hi.now() - t) + \"ms\");\n    }\n  },\n  notime: function notime(e, n) {\n    return n();\n  }\n};\n\nfunction oa(e, n, t, r) {\n  var o;\n\n  do {\n    o = Hi.uniqueId(r);\n  } while (e.hasNode(o));\n\n  return t.dummy = n, e.setNode(o, t), o;\n}\n\nfunction ia(e) {\n  return Hi.max(Hi.map(e.nodes(), function (n) {\n    var t = e.node(n).rank;\n    if (!Hi.isUndefined(t)) return t;\n  }));\n}\n\nvar aa = {\n  run: function run(e) {\n    e.graph().dummyChains = [], Hi.forEach(e.edges(), function (n) {\n      !function (e, n) {\n        var t,\n            r,\n            o,\n            i = n.v,\n            a = e.node(i).rank,\n            u = n.w,\n            c = e.node(u).rank,\n            s = n.name,\n            d = e.edge(n),\n            f = d.labelRank;\n        if (c === a + 1) return;\n\n        for (e.removeEdge(n), o = 0, ++a; a < c; ++o, ++a) {\n          d.points = [], r = {\n            width: 0,\n            height: 0,\n            edgeLabel: d,\n            edgeObj: n,\n            rank: a\n          }, t = ra.addDummyNode(e, \"edge\", r, \"_d\"), a === f && (r.width = d.width, r.height = d.height, r.dummy = \"edge-label\", r.labelpos = d.labelpos), e.setEdge(i, t, {\n            weight: d.weight\n          }, s), 0 === o && e.graph().dummyChains.push(t), i = t;\n        }\n\n        e.setEdge(i, u, {\n          weight: d.weight\n        }, s);\n      }(e, n);\n    });\n  },\n  undo: function undo(e) {\n    Hi.forEach(e.graph().dummyChains, function (n) {\n      var t,\n          r = e.node(n),\n          o = r.edgeLabel;\n\n      for (e.setEdge(r.edgeObj, o); r.dummy;) {\n        t = e.successors(n)[0], e.removeNode(n), o.points.push({\n          x: r.x,\n          y: r.y\n        }), \"edge-label\" === r.dummy && (o.x = r.x, o.y = r.y, o.width = r.width, o.height = r.height), n = t, r = e.node(n);\n      }\n    });\n  }\n};\n\nvar ua = function ua(e) {\n  var n = {};\n  Hi.forEach(e.sources(), function t(r) {\n    var o = e.node(r);\n    if (Hi.has(n, r)) return o.rank;\n    n[r] = !0;\n    var i = Hi.min(Hi.map(e.outEdges(r), function (n) {\n      return t(n.w) - e.edge(n).minlen;\n    }));\n    return i !== Number.POSITIVE_INFINITY && null != i || (i = 0), o.rank = i;\n  });\n},\n    ca = function ca(e, n) {\n  return e.node(n.w).rank - e.node(n.v).rank - e.edge(n).minlen;\n};\n\nvar sa = Fo.Graph,\n    da = ca,\n    fa = function fa(e) {\n  var n,\n      t,\n      r = new sa({\n    directed: !1\n  }),\n      o = e.nodes()[0],\n      i = e.nodeCount();\n  r.setNode(o, {});\n\n  for (; ha(r, e) < i;) {\n    n = la(r, e), t = r.hasNode(n.v) ? da(e, n) : -da(e, n), va(r, e, t);\n  }\n\n  return r;\n};\n\nfunction ha(e, n) {\n  return Hi.forEach(e.nodes(), function t(r) {\n    Hi.forEach(n.nodeEdges(r), function (o) {\n      var i = o.v,\n          a = r === i ? o.w : i;\n      e.hasNode(a) || da(n, o) || (e.setNode(a, {}), e.setEdge(r, a, {}), t(a));\n    });\n  }), e.nodeCount();\n}\n\nfunction la(e, n) {\n  return Hi.minBy(n.edges(), function (t) {\n    if (e.hasNode(t.v) !== e.hasNode(t.w)) return da(n, t);\n  });\n}\n\nfunction va(e, n, t) {\n  Hi.forEach(e.nodes(), function (e) {\n    n.node(e).rank += t;\n  });\n}\n\nvar pa = ca,\n    ga = ua,\n    ya = Fo.alg.preorder,\n    ba = Fo.alg.postorder,\n    ma = ra.simplify,\n    wa = Ea;\n\nfunction Ea(e) {\n  e = ma(e), ga(e);\n  var n,\n      t = fa(e);\n\n  for (xa(t), _a(t, e); n = Oa(t);) {\n    Ia(t, e, n, ka(t, e, n));\n  }\n}\n\nfunction _a(e, n) {\n  var t = ba(e, e.nodes());\n  t = t.slice(0, t.length - 1), Hi.forEach(t, function (t) {\n    !function (e, n, t) {\n      var r = e.node(t).parent;\n      e.edge(t, r).cutvalue = ja(e, n, t);\n    }(e, n, t);\n  });\n}\n\nfunction ja(e, n, t) {\n  var r = e.node(t).parent,\n      o = !0,\n      i = n.edge(t, r),\n      a = 0;\n  return i || (o = !1, i = n.edge(r, t)), a = i.weight, Hi.forEach(n.nodeEdges(t), function (i) {\n    var u,\n        c,\n        s = i.v === t,\n        d = s ? i.w : i.v;\n\n    if (d !== r) {\n      var f = s === o,\n          h = n.edge(i).weight;\n\n      if (a += f ? h : -h, u = t, c = d, e.hasEdge(u, c)) {\n        var l = e.edge(t, d).cutvalue;\n        a += f ? -l : l;\n      }\n    }\n  }), a;\n}\n\nfunction xa(e, n) {\n  arguments.length < 2 && (n = e.nodes()[0]), Na(e, {}, 1, n);\n}\n\nfunction Na(e, n, t, r, o) {\n  var i = t,\n      a = e.node(r);\n  return n[r] = !0, Hi.forEach(e.neighbors(r), function (o) {\n    Hi.has(n, o) || (t = Na(e, n, t, o, r));\n  }), a.low = i, a.lim = t++, o ? a.parent = o : delete a.parent, t;\n}\n\nfunction Oa(e) {\n  return Hi.find(e.edges(), function (n) {\n    return e.edge(n).cutvalue < 0;\n  });\n}\n\nfunction ka(e, n, t) {\n  var r = t.v,\n      o = t.w;\n  n.hasEdge(r, o) || (r = t.w, o = t.v);\n  var i = e.node(r),\n      a = e.node(o),\n      u = i,\n      c = !1;\n  i.lim > a.lim && (u = a, c = !0);\n  var s = Hi.filter(n.edges(), function (n) {\n    return c === Sa(e, e.node(n.v), u) && c !== Sa(e, e.node(n.w), u);\n  });\n  return Hi.minBy(s, function (e) {\n    return pa(n, e);\n  });\n}\n\nfunction Ia(e, n, t, r) {\n  var o = t.v,\n      i = t.w;\n  e.removeEdge(o, i), e.setEdge(r.v, r.w, {}), xa(e), _a(e, n), function (e, n) {\n    var t = Hi.find(e.nodes(), function (e) {\n      return !n.node(e).parent;\n    }),\n        r = ya(e, t);\n    r = r.slice(1), Hi.forEach(r, function (t) {\n      var r = e.node(t).parent,\n          o = n.edge(t, r),\n          i = !1;\n      o || (o = n.edge(r, t), i = !0), n.node(t).rank = n.node(r).rank + (i ? o.minlen : -o.minlen);\n    });\n  }(e, n);\n}\n\nfunction Sa(e, n, t) {\n  return t.low <= n.lim && n.lim <= t.lim;\n}\n\nEa.initLowLimValues = xa, Ea.initCutValues = _a, Ea.calcCutValue = ja, Ea.leaveEdge = Oa, Ea.enterEdge = ka, Ea.exchangeEdges = Ia;\n\nvar Ma = ua,\n    Ca = function Ca(e) {\n  switch (e.graph().ranker) {\n    case \"network-simplex\":\n      Ba(e);\n      break;\n\n    case \"tight-tree\":\n      !function (e) {\n        Ma(e), fa(e);\n      }(e);\n      break;\n\n    case \"longest-path\":\n      Ga(e);\n      break;\n\n    default:\n      Ba(e);\n  }\n};\n\nvar Ga = Ma;\n\nfunction Ba(e) {\n  wa(e);\n}\n\nvar Aa = function Aa(e) {\n  var n = function (e) {\n    var n = {},\n        t = 0;\n\n    function r(o) {\n      var i = t;\n      Hi.forEach(e.children(o), r), n[o] = {\n        low: i,\n        lim: t++\n      };\n    }\n\n    return Hi.forEach(e.children(), r), n;\n  }(e);\n\n  Hi.forEach(e.graph().dummyChains, function (t) {\n    for (var r = e.node(t), o = r.edgeObj, i = function (e, n, t, r) {\n      var o,\n          i,\n          a = [],\n          u = [],\n          c = Math.min(n[t].low, n[r].low),\n          s = Math.max(n[t].lim, n[r].lim);\n      o = t;\n\n      do {\n        o = e.parent(o), a.push(o);\n      } while (o && (n[o].low > c || s > n[o].lim));\n\n      i = o, o = r;\n\n      for (; (o = e.parent(o)) !== i;) {\n        u.push(o);\n      }\n\n      return {\n        path: a.concat(u.reverse()),\n        lca: i\n      };\n    }(e, n, o.v, o.w), a = i.path, u = i.lca, c = 0, s = a[c], d = !0; t !== o.w;) {\n      if (r = e.node(t), d) {\n        for (; (s = a[c]) !== u && e.node(s).maxRank < r.rank;) {\n          c++;\n        }\n\n        s === u && (d = !1);\n      }\n\n      if (!d) {\n        for (; c < a.length - 1 && e.node(s = a[c + 1]).minRank <= r.rank;) {\n          c++;\n        }\n\n        s = a[c];\n      }\n\n      e.setParent(t, s), t = e.successors(t)[0];\n    }\n  });\n};\n\nvar La = {\n  run: function run(e) {\n    var n = ra.addDummyNode(e, \"root\", {}, \"_root\"),\n        t = function (e) {\n      var n = {};\n\n      function t(r, o) {\n        var i = e.children(r);\n        i && i.length && Hi.forEach(i, function (e) {\n          t(e, o + 1);\n        }), n[r] = o;\n      }\n\n      return Hi.forEach(e.children(), function (e) {\n        t(e, 1);\n      }), n;\n    }(e),\n        r = Hi.max(Hi.values(t)) - 1,\n        o = 2 * r + 1;\n\n    e.graph().nestingRoot = n, Hi.forEach(e.edges(), function (n) {\n      e.edge(n).minlen *= o;\n    });\n\n    var i = function (e) {\n      return Hi.reduce(e.edges(), function (n, t) {\n        return n + e.edge(t).weight;\n      }, 0);\n    }(e) + 1;\n\n    Hi.forEach(e.children(), function (a) {\n      Ra(e, n, o, i, r, t, a);\n    }), e.graph().nodeRankFactor = o;\n  },\n  cleanup: function cleanup(e) {\n    var n = e.graph();\n    e.removeNode(n.nestingRoot), delete n.nestingRoot, Hi.forEach(e.edges(), function (n) {\n      e.edge(n).nestingEdge && e.removeEdge(n);\n    });\n  }\n};\n\nfunction Ra(e, n, t, r, o, i, a) {\n  var u = e.children(a);\n\n  if (u.length) {\n    var c = ra.addBorderNode(e, \"_bt\"),\n        s = ra.addBorderNode(e, \"_bb\"),\n        d = e.node(a);\n    e.setParent(c, a), d.borderTop = c, e.setParent(s, a), d.borderBottom = s, Hi.forEach(u, function (u) {\n      Ra(e, n, t, r, o, i, u);\n      var d = e.node(u),\n          f = d.borderTop ? d.borderTop : u,\n          h = d.borderBottom ? d.borderBottom : u,\n          l = d.borderTop ? r : 2 * r,\n          v = f !== h ? 1 : o - i[a] + 1;\n      e.setEdge(c, f, {\n        weight: l,\n        minlen: v,\n        nestingEdge: !0\n      }), e.setEdge(h, s, {\n        weight: l,\n        minlen: v,\n        nestingEdge: !0\n      });\n    }), e.parent(a) || e.setEdge(n, c, {\n      weight: 0,\n      minlen: o + i[a]\n    });\n  } else a !== n && e.setEdge(n, a, {\n    weight: 0,\n    minlen: t\n  });\n}\n\nvar Ta = function Ta(e) {\n  Hi.forEach(e.children(), function n(t) {\n    var r = e.children(t),\n        o = e.node(t);\n\n    if (r.length && Hi.forEach(r, n), Hi.has(o, \"minRank\")) {\n      o.borderLeft = [], o.borderRight = [];\n\n      for (var i = o.minRank, a = o.maxRank + 1; i < a; ++i) {\n        Da(e, \"borderLeft\", \"_bl\", t, o, i), Da(e, \"borderRight\", \"_br\", t, o, i);\n      }\n    }\n  });\n};\n\nfunction Da(e, n, t, r, o, i) {\n  var a = {\n    width: 0,\n    height: 0,\n    rank: i,\n    borderType: n\n  },\n      u = o[n][i - 1],\n      c = ra.addDummyNode(e, \"border\", a, t);\n  o[n][i] = c, e.setParent(c, r), u && e.setEdge(u, c, {\n    weight: 1\n  });\n}\n\nvar Pa = {\n  adjust: function adjust(e) {\n    var n = e.graph().rankdir.toLowerCase();\n    \"lr\" !== n && \"rl\" !== n || za(e);\n  },\n  undo: function undo(e) {\n    var n = e.graph().rankdir.toLowerCase();\n    \"bt\" !== n && \"rl\" !== n || function (e) {\n      Hi.forEach(e.nodes(), function (n) {\n        Ua(e.node(n));\n      }), Hi.forEach(e.edges(), function (n) {\n        var t = e.edge(n);\n        Hi.forEach(t.points, Ua), Hi.has(t, \"y\") && Ua(t);\n      });\n    }(e);\n    \"lr\" !== n && \"rl\" !== n || (!function (e) {\n      Hi.forEach(e.nodes(), function (n) {\n        Va(e.node(n));\n      }), Hi.forEach(e.edges(), function (n) {\n        var t = e.edge(n);\n        Hi.forEach(t.points, Va), Hi.has(t, \"x\") && Va(t);\n      });\n    }(e), za(e));\n  }\n};\n\nfunction za(e) {\n  Hi.forEach(e.nodes(), function (n) {\n    Fa(e.node(n));\n  }), Hi.forEach(e.edges(), function (n) {\n    Fa(e.edge(n));\n  });\n}\n\nfunction Fa(e) {\n  var n = e.width;\n  e.width = e.height, e.height = n;\n}\n\nfunction Ua(e) {\n  e.y = -e.y;\n}\n\nfunction Va(e) {\n  var n = e.x;\n  e.x = e.y, e.y = n;\n}\n\nvar $a = function $a(e) {\n  var n = {},\n      t = Hi.filter(e.nodes(), function (n) {\n    return !e.children(n).length;\n  }),\n      r = Hi.max(Hi.map(t, function (n) {\n    return e.node(n).rank;\n  })),\n      o = Hi.map(Hi.range(r + 1), function () {\n    return [];\n  });\n\n  function i(t) {\n    if (!Hi.has(n, t)) {\n      n[t] = !0;\n      var r = e.node(t);\n      o[r.rank].push(t), Hi.forEach(e.successors(t), i);\n    }\n  }\n\n  var a = Hi.sortBy(t, function (n) {\n    return e.node(n).rank;\n  });\n  return Hi.forEach(a, i), o;\n};\n\nvar Ha = function Ha(e, n) {\n  for (var t = 0, r = 1; r < n.length; ++r) {\n    t += Wa(e, n[r - 1], n[r]);\n  }\n\n  return t;\n};\n\nfunction Wa(e, n, t) {\n  for (var r = Hi.zipObject(t, Hi.map(t, function (e, n) {\n    return n;\n  })), o = Hi.flatten(Hi.map(n, function (n) {\n    return Hi.sortBy(Hi.map(e.outEdges(n), function (n) {\n      return {\n        pos: r[n.w],\n        weight: e.edge(n).weight\n      };\n    }), \"pos\");\n  }), !0), i = 1; i < t.length;) {\n    i <<= 1;\n  }\n\n  var a = 2 * i - 1;\n  i -= 1;\n  var u = Hi.map(new Array(a), function () {\n    return 0;\n  }),\n      c = 0;\n  return Hi.forEach(o.forEach(function (e) {\n    var n = e.pos + i;\n    u[n] += e.weight;\n\n    for (var t = 0; n > 0;) {\n      n % 2 && (t += u[n + 1]), u[n = n - 1 >> 1] += e.weight;\n    }\n\n    c += e.weight * t;\n  })), c;\n}\n\nvar qa = function qa(e, n) {\n  return Hi.map(n, function (n) {\n    var t = e.inEdges(n);\n\n    if (t.length) {\n      var r = Hi.reduce(t, function (n, t) {\n        var r = e.edge(t),\n            o = e.node(t.v);\n        return {\n          sum: n.sum + r.weight * o.order,\n          weight: n.weight + r.weight\n        };\n      }, {\n        sum: 0,\n        weight: 0\n      });\n      return {\n        v: n,\n        barycenter: r.sum / r.weight,\n        weight: r.weight\n      };\n    }\n\n    return {\n      v: n\n    };\n  });\n};\n\nvar Ya = function Ya(e, n) {\n  var t = {};\n  return Hi.forEach(e, function (e, n) {\n    var r = t[e.v] = {\n      indegree: 0,\n      in: [],\n      out: [],\n      vs: [e.v],\n      i: n\n    };\n    Hi.isUndefined(e.barycenter) || (r.barycenter = e.barycenter, r.weight = e.weight);\n  }), Hi.forEach(n.edges(), function (e) {\n    var n = t[e.v],\n        r = t[e.w];\n    Hi.isUndefined(n) || Hi.isUndefined(r) || (r.indegree++, n.out.push(t[e.w]));\n  }), function (e) {\n    var n = [];\n\n    function t(e) {\n      return function (n) {\n        n.merged || (Hi.isUndefined(n.barycenter) || Hi.isUndefined(e.barycenter) || n.barycenter >= e.barycenter) && function (e, n) {\n          var t = 0,\n              r = 0;\n          e.weight && (t += e.barycenter * e.weight, r += e.weight);\n          n.weight && (t += n.barycenter * n.weight, r += n.weight);\n          e.vs = n.vs.concat(e.vs), e.barycenter = t / r, e.weight = r, e.i = Math.min(n.i, e.i), n.merged = !0;\n        }(e, n);\n      };\n    }\n\n    function r(n) {\n      return function (t) {\n        t.in.push(n), 0 == --t.indegree && e.push(t);\n      };\n    }\n\n    for (; e.length;) {\n      var o = e.pop();\n      n.push(o), Hi.forEach(o.in.reverse(), t(o)), Hi.forEach(o.out, r(o));\n    }\n\n    return Hi.map(Hi.filter(n, function (e) {\n      return !e.merged;\n    }), function (e) {\n      return Hi.pick(e, [\"vs\", \"i\", \"barycenter\", \"weight\"]);\n    });\n  }(Hi.filter(t, function (e) {\n    return !e.indegree;\n  }));\n};\n\nvar Ja = function Ja(e, n) {\n  var t = ra.partition(e, function (e) {\n    return Hi.has(e, \"barycenter\");\n  }),\n      r = t.lhs,\n      o = Hi.sortBy(t.rhs, function (e) {\n    return -e.i;\n  }),\n      i = [],\n      a = 0,\n      u = 0,\n      c = 0;\n  r.sort((s = !!n, function (e, n) {\n    return e.barycenter < n.barycenter ? -1 : e.barycenter > n.barycenter ? 1 : s ? n.i - e.i : e.i - n.i;\n  })), c = Xa(i, o, c), Hi.forEach(r, function (e) {\n    c += e.vs.length, i.push(e.vs), a += e.barycenter * e.weight, u += e.weight, c = Xa(i, o, c);\n  });\n  var s;\n  var d = {\n    vs: Hi.flatten(i, !0)\n  };\n  u && (d.barycenter = a / u, d.weight = u);\n  return d;\n};\n\nfunction Xa(e, n, t) {\n  for (var r; n.length && (r = Hi.last(n)).i <= t;) {\n    n.pop(), e.push(r.vs), t++;\n  }\n\n  return t;\n}\n\nvar Ka = function e(n, t, r, o) {\n  var i = n.children(t),\n      a = n.node(t),\n      u = a ? a.borderLeft : void 0,\n      c = a ? a.borderRight : void 0,\n      s = {};\n  u && (i = Hi.filter(i, function (e) {\n    return e !== u && e !== c;\n  }));\n  var d = qa(n, i);\n  Hi.forEach(d, function (t) {\n    if (n.children(t.v).length) {\n      var i = e(n, t.v, r, o);\n      s[t.v] = i, Hi.has(i, \"barycenter\") && (a = t, u = i, Hi.isUndefined(a.barycenter) ? (a.barycenter = u.barycenter, a.weight = u.weight) : (a.barycenter = (a.barycenter * a.weight + u.barycenter * u.weight) / (a.weight + u.weight), a.weight += u.weight));\n    }\n\n    var a, u;\n  });\n  var f = Ya(d, r);\n  !function (e, n) {\n    Hi.forEach(e, function (e) {\n      e.vs = Hi.flatten(e.vs.map(function (e) {\n        return n[e] ? n[e].vs : e;\n      }), !0);\n    });\n  }(f, s);\n  var h = Ja(f, o);\n\n  if (u && (h.vs = Hi.flatten([u, h.vs, c], !0), n.predecessors(u).length)) {\n    var l = n.node(n.predecessors(u)[0]),\n        v = n.node(n.predecessors(c)[0]);\n    Hi.has(h, \"barycenter\") || (h.barycenter = 0, h.weight = 0), h.barycenter = (h.barycenter * h.weight + l.order + v.order) / (h.weight + 2), h.weight += 2;\n  }\n\n  return h;\n};\n\nvar Qa = Fo.Graph,\n    Za = function Za(e, n, t) {\n  var r = function (e) {\n    var n;\n\n    for (; e.hasNode(n = Hi.uniqueId(\"_root\"));) {\n      ;\n    }\n\n    return n;\n  }(e),\n      o = new Qa({\n    compound: !0\n  }).setGraph({\n    root: r\n  }).setDefaultNodeLabel(function (n) {\n    return e.node(n);\n  });\n\n  return Hi.forEach(e.nodes(), function (i) {\n    var a = e.node(i),\n        u = e.parent(i);\n    (a.rank === n || a.minRank <= n && n <= a.maxRank) && (o.setNode(i), o.setParent(i, u || r), Hi.forEach(e[t](i), function (n) {\n      var t = n.v === i ? n.w : n.v,\n          r = o.edge(t, i),\n          a = Hi.isUndefined(r) ? 0 : r.weight;\n      o.setEdge(t, i, {\n        weight: e.edge(n).weight + a\n      });\n    }), Hi.has(a, \"minRank\") && o.setNode(i, {\n      borderLeft: a.borderLeft[n],\n      borderRight: a.borderRight[n]\n    }));\n  }), o;\n};\n\nvar eu = function eu(e, n, t) {\n  var r,\n      o = {};\n  Hi.forEach(t, function (t) {\n    for (var i, a, u = e.parent(t); u;) {\n      if ((i = e.parent(u)) ? (a = o[i], o[i] = u) : (a = r, r = u), a && a !== u) return void n.setEdge(a, u);\n      u = i;\n    }\n  });\n};\n\nvar nu = Fo.Graph,\n    tu = function tu(e) {\n  var n = ra.maxRank(e),\n      t = ru(e, Hi.range(1, n + 1), \"inEdges\"),\n      r = ru(e, Hi.range(n - 1, -1, -1), \"outEdges\"),\n      o = $a(e);\n  iu(e, o);\n\n  for (var i, a = Number.POSITIVE_INFINITY, u = 0, c = 0; c < 4; ++u, ++c) {\n    ou(u % 2 ? t : r, u % 4 >= 2), o = ra.buildLayerMatrix(e);\n    var s = Ha(e, o);\n    s < a && (c = 0, i = Hi.cloneDeep(o), a = s);\n  }\n\n  iu(e, i);\n};\n\nfunction ru(e, n, t) {\n  return Hi.map(n, function (n) {\n    return Za(e, n, t);\n  });\n}\n\nfunction ou(e, n) {\n  var t = new nu();\n  Hi.forEach(e, function (e) {\n    var r = e.graph().root,\n        o = Ka(e, r, t, n);\n    Hi.forEach(o.vs, function (n, t) {\n      e.node(n).order = t;\n    }), eu(e, t, o.vs);\n  });\n}\n\nfunction iu(e, n) {\n  Hi.forEach(n, function (n) {\n    Hi.forEach(n, function (n, t) {\n      e.node(n).order = t;\n    });\n  });\n}\n\nvar au = Fo.Graph,\n    uu = function uu(e) {\n  var n,\n      t = ra.buildLayerMatrix(e),\n      r = Hi.merge(cu(e, t), su(e, t)),\n      o = {};\n  Hi.forEach([\"u\", \"d\"], function (i) {\n    n = \"u\" === i ? t : Hi.values(t).reverse(), Hi.forEach([\"l\", \"r\"], function (t) {\n      \"r\" === t && (n = Hi.map(n, function (e) {\n        return Hi.values(e).reverse();\n      }));\n      var a = (\"u\" === i ? e.predecessors : e.successors).bind(e),\n          u = hu(e, n, r, a),\n          c = lu(e, n, u.root, u.align, \"r\" === t);\n      \"r\" === t && (c = Hi.mapValues(c, function (e) {\n        return -e;\n      })), o[i + t] = c;\n    });\n  });\n  var i = vu(e, o);\n  return pu(o, i), gu(o, e.graph().align);\n};\n\nfunction cu(e, n) {\n  var t = {};\n  return Hi.reduce(n, function (n, r) {\n    var o = 0,\n        i = 0,\n        a = n.length,\n        u = Hi.last(r);\n    return Hi.forEach(r, function (n, c) {\n      var s = function (e, n) {\n        if (e.node(n).dummy) return Hi.find(e.predecessors(n), function (n) {\n          return e.node(n).dummy;\n        });\n      }(e, n),\n          d = s ? e.node(s).order : a;\n\n      (s || n === u) && (Hi.forEach(r.slice(i, c + 1), function (n) {\n        Hi.forEach(e.predecessors(n), function (r) {\n          var i = e.node(r),\n              a = i.order;\n          !(a < o || d < a) || i.dummy && e.node(n).dummy || du(t, r, n);\n        });\n      }), i = c + 1, o = d);\n    }), r;\n  }), t;\n}\n\nfunction su(e, n) {\n  var t = {};\n\n  function r(n, r, o, i, a) {\n    var u;\n    Hi.forEach(Hi.range(r, o), function (r) {\n      u = n[r], e.node(u).dummy && Hi.forEach(e.predecessors(u), function (n) {\n        var r = e.node(n);\n        r.dummy && (r.order < i || r.order > a) && du(t, n, u);\n      });\n    });\n  }\n\n  return Hi.reduce(n, function (n, t) {\n    var o,\n        i = -1,\n        a = 0;\n    return Hi.forEach(t, function (u, c) {\n      if (\"border\" === e.node(u).dummy) {\n        var s = e.predecessors(u);\n        s.length && (o = e.node(s[0]).order, r(t, a, c, i, o), a = c, i = o);\n      }\n\n      r(t, a, t.length, o, n.length);\n    }), t;\n  }), t;\n}\n\nfunction du(e, n, t) {\n  if (n > t) {\n    var r = n;\n    n = t, t = r;\n  }\n\n  var o = e[n];\n  o || (e[n] = o = {}), o[t] = !0;\n}\n\nfunction fu(e, n, t) {\n  if (n > t) {\n    var r = n;\n    n = t, t = r;\n  }\n\n  return Hi.has(e[n], t);\n}\n\nfunction hu(e, n, t, r) {\n  var o = {},\n      i = {},\n      a = {};\n  return Hi.forEach(n, function (e) {\n    Hi.forEach(e, function (e, n) {\n      o[e] = e, i[e] = e, a[e] = n;\n    });\n  }), Hi.forEach(n, function (e) {\n    var n = -1;\n    Hi.forEach(e, function (e) {\n      var u = r(e);\n      if (u.length) for (var c = ((u = Hi.sortBy(u, function (e) {\n        return a[e];\n      })).length - 1) / 2, s = Math.floor(c), d = Math.ceil(c); s <= d; ++s) {\n        var f = u[s];\n        i[e] === e && n < a[f] && !fu(t, e, f) && (i[f] = e, i[e] = o[e] = o[f], n = a[f]);\n      }\n    });\n  }), {\n    root: o,\n    align: i\n  };\n}\n\nfunction lu(e, n, t, r, o) {\n  var i = {},\n      a = function (e, n, t, r) {\n    var o = new au(),\n        i = e.graph(),\n        a = function (e, n, t) {\n      return function (r, o, i) {\n        var a,\n            u = r.node(o),\n            c = r.node(i),\n            s = 0;\n        if (s += u.width / 2, Hi.has(u, \"labelpos\")) switch (u.labelpos.toLowerCase()) {\n          case \"l\":\n            a = -u.width / 2;\n            break;\n\n          case \"r\":\n            a = u.width / 2;\n        }\n        if (a && (s += t ? a : -a), a = 0, s += (u.dummy ? n : e) / 2, s += (c.dummy ? n : e) / 2, s += c.width / 2, Hi.has(c, \"labelpos\")) switch (c.labelpos.toLowerCase()) {\n          case \"l\":\n            a = c.width / 2;\n            break;\n\n          case \"r\":\n            a = -c.width / 2;\n        }\n        return a && (s += t ? a : -a), a = 0, s;\n      };\n    }(i.nodesep, i.edgesep, r);\n\n    return Hi.forEach(n, function (n) {\n      var r;\n      Hi.forEach(n, function (n) {\n        var i = t[n];\n\n        if (o.setNode(i), r) {\n          var u = t[r],\n              c = o.edge(u, i);\n          o.setEdge(u, i, Math.max(a(e, n, r), c || 0));\n        }\n\n        r = n;\n      });\n    }), o;\n  }(e, n, t, o),\n      u = o ? \"borderLeft\" : \"borderRight\";\n\n  function c(e, n) {\n    for (var t = a.nodes(), r = t.pop(), o = {}; r;) {\n      o[r] ? e(r) : (o[r] = !0, t.push(r), t = t.concat(n(r))), r = t.pop();\n    }\n  }\n\n  return c(function (e) {\n    i[e] = a.inEdges(e).reduce(function (e, n) {\n      return Math.max(e, i[n.v] + a.edge(n));\n    }, 0);\n  }, a.predecessors.bind(a)), c(function (n) {\n    var t = a.outEdges(n).reduce(function (e, n) {\n      return Math.min(e, i[n.w] - a.edge(n));\n    }, Number.POSITIVE_INFINITY),\n        r = e.node(n);\n    t !== Number.POSITIVE_INFINITY && r.borderType !== u && (i[n] = Math.max(i[n], t));\n  }, a.successors.bind(a)), Hi.forEach(r, function (e) {\n    i[e] = i[t[e]];\n  }), i;\n}\n\nfunction vu(e, n) {\n  return Hi.minBy(Hi.values(n), function (n) {\n    var t = Number.NEGATIVE_INFINITY,\n        r = Number.POSITIVE_INFINITY;\n    return Hi.forIn(n, function (n, o) {\n      var i = function (e, n) {\n        return e.node(n).width;\n      }(e, o) / 2;\n\n      t = Math.max(n + i, t), r = Math.min(n - i, r);\n    }), t - r;\n  });\n}\n\nfunction pu(e, n) {\n  var t = Hi.values(n),\n      r = Hi.min(t),\n      o = Hi.max(t);\n  Hi.forEach([\"u\", \"d\"], function (t) {\n    Hi.forEach([\"l\", \"r\"], function (i) {\n      var a,\n          u = t + i,\n          c = e[u];\n\n      if (c !== n) {\n        var s = Hi.values(c);\n        (a = \"l\" === i ? r - Hi.min(s) : o - Hi.max(s)) && (e[u] = Hi.mapValues(c, function (e) {\n          return e + a;\n        }));\n      }\n    });\n  });\n}\n\nfunction gu(e, n) {\n  return Hi.mapValues(e.ul, function (t, r) {\n    if (n) return e[n.toLowerCase()][r];\n    var o = Hi.sortBy(Hi.map(e, r));\n    return (o[1] + o[2]) / 2;\n  });\n}\n\nvar yu = uu,\n    bu = function bu(e) {\n  (function (e) {\n    var n = ra.buildLayerMatrix(e),\n        t = e.graph().ranksep,\n        r = 0;\n    Hi.forEach(n, function (n) {\n      var o = Hi.max(Hi.map(n, function (n) {\n        return e.node(n).height;\n      }));\n      Hi.forEach(n, function (n) {\n        e.node(n).y = r + o / 2;\n      }), r += o + t;\n    });\n  })(e = ra.asNonCompoundGraph(e)), Hi.forEach(yu(e), function (n, t) {\n    e.node(t).x = n;\n  });\n};\n\nvar mu = ra.normalizeRanks,\n    wu = ra.removeEmptyRanks,\n    Eu = ra,\n    _u = Fo.Graph,\n    ju = function ju(e, n) {\n  var t = n && n.debugTiming ? Eu.time : Eu.notime;\n  t(\"layout\", function () {\n    var n = t(\"  buildLayoutGraph\", function () {\n      return function (e) {\n        var n = new _u({\n          multigraph: !0,\n          compound: !0\n        }),\n            t = Bu(e.graph());\n        return n.setGraph(Hi.merge({}, Nu, Gu(t, xu), Hi.pick(t, Ou))), Hi.forEach(e.nodes(), function (t) {\n          var r = Bu(e.node(t));\n          n.setNode(t, Hi.defaults(Gu(r, ku), Iu)), n.setParent(t, e.parent(t));\n        }), Hi.forEach(e.edges(), function (t) {\n          var r = Bu(e.edge(t));\n          n.setEdge(t, Hi.merge({}, Mu, Gu(r, Su), Hi.pick(r, Cu)));\n        }), n;\n      }(e);\n    });\n    t(\"  runLayout\", function () {\n      !function (e, n) {\n        n(\"    makeSpaceForEdgeLabels\", function () {\n          !function (e) {\n            var n = e.graph();\n            n.ranksep /= 2, Hi.forEach(e.edges(), function (t) {\n              var r = e.edge(t);\n              r.minlen *= 2, \"c\" !== r.labelpos.toLowerCase() && (\"TB\" === n.rankdir || \"BT\" === n.rankdir ? r.width += r.labeloffset : r.height += r.labeloffset);\n            });\n          }(e);\n        }), n(\"    removeSelfEdges\", function () {\n          !function (e) {\n            Hi.forEach(e.edges(), function (n) {\n              if (n.v === n.w) {\n                var t = e.node(n.v);\n                t.selfEdges || (t.selfEdges = []), t.selfEdges.push({\n                  e: n,\n                  label: e.edge(n)\n                }), e.removeEdge(n);\n              }\n            });\n          }(e);\n        }), n(\"    acyclic\", function () {\n          na.run(e);\n        }), n(\"    nestingGraph.run\", function () {\n          La.run(e);\n        }), n(\"    rank\", function () {\n          Ca(Eu.asNonCompoundGraph(e));\n        }), n(\"    injectEdgeLabelProxies\", function () {\n          !function (e) {\n            Hi.forEach(e.edges(), function (n) {\n              var t = e.edge(n);\n\n              if (t.width && t.height) {\n                var r = e.node(n.v),\n                    o = {\n                  rank: (e.node(n.w).rank - r.rank) / 2 + r.rank,\n                  e: n\n                };\n                Eu.addDummyNode(e, \"edge-proxy\", o, \"_ep\");\n              }\n            });\n          }(e);\n        }), n(\"    removeEmptyRanks\", function () {\n          wu(e);\n        }), n(\"    nestingGraph.cleanup\", function () {\n          La.cleanup(e);\n        }), n(\"    normalizeRanks\", function () {\n          mu(e);\n        }), n(\"    assignRankMinMax\", function () {\n          !function (e) {\n            var n = 0;\n            Hi.forEach(e.nodes(), function (t) {\n              var r = e.node(t);\n              r.borderTop && (r.minRank = e.node(r.borderTop).rank, r.maxRank = e.node(r.borderBottom).rank, n = Hi.max(n, r.maxRank));\n            }), e.graph().maxRank = n;\n          }(e);\n        }), n(\"    removeEdgeLabelProxies\", function () {\n          !function (e) {\n            Hi.forEach(e.nodes(), function (n) {\n              var t = e.node(n);\n              \"edge-proxy\" === t.dummy && (e.edge(t.e).labelRank = t.rank, e.removeNode(n));\n            });\n          }(e);\n        }), n(\"    normalize.run\", function () {\n          aa.run(e);\n        }), n(\"    parentDummyChains\", function () {\n          Aa(e);\n        }), n(\"    addBorderSegments\", function () {\n          Ta(e);\n        }), n(\"    order\", function () {\n          tu(e);\n        }), n(\"    insertSelfEdges\", function () {\n          !function (e) {\n            var n = Eu.buildLayerMatrix(e);\n            Hi.forEach(n, function (n) {\n              var t = 0;\n              Hi.forEach(n, function (n, r) {\n                var o = e.node(n);\n                o.order = r + t, Hi.forEach(o.selfEdges, function (n) {\n                  Eu.addDummyNode(e, \"selfedge\", {\n                    width: n.label.width,\n                    height: n.label.height,\n                    rank: o.rank,\n                    order: r + ++t,\n                    e: n.e,\n                    label: n.label\n                  }, \"_se\");\n                }), delete o.selfEdges;\n              });\n            });\n          }(e);\n        }), n(\"    adjustCoordinateSystem\", function () {\n          Pa.adjust(e);\n        }), n(\"    position\", function () {\n          bu(e);\n        }), n(\"    positionSelfEdges\", function () {\n          !function (e) {\n            Hi.forEach(e.nodes(), function (n) {\n              var t = e.node(n);\n\n              if (\"selfedge\" === t.dummy) {\n                var r = e.node(t.e.v),\n                    o = r.x + r.width / 2,\n                    i = r.y,\n                    a = t.x - o,\n                    u = r.height / 2;\n                e.setEdge(t.e, t.label), e.removeNode(n), t.label.points = [{\n                  x: o + 2 * a / 3,\n                  y: i - u\n                }, {\n                  x: o + 5 * a / 6,\n                  y: i - u\n                }, {\n                  x: o + a,\n                  y: i\n                }, {\n                  x: o + 5 * a / 6,\n                  y: i + u\n                }, {\n                  x: o + 2 * a / 3,\n                  y: i + u\n                }], t.label.x = t.x, t.label.y = t.y;\n              }\n            });\n          }(e);\n        }), n(\"    removeBorderNodes\", function () {\n          !function (e) {\n            Hi.forEach(e.nodes(), function (n) {\n              if (e.children(n).length) {\n                var t = e.node(n),\n                    r = e.node(t.borderTop),\n                    o = e.node(t.borderBottom),\n                    i = e.node(Hi.last(t.borderLeft)),\n                    a = e.node(Hi.last(t.borderRight));\n                t.width = Math.abs(a.x - i.x), t.height = Math.abs(o.y - r.y), t.x = i.x + t.width / 2, t.y = r.y + t.height / 2;\n              }\n            }), Hi.forEach(e.nodes(), function (n) {\n              \"border\" === e.node(n).dummy && e.removeNode(n);\n            });\n          }(e);\n        }), n(\"    normalize.undo\", function () {\n          aa.undo(e);\n        }), n(\"    fixupEdgeLabelCoords\", function () {\n          !function (e) {\n            Hi.forEach(e.edges(), function (n) {\n              var t = e.edge(n);\n              if (Hi.has(t, \"x\")) switch (\"l\" !== t.labelpos && \"r\" !== t.labelpos || (t.width -= t.labeloffset), t.labelpos) {\n                case \"l\":\n                  t.x -= t.width / 2 + t.labeloffset;\n                  break;\n\n                case \"r\":\n                  t.x += t.width / 2 + t.labeloffset;\n              }\n            });\n          }(e);\n        }), n(\"    undoCoordinateSystem\", function () {\n          Pa.undo(e);\n        }), n(\"    translateGraph\", function () {\n          !function (e) {\n            var n = Number.POSITIVE_INFINITY,\n                t = 0,\n                r = Number.POSITIVE_INFINITY,\n                o = 0,\n                i = e.graph(),\n                a = i.marginx || 0,\n                u = i.marginy || 0;\n\n            function c(e) {\n              var i = e.x,\n                  a = e.y,\n                  u = e.width,\n                  c = e.height;\n              n = Math.min(n, i - u / 2), t = Math.max(t, i + u / 2), r = Math.min(r, a - c / 2), o = Math.max(o, a + c / 2);\n            }\n\n            Hi.forEach(e.nodes(), function (n) {\n              c(e.node(n));\n            }), Hi.forEach(e.edges(), function (n) {\n              var t = e.edge(n);\n              Hi.has(t, \"x\") && c(t);\n            }), n -= a, r -= u, Hi.forEach(e.nodes(), function (t) {\n              var o = e.node(t);\n              o.x -= n, o.y -= r;\n            }), Hi.forEach(e.edges(), function (t) {\n              var o = e.edge(t);\n              Hi.forEach(o.points, function (e) {\n                e.x -= n, e.y -= r;\n              }), Hi.has(o, \"x\") && (o.x -= n), Hi.has(o, \"y\") && (o.y -= r);\n            }), i.width = t - n + a, i.height = o - r + u;\n          }(e);\n        }), n(\"    assignNodeIntersects\", function () {\n          !function (e) {\n            Hi.forEach(e.edges(), function (n) {\n              var t,\n                  r,\n                  o = e.edge(n),\n                  i = e.node(n.v),\n                  a = e.node(n.w);\n              o.points ? (t = o.points[0], r = o.points[o.points.length - 1]) : (o.points = [], t = a, r = i), o.points.unshift(Eu.intersectRect(i, t)), o.points.push(Eu.intersectRect(a, r));\n            });\n          }(e);\n        }), n(\"    reversePoints\", function () {\n          !function (e) {\n            Hi.forEach(e.edges(), function (n) {\n              var t = e.edge(n);\n              t.reversed && t.points.reverse();\n            });\n          }(e);\n        }), n(\"    acyclic.undo\", function () {\n          na.undo(e);\n        });\n      }(n, t);\n    }), t(\"  updateInputGraph\", function () {\n      !function (e, n) {\n        Hi.forEach(e.nodes(), function (t) {\n          var r = e.node(t),\n              o = n.node(t);\n          r && (r.x = o.x, r.y = o.y, n.children(t).length && (r.width = o.width, r.height = o.height));\n        }), Hi.forEach(e.edges(), function (t) {\n          var r = e.edge(t),\n              o = n.edge(t);\n          r.points = o.points, Hi.has(o, \"x\") && (r.x = o.x, r.y = o.y);\n        }), e.graph().width = n.graph().width, e.graph().height = n.graph().height;\n      }(e, n);\n    });\n  });\n};\n\nvar xu = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"],\n    Nu = {\n  ranksep: 50,\n  edgesep: 20,\n  nodesep: 50,\n  rankdir: \"tb\"\n},\n    Ou = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"],\n    ku = [\"width\", \"height\"],\n    Iu = {\n  width: 0,\n  height: 0\n},\n    Su = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"],\n    Mu = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: \"r\"\n},\n    Cu = [\"labelpos\"];\n\nfunction Gu(e, n) {\n  return Hi.mapValues(Hi.pick(e, n), Number);\n}\n\nfunction Bu(e) {\n  var n = {};\n  return Hi.forEach(e, function (e, t) {\n    n[t.toLowerCase()] = e;\n  }), n;\n}\n\nvar Au = Fo.Graph;\nvar Lu = {\n  graphlib: Fo,\n  layout: ju,\n  debug: {\n    debugOrdering: function debugOrdering(e) {\n      var n = ra.buildLayerMatrix(e),\n          t = new Au({\n        compound: !0,\n        multigraph: !0\n      }).setGraph({});\n      return Hi.forEach(e.nodes(), function (n) {\n        t.setNode(n, {\n          label: n\n        }), t.setParent(n, \"layer\" + e.node(n).rank);\n      }), Hi.forEach(e.edges(), function (e) {\n        t.setEdge(e.v, e.w, {}, e.name);\n      }), Hi.forEach(n, function (e, n) {\n        var r = \"layer\" + n;\n        t.setNode(r, {\n          rank: \"same\"\n        }), Hi.reduce(e, function (e, n) {\n          return t.setEdge(e, n, {\n            style: \"invis\"\n          }), n;\n        });\n      }), t;\n    }\n  },\n  util: {\n    time: ra.time,\n    notime: ra.notime\n  },\n  version: \"0.8.5\"\n},\n    Ru = Lu.graphlib,\n    Tu = Lu.layout;\n\nvar Du = function Du(e) {\n  _classCallCheck(this, Du);\n\n  this.cardinality = 1, this.include = a.UNSPECIFIED, this.isGroupNode = !1, this.parentNode = null, this.type = i.NODE, this.name = e.name, this.attr = e.attr || {}, this.inputs = e.inputs, this.path = e.path || [], this.width = e.width, this.height = e.height;\n};\n\nvar Pu = function Pu() {\n  _classCallCheck(this, Pu);\n\n  this.nodes = {}, this.edges = [], this.nodes = {}, this.edges = [];\n};\n\nfunction zu(e) {\n  var n = new Pu();\n  return e.nodes.map(function (e) {\n    return new Du(e);\n  }).forEach(function (e) {\n    n.nodes[e.name] = e, e.inputs.forEach(function (t) {\n      !function (e, n, t) {\n        t.name !== n.name && e.edges.push(Object.assign(Object.assign({}, t.attr), {\n          v: t.name,\n          w: n.name\n        }));\n      }(n, e, t);\n    });\n  }), n;\n}\n\nvar Fu = /*#__PURE__*/function () {\n  function Fu(e) {\n    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Fu);\n\n    this.attr = null, this.bridgeGraph = null, this.cardinality = 0, this.depth = 1, this.include = a.UNSPECIFIED, this.isGroupNode = !0, this.parentNode = null, this.type = i.META, this.path = [], this.name = e, this.metaGraph = Hu(e, u.META, n);\n  }\n\n  _createClass(Fu, [{\n    key: \"getFirstChild\",\n    value: function getFirstChild() {\n      return this.metaGraph.node(this.metaGraph.nodes()[0]);\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var _this = this;\n\n      return this.metaGraph.nodes().map(function (e) {\n        return _this.metaGraph.node(e);\n      });\n    }\n  }, {\n    key: \"leaves\",\n    value: function leaves() {\n      var e,\n          n = [],\n          t = [this];\n\n      for (; t.length;) {\n        var _r2 = t.shift();\n\n        _r2.isGroupNode ? (e = _r2.metaGraph, e.nodes().forEach(function (n) {\n          return t.push(e.node(n));\n        })) : n.push(_r2.name);\n      }\n\n      return n;\n    }\n  }]);\n\n  return Fu;\n}();\n\nvar Uu = /*#__PURE__*/function () {\n  function Uu(e, n) {\n    _classCallCheck(this, Uu);\n\n    this.v = e, this.w = n, this.baseEdgeList = [], this.inbound = null, this.name = null;\n  }\n\n  _createClass(Uu, [{\n    key: \"addBaseEdge\",\n    value: function addBaseEdge(e, n) {\n      this.baseEdgeList.push(e);\n    }\n  }]);\n\n  return Uu;\n}();\n\nfunction Vu(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Fu(e, n);\n}\n\nfunction $u(e, n) {\n  return new Uu(e, n);\n}\n\nfunction Hu(e, n, t) {\n  var r = t || {},\n      o = new Ru.Graph(r);\n  return o.setGraph({\n    name: e,\n    rankdir: r.rankdir,\n    type: n,\n    align: r.align\n  }), o;\n}\n\nvar Wu = /*#__PURE__*/function () {\n  function Wu() {\n    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Wu);\n\n    this.graphOptions = e, this.index = {}, this.graphOptions.compound = !0, this.root = Vu(r, this.graphOptions), this.index[r] = this.root;\n  }\n\n  _createClass(Wu, [{\n    key: \"getNodeMap\",\n    value: function getNodeMap() {\n      return this.index;\n    }\n  }, {\n    key: \"node\",\n    value: function node(e) {\n      return this.index[e];\n    }\n  }, {\n    key: \"setNode\",\n    value: function setNode(e, n) {\n      this.index[e] = n;\n    }\n  }, {\n    key: \"getBridgeGraph\",\n    value: function getBridgeGraph(e) {\n      var _this2 = this;\n\n      var n = this.index[e];\n      if (!n) throw Error(\"Could not find node in hierarchy: \" + e);\n      if (!(\"metaGraph\" in n)) return null;\n      var t = n;\n      if (t.bridgeGraph) return t.bridgeGraph;\n      var r = Hu(o, u.BRIDGE, this.graphOptions);\n      if (t.bridgeGraph = r, !n.parentNode || !(\"metaGraph\" in n.parentNode)) return r;\n      var i = n.parentNode;\n      return [i.metaGraph, this.getBridgeGraph(i.name)].forEach(function (n) {\n        n.edges().filter(function (n) {\n          return n.v === e || n.w === e;\n        }).forEach(function (t) {\n          var o = t.w === e;\n          n.edge(t).baseEdgeList.forEach(function (n) {\n            var _ref = o ? [n.w, t.v] : [n.v, t.w],\n                _ref2 = _slicedToArray(_ref, 2),\n                i = _ref2[0],\n                a = _ref2[1],\n                u = _this2.getChildName(e, i),\n                c = {\n              v: o ? a : u,\n              w: o ? u : a\n            };\n\n            var s = r.edge(c);\n            s || (s = $u(c.v, c.w), s.inbound = o, r.setEdge(c.v, c.w, s)), s.addBaseEdge(n, _this2);\n          });\n        });\n      }), r;\n    }\n  }, {\n    key: \"getChildName\",\n    value: function getChildName(e, n) {\n      var t = this.index[n];\n\n      for (; t;) {\n        if (t.parentNode && t.parentNode.name === e) return t.name;\n        t = t.parentNode;\n      }\n\n      throw Error(\"Could not find immediate child for descendant: \" + n);\n    }\n  }, {\n    key: \"getPredecessors\",\n    value: function getPredecessors(e) {\n      var n = this.index[e];\n      if (!n) throw Error(\"Could not find node with name: \" + e);\n      return this.getOneWayEdges(n, !0);\n    }\n  }, {\n    key: \"getSuccessors\",\n    value: function getSuccessors(e) {\n      var n = this.index[e];\n      if (!n) throw Error(\"Could not find node with name: \" + e);\n      return this.getOneWayEdges(n, !1);\n    }\n  }, {\n    key: \"getOneWayEdges\",\n    value: function getOneWayEdges(e, n) {\n      var t = [];\n      if (!e.parentNode || !e.parentNode.isGroupNode) return t;\n      var r = e.parentNode,\n          o = r.metaGraph,\n          i = this.getBridgeGraph(r.name);\n      return Yu(o, e, n, t), Yu(i, e, n, t), t;\n    }\n  }]);\n\n  return Wu;\n}();\n\nfunction qu(e, n) {\n  var t = n.rankDirection,\n      r = n.align,\n      o = new Wu({\n    rankdir: t,\n    align: r\n  });\n  return function (e, n) {\n    Object.keys(n.nodes).forEach(function (t) {\n      var r = n.nodes[t],\n          o = r.path;\n      var i = e.root;\n      i.depth = Math.max(o.length, i.depth);\n\n      for (var _n2 = 0; _n2 < o.length && (i.depth = Math.max(i.depth, o.length - _n2), i.cardinality += r.cardinality, _n2 !== o.length - 1); _n2++) {\n        var _t2 = o[_n2];\n\n        var _a2 = e.node(_t2);\n\n        _a2 || (_a2 = Vu(_t2, e.graphOptions), _a2.path = r.path.slice(0, _n2 + 1), _a2.parentNode = i, e.setNode(_t2, _a2), i.metaGraph.setNode(_t2, _a2)), i = _a2;\n      }\n\n      e.setNode(r.name, r), r.parentNode = i, i.metaGraph.setNode(r.name, r);\n    });\n  }(o, e), function (e, n) {\n    var t = e.getNodeMap();\n    var r = [],\n        o = [];\n\n    var i = function i(e, n) {\n      var t = 0;\n\n      for (; e;) {\n        n[t++] = e.name, e = e.parentNode;\n      }\n\n      return t - 1;\n    };\n\n    n.edges.forEach(function (a) {\n      r = [], o = [];\n      var u = i(n.nodes[a.v], r),\n          c = i(n.nodes[a.w], o);\n\n      for (; r[u] === o[c];) {\n        if (u--, c--, u < 0 || c < 0) throw Error(\"No difference found between ancestor paths.\");\n      }\n\n      var s = t[r[u + 1]],\n          d = r[u],\n          f = o[c];\n      var h = s.metaGraph.edge(d, f);\n      h || (h = $u(d, f), s.metaGraph.setEdge(d, f, h)), h.addBaseEdge(a, e);\n    });\n  }(o, e), o;\n}\n\nfunction Yu(e, n, t, r) {\n  (t ? e.inEdges(n.name) : e.outEdges(n.name)).forEach(function (n) {\n    var t = e.edge(n);\n    r.push(t);\n  });\n}\n\nvar Ju = /*#__PURE__*/function () {\n  function Ju(e) {\n    _classCallCheck(this, Ju);\n\n    this.hierarchy = e, this.index = {}, this.hasSubHierarchy = {}, this.root = new Qu(this.hierarchy.root, this.hierarchy.graphOptions), this.index[e.root.name] = this.root, this.buildSubHierarchy(e.root.name), this.root.expanded = !0;\n  }\n\n  _createClass(Ju, [{\n    key: \"getRenderInfoNodes\",\n    value: function getRenderInfoNodes() {\n      return Object.values(this.index);\n    }\n  }, {\n    key: \"getSubHierarchy\",\n    value: function getSubHierarchy() {\n      return this.hasSubHierarchy;\n    }\n  }, {\n    key: \"buildSubHierarchy\",\n    value: function buildSubHierarchy(e) {\n      var _this3 = this;\n\n      if (e in this.hasSubHierarchy) return;\n      this.hasSubHierarchy[e] = !0;\n      var n = this.index[e];\n      if (n.node.type !== i.META) return;\n      var t = n,\n          r = t.node.metaGraph,\n          o = t.coreGraph;\n      r.nodes().forEach(function (e) {\n        var n = _this3.getOrCreateRenderNodeByName(e);\n\n        o.setNode(e, n);\n      }), r.edges().forEach(function (e) {\n        var n = r.edge(e),\n            t = new Ku(n);\n        o.setEdge(e.v, e.w, t);\n      });\n      var u = t.node.parentNode;\n      if (!u) return;\n\n      var c = this.getRenderNodeByName(u.name),\n          s = function s(e) {\n        for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          n[_key - 1] = arguments[_key];\n        }\n\n        return n.concat([e ? \"IN\" : \"OUT\"]).join(\"~~\");\n      },\n          d = this.hierarchy.getBridgeGraph(e);\n\n      d.edges().forEach(function (n) {\n        var t = d.edge(n),\n            f = !!r.node(n.w),\n            _ref3 = f ? [n.w, n.v] : [n.v, n.w],\n            _ref4 = _slicedToArray(_ref3, 2),\n            h = _ref4[0],\n            l = _ref4[1],\n            v = function v(n) {\n          var t = f ? {\n            v: n,\n            w: e\n          } : {\n            v: e,\n            w: n\n          };\n          return c.coreGraph.edge(t);\n        };\n\n        var p = v(l);\n        p || (p = v(s(f, l, u.name)));\n        var g = s(f, e),\n            y = s(f, l, e);\n        var b = o.node(y);\n\n        if (!b) {\n          var _e2 = o.node(g);\n\n          if (!_e2) {\n            var _n4 = {\n              name: g,\n              type: i.BRIDGE,\n              isGroupNode: !1,\n              cardinality: 0,\n              parentNode: null,\n              include: a.UNSPECIFIED,\n              inbound: f,\n              attr: {}\n            };\n            _e2 = new Xu(_n4), _this3.index[g] = _e2, o.setNode(g, _e2);\n          }\n\n          var _n3 = {\n            name: y,\n            type: i.BRIDGE,\n            isGroupNode: !1,\n            cardinality: 1,\n            parentNode: null,\n            include: a.UNSPECIFIED,\n            inbound: f,\n            attr: {}\n          };\n          b = new Xu(_n3), _this3.index[y] = b, o.setNode(y, b), o.setParent(y, g), _e2.node.cardinality++;\n        }\n\n        var m = new Ku(t);\n        m.adjoiningMetaEdge = p, f ? o.setEdge(y, h, m) : o.setEdge(h, y, m);\n      });\n    }\n  }, {\n    key: \"getOrCreateRenderNodeByName\",\n    value: function getOrCreateRenderNodeByName(e) {\n      if (!e) return null;\n      if (e in this.index) return this.index[e];\n      var n = this.getNodeByName(e);\n      return n ? (this.index[e] = n.isGroupNode ? new Qu(n, this.hierarchy.graphOptions) : new Xu(n), this.index[e]) : null;\n    }\n  }, {\n    key: \"getRenderNodeByName\",\n    value: function getRenderNodeByName(e) {\n      return this.index[e];\n    }\n  }, {\n    key: \"getNodeByName\",\n    value: function getNodeByName(e) {\n      return this.hierarchy.node(e);\n    }\n  }]);\n\n  return Ju;\n}();\n\nvar Xu = function Xu(e) {\n  _classCallCheck(this, Xu);\n\n  this.node = e, this.expanded = !1, this.x = 0, this.y = 0, this.coreBox = {\n    width: 0,\n    height: 0\n  }, this.outboxWidth = 0, this.labelOffset = 0, this.radius = 0, this.labelHeight = 0, this.paddingTop = 0, this.paddingLeft = 0, this.paddingRight = 0, this.paddingBottom = 0, this.width = e.width || 0, this.height = e.height || 0, this.displayName = e.name, this.attr = e.attr;\n};\n\nvar Ku = function Ku(e) {\n  _classCallCheck(this, Ku);\n\n  this.metaEdge = e, this.adjoiningMetaEdge = null, this.weight = 1, this.points = [];\n};\n\nvar Qu = /*#__PURE__*/function (_Xu) {\n  _inherits(Qu, _Xu);\n\n  function Qu(e, n) {\n    var _this4;\n\n    _classCallCheck(this, Qu);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Qu).call(this, e));\n    var t = e.metaGraph.graph();\n    n.compound = !0, _this4.coreGraph = Hu(t.name, u.CORE, n);\n    return _this4;\n  }\n\n  return Qu;\n}(Xu);\n\nfunction Zu(e, t) {\n  e.node.isGroupNode && function (e, t) {\n    var r = n(t);\n    e.coreGraph.nodes().map(function (n) {\n      return e.coreGraph.node(n);\n    }).forEach(function (e) {\n      var n, o, a, u, c, s;\n      var d = e.height,\n          f = e.width;\n\n      switch (e.node.type) {\n        case i.NODE:\n          Object.assign(e, r.nodeSize.node), e.height = d || r.nodeSize.node.height, e.width = f || r.nodeSize.node.width;\n          break;\n\n        case i.BRIDGE:\n          Object.assign(e, r.nodeSize.bridge);\n          break;\n\n        case i.META:\n          if (e.expanded) {\n            Zu(e, t);\n          } else Object.assign(e, r.nodeSize.meta), e.height = r.nodeSize.meta.height, e.width = r.nodeSize.meta.width;\n\n          break;\n\n        default:\n          throw Error(\"Unrecognized node type: \" + e.node.type);\n      }\n\n      if (!e.expanded) {\n        var _r3 = e.attr;\n        !function (e) {\n          var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n\n          if (e.coreBox.width = e.width, e.coreBox.height = e.height, !n) {\n            var _n5 = \"\".concat(e.displayName).length,\n                _t3 = 3;\n            e.width = Math.max(e.coreBox.width, _n5 * _t3);\n          }\n        }(e, t && (0 === e.node.type && !!(null === (o = null === (n = null == t ? void 0 : t.nodeSize) || void 0 === n ? void 0 : n.meta) || void 0 === o ? void 0 : o.width) || 1 === e.node.type && (!!(null === (u = null === (a = null == t ? void 0 : t.nodeSize) || void 0 === a ? void 0 : a.node) || void 0 === u ? void 0 : u.width) || !!_r3.width) || 2 === e.node.type && !!(null === (s = null === (c = null == t ? void 0 : t.nodeSize) || void 0 === c ? void 0 : c.bridge) || void 0 === s ? void 0 : s.width)));\n      }\n    });\n  }(e, t), e.node.type === i.META && function (e, t) {\n    var r = n(t),\n        o = r.subScene.meta;\n    Object.assign(e, o);\n    var _r$graph$meta = r.graph.meta,\n        a = _r$graph$meta.nodeSep,\n        u = _r$graph$meta.rankSep,\n        c = _r$graph$meta.edgeSep,\n        s = _r$graph$meta.align,\n        d = {\n      nodesep: a,\n      ranksep: u,\n      edgesep: c,\n      align: s\n    };\n    Object.assign(e.coreBox, function (e, n) {\n      var t = n.ranksep,\n          r = n.nodesep,\n          o = n.edgesep,\n          a = n.align;\n      Object.assign(e.graph(), {\n        ranksep: t,\n        nodesep: r,\n        edgesep: o,\n        align: a\n      });\n      var u = [];\n      if (e.nodes().forEach(function (n) {\n        e.node(n).node.type !== i.BRIDGE && u.push(n);\n      }), !u.length) return {\n        width: 0,\n        height: 0\n      };\n      Tu(e);\n      var c = 1 / 0,\n          s = 1 / 0,\n          d = -1 / 0,\n          f = -1 / 0;\n      return u.forEach(function (n) {\n        var t = e.node(n),\n            r = .5 * t.width,\n            o = t.x - r,\n            i = t.x + r;\n        c = o < c ? o : c, d = i > d ? i : d;\n        var a = .5 * t.height,\n            u = t.y - a,\n            h = t.y + a;\n        s = u < s ? u : s, f = h > f ? h : f;\n      }), e.edges().forEach(function (n) {\n        var t = e.edge(n),\n            r = e.node(t.metaEdge.v),\n            o = e.node(t.metaEdge.w);\n\n        if (3 === t.points.length && function (e) {\n          var n = ec(e[0], e[1]);\n\n          for (var _t4 = 1; _t4 < e.length - 1; _t4++) {\n            var _r4 = ec(e[_t4], e[_t4 + 1]);\n\n            if (Math.abs(_r4 - n) > 1) return !1;\n            n = _r4;\n          }\n\n          return !0;\n        }(t.points)) {\n          if (null != r) {\n            var _e3 = r.expanded ? r.x : nc(r);\n\n            t.points[0].x = _e3;\n          }\n\n          if (null != o) {\n            var _e4 = o.expanded ? o.x : nc(o);\n\n            t.points[2].x = _e4;\n          }\n\n          t.points = [t.points[0], t.points[1]];\n        }\n\n        var i = t.points[t.points.length - 2];\n        null != o && (t.points[t.points.length - 1] = tc(i, o));\n        var a = t.points[1];\n        null != r && (t.points[0] = tc(a, r)), t.points.forEach(function (e) {\n          c = e.x < c ? e.x : c, d = e.x > d ? e.x : d, s = e.y < s ? e.y : s, f = e.y > f ? e.y : f;\n        });\n      }), e.nodes().forEach(function (n) {\n        var t = e.node(n);\n        t.x -= c, t.y -= s;\n      }), e.edges().forEach(function (n) {\n        e.edge(n).points.forEach(function (e) {\n          e.x -= c, e.y -= s;\n        });\n      }), {\n        width: d - c,\n        height: f - s\n      };\n    }(e.coreGraph, d));\n    var f = 0;\n    e.coreGraph.nodeCount() > 0 && f++;\n    var h = f <= 1 ? 0 : f;\n    e.coreBox.width += h + h, e.coreBox.height = o.labelHeight + e.coreBox.height, e.width = e.coreBox.width + o.paddingLeft + o.paddingRight, e.height = e.paddingTop + e.coreBox.height + e.paddingBottom;\n  }(e, t);\n}\n\nfunction ec(e, n) {\n  var t = n.x - e.x,\n      r = n.y - e.y;\n  return 180 * Math.atan(r / t) / Math.PI;\n}\n\nfunction nc(e) {\n  if (e.expanded) return e.x;\n  return e.x - e.width / 2 + 0 + e.coreBox.width / 2;\n}\n\nfunction tc(e, n) {\n  var t = n.expanded ? n.x : nc(n),\n      r = n.y,\n      o = e.x - t,\n      i = e.y - r;\n  var a,\n      u,\n      c = n.expanded ? n.width : n.coreBox.width,\n      s = n.expanded ? n.height : n.coreBox.height;\n  return Math.abs(i) * c / 2 > Math.abs(o) * s / 2 ? (i < 0 && (s = -s), a = 0 === i ? 0 : s / 2 * o / i, u = s / 2) : (o < 0 && (c = -c), a = c / 2, u = 0 === o ? 0 : c / 2 * i / o), {\n    x: t + a,\n    y: r + u\n  };\n}\n\nfunction rc(n, t, r) {\n  var o, i, a, u;\n  var c = n.nodes.filter(function (e, n, t) {\n    return t.findIndex(function (n) {\n      return n.id === e.id;\n    }) !== n;\n  }).map(function (e) {\n    return e.id;\n  });\n  if (c.length) throw new Error(\"Duplicated ids found: \".concat(c.join(\", \")));\n\n  var s = function (e) {\n    var n = {\n      nodes: []\n    },\n        t = e.compound,\n        r = Object.keys(t || {}),\n        o = new Map(),\n        i = function i(e) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      if (o.has(e)) return o.get(e);\n\n      for (var _o2 = 0; _o2 < r.length; _o2++) {\n        var _a3 = r[_o2];\n        if (t && -1 !== t[_a3].indexOf(e)) return n.unshift(_a3), i(_a3, n);\n      }\n\n      return 0 === n.length && o.set(e, n), n;\n    },\n        a = function a(n) {\n      return e.edges.filter(function (e) {\n        return e.w === n;\n      }).map(function (e) {\n        return {\n          name: e.v\n        };\n      });\n    };\n\n    return e.nodes.forEach(function (e) {\n      var t = e.id,\n          r = [].concat(_toConsumableArray(i(t)), [t]);\n      var o = a(t);\n      n.nodes.push({\n        name: t,\n        path: r,\n        inputs: o,\n        width: e.width,\n        height: e.height,\n        attr: Object.assign({}, e)\n      });\n    }), n;\n  }(n),\n      d = function (e, n) {\n    var t = function t(e, n) {\n      var _iterator = _createForOfIteratorHelper(n.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _t5 = _step.value;\n          if (_t5.includes(e)) return !0;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return !1;\n    },\n        r = function r(e) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      if (0 === Object.keys(e).length) return _toConsumableArray(new Set(n));\n      var o = new Map(Object.keys(e).map(function (n) {\n        return [n, e[n]];\n      })),\n          i = {};\n\n      var _iterator2 = _createForOfIteratorHelper(o),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              _e5 = _step2$value[0],\n              _r5 = _step2$value[1];\n\n          t(_e5, o) ? i[_e5] = _r5 : n = n.concat(_e5, _r5);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return r(i, n);\n    };\n\n    return r(e).filter(function (e) {\n      return n.includes(e);\n    });\n  }(n.compound || {}, (null == t ? void 0 : t.expanded) || []),\n      f = function (e, n) {\n    return function (e) {\n      return new Ju(e);\n    }(qu(zu(e), n));\n  }(s, {\n    rankDirection: (null === (i = null === (o = null == r ? void 0 : r.graph) || void 0 === o ? void 0 : o.meta) || void 0 === i ? void 0 : i.rankDir) || (null == t ? void 0 : t.rankDirection) || e.graph.meta.rankDir,\n    align: (null === (u = null === (a = null == r ? void 0 : r.graph) || void 0 === a ? void 0 : a.meta) || void 0 === u ? void 0 : u.align) || e.graph.meta.align\n  });\n\n  return function (e, n) {\n    n.forEach(function (n) {\n      var t = e.getRenderInfoNodes().find(function (e) {\n        return e.displayName === n;\n      });\n      var r = t && t.node && t.node.name || \"\";\n      var o = e.getRenderNodeByName(r);\n      if (!o) throw new Error(\"No nodes found: \".concat(r));\n      o.expanded = !0, e.buildSubHierarchy(r);\n    });\n  }(f, d), Zu(f.root, r), ac(f.root);\n}\n\nfunction oc(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n  var t = JSON.parse(JSON.stringify(e)),\n      o = {\n    nodes: [t],\n    edges: _toConsumableArray(t.edges)\n  };\n  return t.nodes.forEach(function e(n) {\n    (0 === n.type || 1 === n.type) && o.nodes.push(n), 0 === n.type && (o.edges = o.edges.concat(n.edges)), Array.isArray(n.nodes) && n.nodes.forEach(e);\n  }), n && o.nodes.forEach(function (e) {\n    var n = o.nodes.find(function (n) {\n      return n.id === e.parentNodeName;\n    });\n\n    if (n) {\n      var _t6 = n.x - n.width / 2 + n.paddingLeft,\n          _o3 = n.y - n.height / 2 + n.labelHeight + n.paddingTop;\n\n      n.id !== r && (e.x += _t6, e.y += _o3), 0 === e.type && e.edges.forEach(function (n) {\n        n.points.forEach(function (n) {\n          n.x += e.x - e.width / 2 + e.paddingLeft, n.y += e.y - e.height / 2 + e.labelHeight + e.paddingTop;\n        });\n      });\n    }\n  }), o;\n}\n\nfunction ic(e, n, t, o) {\n  var i, a;\n  var u = [];\n  var c = (null === (i = t.find(function (n) {\n    return n.id === e;\n  })) || void 0 === i ? void 0 : i.path) || [],\n      s = (null === (a = t.find(function (e) {\n    return e.id === n;\n  })) || void 0 === a ? void 0 : a.path) || [],\n      d = [r].concat(_toConsumableArray(c)).slice(0, c.length).reverse(),\n      f = [r].concat(_toConsumableArray(s)).slice(0, s.length);\n  return d.forEach(function (r) {\n    var i = t.find(function (e) {\n      return e.id === r;\n    });\n    u = u.concat(i.edges.filter(function (t) {\n      return t.baseEdgeList.some(function (t) {\n        return t.v === ((null == o ? void 0 : o.v) || e) && t.w === ((null == o ? void 0 : o.w) || n);\n      });\n    }));\n  }), f.filter(function (e) {\n    return !d.includes(e);\n  }).forEach(function (r) {\n    var i = t.find(function (e) {\n      return e.id === r;\n    });\n    u = u.concat(i.edges.filter(function (t) {\n      return t.baseEdgeList.some(function (t) {\n        return t.v === ((null == o ? void 0 : o.v) || e) && t.w === ((null == o ? void 0 : o.w) || n);\n      });\n    }));\n  }), u;\n}\n\nfunction ac(e) {\n  var n = e.coreGraph.nodes().map(function (n) {\n    return e.coreGraph.node(n);\n  });\n  return Object.assign(Object.assign({}, uc(e)), {\n    expanded: e.expanded,\n    nodes: e.expanded ? (t = n, t.map(function (e) {\n      return e.node.type === i.META ? ac(e) : uc(e);\n    })) : [],\n    edges: e.expanded ? cc(e) : []\n  });\n  var t;\n}\n\nfunction uc(e) {\n  return {\n    id: e.node.name,\n    name: e.node.name,\n    type: e.node.type,\n    cardinality: e.node.cardinality,\n    attr: e.attr,\n    parentNodeName: e.node.parentNode ? e.node.parentNode.name : null,\n    coreBox: Object.assign({}, e.coreBox),\n    x: e.x,\n    y: e.y,\n    width: e.width,\n    height: e.height,\n    radius: e.radius,\n    labelHeight: e.labelHeight,\n    labelOffset: e.labelOffset,\n    outboxWidth: e.outboxWidth,\n    paddingLeft: e.paddingLeft,\n    paddingTop: e.paddingTop,\n    paddingRight: e.paddingRight,\n    paddingBottom: e.paddingBottom,\n    path: e.node.path\n  };\n}\n\nfunction cc(e) {\n  return e.coreGraph.edges().map(function (n) {\n    return {\n      renderInfoEdge: e.coreGraph.edge(n),\n      edge: n\n    };\n  }).filter(function (_ref5) {\n    var e = _ref5.renderInfoEdge;\n    return e.metaEdge;\n  }).map(function (_ref6) {\n    var n = _ref6.edge,\n        t = _ref6.renderInfoEdge;\n\n    var r = function (e, n) {\n      var t = n.points.map(function (e) {\n        return Object.assign({}, e);\n      });\n\n      if (n.adjoiningMetaEdge) {\n        var _r6 = n.adjoiningMetaEdge.points,\n            _o4 = n.metaEdge.inbound,\n            _i2 = _o4 ? _r6[_r6.length - 1] : _r6[0],\n            _a4 = t[_o4 ? 0 : t.length - 1],\n            _u2 = e.x - e.width / 2,\n            _c = e.y - e.height / 2,\n            _s = _i2.x - _u2,\n            _d = _i2.y - _c,\n            _f = -e.paddingLeft,\n            _h = -(e.paddingTop + e.labelHeight);\n\n        _a4.x = _s + _f, _a4.y = _d + _h;\n      }\n\n      return t;\n    }(e, t);\n\n    return {\n      adjoiningEdge: t.adjoiningMetaEdge ? {\n        w: t.adjoiningMetaEdge.metaEdge.w,\n        v: t.adjoiningMetaEdge.metaEdge.v\n      } : null,\n      inbound: t.metaEdge.inbound,\n      w: n.w,\n      v: n.v,\n      points: r,\n      weight: t.weight,\n      baseEdgeList: t.metaEdge.baseEdgeList,\n      parentNodeName: e.node.name\n    };\n  });\n}\n\nexport { o as BRIDGE_GRAPH_NAME, u as GraphType, c as HierarchyNodeType, a as InclusionType, e as LAYOUT_CONFIG, i as NodeType, r as ROOT_NAME, rc as buildGraph, oc as flatGraph, ic as getEdges, n as mergeConfig };","map":null,"metadata":{},"sourceType":"module"}