{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CircularLayout = void 0;\n\nvar base_1 = require(\"./base\");\n\nvar util_1 = require(\"../util\");\n\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n  nodes.forEach(function (_, i) {\n    nodes[i].children = [];\n    nodes[i].parent = [];\n  });\n\n  if (directed) {\n    edges.forEach(function (e) {\n      var source = (0, util_1.getEdgeTerminal)(e, 'source');\n      var target = (0, util_1.getEdgeTerminal)(e, 'target');\n      var sourceIdx = 0;\n\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n\n      var targetIdx = 0;\n\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n\n      var child = nodes[sourceIdx].children;\n      var parent = nodes[targetIdx].parent;\n      child.push(nodes[targetIdx].id);\n      parent.push(nodes[sourceIdx].id);\n    });\n  } else {\n    edges.forEach(function (e) {\n      var source = (0, util_1.getEdgeTerminal)(e, 'source');\n      var target = (0, util_1.getEdgeTerminal)(e, 'target');\n      var sourceIdx = 0;\n\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n\n      var targetIdx = 0;\n\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n\n      var sourceChildren = nodes[sourceIdx].children;\n      var targetChildren = nodes[targetIdx].children;\n      sourceChildren.push(nodes[targetIdx].id);\n      targetChildren.push(nodes[sourceIdx].id);\n    });\n  }\n}\n\nfunction connect(a, b, edges) {\n  var m = edges.length;\n\n  for (var i = 0; i < m; i++) {\n    var source = (0, util_1.getEdgeTerminal)(edges[i], 'source');\n    var target = (0, util_1.getEdgeTerminal)(edges[i], 'target');\n\n    if (a.id === source && b.id === target || b.id === source && a.id === target) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction compareDegree(a, b) {\n  var aDegree = a.degree;\n  var bDegree = b.degree;\n\n  if (aDegree < bDegree) {\n    return -1;\n  }\n\n  if (aDegree > bDegree) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * 圆形布局\n */\n\n\nvar CircularLayout =\n/** @class */\nfunction (_super) {\n  __extends(CircularLayout, _super);\n\n  function CircularLayout(options) {\n    var _this = _super.call(this) || this;\n    /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n\n\n    _this.radius = null;\n    /** 节点大小，配合 nodeSpacing，一起用于计算 radius。若不配置，节点大小默认为 30 */\n\n    _this.nodeSize = undefined;\n    /** 起始半径 */\n\n    _this.startRadius = null;\n    /** 终止半径 */\n\n    _this.endRadius = null;\n    /** 起始角度 */\n\n    _this.startAngle = 0;\n    /** 终止角度 */\n\n    _this.endAngle = 2 * Math.PI;\n    /** 是否顺时针 */\n\n    _this.clockwise = true;\n    /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n\n    _this.divisions = 1;\n    /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n\n    _this.ordering = null;\n    /** how many 2*pi from first to last nodes */\n\n    _this.angleRatio = 1;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.nodeMap = {};\n    _this.degrees = [];\n    _this.width = 300;\n    _this.height = 300;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  CircularLayout.prototype.getDefaultCfg = function () {\n    return {\n      radius: null,\n      startRadius: null,\n      endRadius: null,\n      startAngle: 0,\n      endAngle: 2 * Math.PI,\n      clockwise: true,\n      divisions: 1,\n      ordering: null,\n      angleRatio: 1\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  CircularLayout.prototype.execute = function () {\n    var _a;\n\n    var self = this;\n    var nodes = self.nodes;\n    var edges = self.edges;\n    var n = nodes.length;\n\n    if (n === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    var center = self.center;\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    var radius = self.radius,\n        startRadius = self.startRadius,\n        endRadius = self.endRadius;\n    var divisions = self.divisions,\n        startAngle = self.startAngle,\n        endAngle = self.endAngle,\n        angleRatio = self.angleRatio,\n        ordering = self.ordering,\n        clockwise = self.clockwise,\n        paramNodeSpacing = self.nodeSpacing,\n        paramNodeSize = self.nodeSize;\n    var angleStep = (endAngle - startAngle) / n; // layout\n\n    var nodeMap = {};\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    var degrees = (0, util_1.getDegree)(nodes.length, nodeMap, edges);\n    self.degrees = degrees;\n\n    if (paramNodeSpacing) {\n      var nodeSpacing_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSpacing);\n      var nodeSize_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSize);\n      var maxNodeSize_1 = -Infinity;\n      nodes.forEach(function (node) {\n        var nSize = nodeSize_1(node);\n        if (maxNodeSize_1 < nSize) maxNodeSize_1 = nSize;\n      });\n      var length_1 = 0;\n      nodes.forEach(function (node, i) {\n        if (i === 0) length_1 += maxNodeSize_1 || 10;else length_1 += (nodeSpacing_1(node) || 0) + (maxNodeSize_1 || 10);\n      });\n      radius = length_1 / (2 * Math.PI);\n    } else if (!radius && !startRadius && !endRadius) {\n      radius = self.height > self.width ? self.width / 2 : self.height / 2;\n    } else if (!startRadius && endRadius) {\n      startRadius = endRadius;\n    } else if (startRadius && !endRadius) {\n      endRadius = startRadius;\n    }\n\n    var astep = angleStep * angleRatio;\n    var layoutNodes = [];\n\n    if (ordering === \"topology\") {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering();\n    } else if (ordering === \"topology-directed\") {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering(true);\n    } else if (ordering === \"degree\") {\n      // layout according to the descent order of degrees\n      layoutNodes = self.degreeOrdering();\n    } else {\n      // layout according to the original order in the data.nodes\n      layoutNodes = nodes;\n    }\n\n    var divN = Math.ceil(n / divisions); // node number in each division\n\n    for (var i = 0; i < n; ++i) {\n      var r = radius;\n\n      if (!r && startRadius !== null && endRadius !== null) {\n        r = startRadius + i * (endRadius - startRadius) / (n - 1);\n      }\n\n      if (!r) {\n        r = 10 + i * 100 / (n - 1);\n      }\n\n      var angle = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);\n\n      if (!clockwise) {\n        angle = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);\n      }\n\n      layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n      layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n      layoutNodes[i].weight = degrees[i];\n    }\n\n    (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n    return {\n      nodes: layoutNodes,\n      edges: this.edges\n    };\n  };\n  /**\n   * 根据节点的拓扑结构排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n\n\n  CircularLayout.prototype.topologyOrdering = function (directed) {\n    if (directed === void 0) {\n      directed = false;\n    }\n\n    var self = this;\n    var degrees = self.degrees;\n    var edges = self.edges;\n    var nodes = self.nodes;\n    var cnodes = (0, util_1.clone)(nodes);\n    var nodeMap = self.nodeMap;\n    var orderedCNodes = [cnodes[0]];\n    var resNodes = [nodes[0]];\n    var pickFlags = [];\n    var n = nodes.length;\n    pickFlags[0] = true;\n    initHierarchy(cnodes, edges, nodeMap, directed);\n    var k = 0;\n    cnodes.forEach(function (cnode, i) {\n      if (i !== 0) {\n        if ((i === n - 1 || degrees[i] !== degrees[i + 1] || connect(orderedCNodes[k], cnode, edges)) && !pickFlags[i]) {\n          orderedCNodes.push(cnode);\n          resNodes.push(nodes[nodeMap[cnode.id]]);\n          pickFlags[i] = true;\n          k++;\n        } else {\n          var children = orderedCNodes[k].children;\n          var foundChild = false;\n\n          for (var j = 0; j < children.length; j++) {\n            var childIdx = nodeMap[children[j]];\n\n            if (degrees[childIdx] === degrees[i] && !pickFlags[childIdx]) {\n              orderedCNodes.push(cnodes[childIdx]);\n              resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n              pickFlags[childIdx] = true;\n              foundChild = true;\n              break;\n            }\n          }\n\n          var ii = 0;\n\n          while (!foundChild) {\n            if (!pickFlags[ii]) {\n              orderedCNodes.push(cnodes[ii]);\n              resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n              pickFlags[ii] = true;\n              foundChild = true;\n            }\n\n            ii++;\n\n            if (ii === n) {\n              break;\n            }\n          }\n        }\n      }\n    });\n    return resNodes;\n  };\n  /**\n   * 根据节点度数大小排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n\n\n  CircularLayout.prototype.degreeOrdering = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var orderedNodes = [];\n    var degrees = self.degrees;\n    nodes.forEach(function (node, i) {\n      node.degree = degrees[i];\n      orderedNodes.push(node);\n    });\n    orderedNodes.sort(compareDegree);\n    return orderedNodes;\n  };\n\n  CircularLayout.prototype.getType = function () {\n    return \"circular\";\n  };\n\n  return CircularLayout;\n}(base_1.Base);\n\nexports.CircularLayout = CircularLayout;","map":null,"metadata":{},"sourceType":"script"}