{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Grid =\n/** @class */\nfunction () {\n  function Grid() {\n    this.cells = [];\n    this.columnNum = 0;\n    this.rowNum = 0;\n    this.additionColumn = [];\n    this.additionRow = [];\n  }\n\n  Grid.prototype.init = function (width, height, gridSize) {\n    this.cells = [];\n    this.CELL_W = gridSize.CELL_W || Grid.DEFAULT_CELL_W;\n    this.CELL_H = gridSize.CELL_H || Grid.DEFAULT_CELL_H;\n    this.columnNum = Math.ceil(width / this.CELL_W);\n    this.rowNum = Math.ceil(height / this.CELL_H);\n    Grid.MIN_DIST = Math.pow(width, 2) + Math.pow(height, 2);\n\n    for (var i = 0; i < this.columnNum; i++) {\n      var tmp = [];\n\n      for (var j = 0; j < this.rowNum; j++) {\n        var cell = {\n          dx: i,\n          dy: j,\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: false\n        };\n        tmp.push(cell);\n      }\n\n      this.cells.push(tmp);\n    }\n  };\n\n  Grid.prototype.findGridByNodeId = function (nodeId) {\n    var _a, _b;\n\n    for (var i = 0; i < this.columnNum; i++) {\n      for (var j = 0; j < this.rowNum; j++) {\n        if (this.cells[i][j].node) {\n          if (((_b = (_a = this.cells[i][j]) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.id) === nodeId) {\n            return {\n              column: i,\n              row: j\n            };\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  Grid.prototype.sqdist = function (a, b) {\n    return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n  };\n\n  Grid.prototype.occupyNearest = function (p) {\n    var minDist = Grid.MIN_DIST;\n    var d;\n    var candidate = null;\n\n    for (var i = 0; i < this.columnNum; i++) {\n      for (var j = 0; j < this.rowNum; j++) {\n        if (!this.cells[i][j].occupied && (d = this.sqdist(p, this.cells[i][j])) < minDist) {\n          minDist = d;\n          candidate = this.cells[i][j];\n        }\n      }\n    }\n\n    if (candidate) {\n      candidate.occupied = true;\n    }\n\n    return candidate;\n  };\n\n  Grid.prototype.insertColumn = function (columnIndex, length) {\n    if (length <= 0) return; // 插入空列\n\n    for (var i = 0; i < length; i++) {\n      this.cells[i + this.columnNum] = [];\n\n      for (var j = 0; j < this.rowNum; j++) {\n        this.cells[i + this.columnNum][j] = {\n          dx: i,\n          dy: j,\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: false,\n          node: null\n        };\n      }\n    } // 交换数据\n\n\n    for (var i = this.columnNum - 1; i > columnIndex; i--) {\n      for (var j = 0; j < this.rowNum; j++) {\n        this.cells[i + length][j] = __assign(__assign({}, this.cells[i][j]), {\n          x: (i + length) * this.CELL_W,\n          y: j * this.CELL_H\n        });\n        this.cells[i][j] = {\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: true,\n          node: null\n        };\n      }\n    } // 已有行列的处理\n\n\n    for (var j = 0; j < this.additionColumn.length; j++) {\n      if (this.additionColumn[j] >= columnIndex) {\n        this.additionColumn[j] += length;\n      }\n    } // 记录新增的行列\n\n\n    for (var i = 0; i < length; i++) {\n      this.additionColumn.push(columnIndex + i + 1);\n    }\n\n    this.columnNum += length;\n  };\n\n  Grid.prototype.insertRow = function (rowIndex, length) {\n    if (length <= 0) return; // 插入空行\n\n    for (var j = 0; j < length; j++) {\n      for (var i = 0; i < this.columnNum; i++) {\n        this.cells[i][j + this.rowNum] = {\n          dx: i,\n          dy: j,\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: false,\n          node: null\n        };\n      }\n    } // 交换数据\n\n\n    for (var i = 0; i < this.columnNum; i++) {\n      for (var j = this.rowNum - 1; j > rowIndex; j--) {\n        this.cells[i][j + length] = __assign(__assign({}, this.cells[i][j]), {\n          dx: i,\n          dy: j + length,\n          x: i * this.CELL_W,\n          y: (j + length) * this.CELL_H\n        });\n        this.cells[i][j] = {\n          dx: i,\n          dy: j,\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: false,\n          node: null\n        };\n      }\n    } // 已有行列的处理\n\n\n    for (var j = 0; j < this.additionRow.length; j++) {\n      if (this.additionRow[j] >= rowIndex) {\n        this.additionRow[j] += length;\n      }\n    } // 记录新增的行列\n\n\n    for (var i = 0; i < length; i++) {\n      this.additionRow.push(rowIndex + i + 1);\n    }\n\n    this.rowNum += length;\n  };\n\n  Grid.prototype.getNodes = function () {\n    var nodes = [];\n\n    for (var i = 0; i < this.columnNum; i++) {\n      for (var j = 0; j < this.rowNum; j++) {\n        if (this.cells[i][j].node) {\n          nodes.push(this.cells[i][j]);\n        }\n      }\n    }\n\n    return nodes;\n  };\n\n  Grid.MIN_DIST = 50;\n  Grid.DEFAULT_CELL_W = 80;\n  Grid.DEFAULT_CELL_H = 80;\n  return Grid;\n}();\n\nexports.default = Grid;","map":null,"metadata":{},"sourceType":"script"}