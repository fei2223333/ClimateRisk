{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { Version } from '@antv/l7-maps';\nimport { getMask } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nvar planeFrag = \"\\nuniform sampler2D u_texture;\\nuniform float u_mapFlag;\\nuniform float u_opacity;\\n\\nvarying vec3 v_Color;\\nvarying vec2 v_uv;\\nvarying float v_clip;\\n\\n#pragma include \\\"picking\\\"\\nvoid main() {\\n  // gl_FragColor = vec4(v_Color, u_opacity);\\n  if(u_mapFlag > 0.0) {\\n    gl_FragColor = texture2D(u_texture, vec2(v_uv.x, 1.0 - v_uv.y));\\n    gl_FragColor.a *= u_opacity;\\n  } else {\\n    // gl_FragColor = vec4(v_uv, 0.0, u_opacity);\\n    gl_FragColor = vec4(v_Color, u_opacity);\\n  }\\n  gl_FragColor.a *= v_clip;\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar planeVert = \"precision highp float;\\nuniform mat4 u_ModelMatrix;\\n\\nuniform mat4 u_Mvp;\\nuniform float u_opacity;\\nuniform float u_terrainClipHeight;\\n\\nattribute vec3 a_Position;\\nattribute vec2 a_Uv;\\nattribute vec3 a_Color;\\n\\nvarying vec3 v_Color;\\nvarying vec2 v_uv;\\nvarying float v_clip;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\nvoid main() {\\n   v_Color = a_Color;\\n   v_uv = a_Uv;\\n  \\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n\\n   v_clip = 1.0;\\n   if(a_Position.z < u_terrainClipHeight) {\\n      v_clip = 0.0;\\n   }\\n  \\n   // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\\n\\n   // float x = 1.0;\\n   // float y = 0.0;\\n   // float z = 0.0;\\n   // mat3 translateMatrix = mat3(\\n   //    1.0, 0.0, 0.0 \\n   //    0.0, 1.0, 0.0\\n   //    -project_pos.x,    -project_pos.y,  1.0\\n   // );\\n   //  mat4 translateMatrix = mat4(\\n   //    1.0, 0.0, 0.0, 0.0 ,\\n   //    0.0, 1.0, 0.0, 0.0,\\n   //    0.0, 0.0, 1.0, 0.0,\\n   //    1.0, 0.0, 0.0, 1.0\\n   // );\\n\\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n      gl_Position = u_Mvp * (vec4(project_pos.xy, a_Position.z, 1.0));\\n   } else {\\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\\n   }\\n\\n   setPickingColor(a_PickingColor);\\n}\\n\";\n\nvar PlaneModel = function (_BaseModel) {\n  _inherits(PlaneModel, _BaseModel);\n\n  var _super = _createSuper(PlaneModel);\n\n  function PlaneModel() {\n    var _this;\n\n    _classCallCheck(this, PlaneModel);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"texture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"mapTexture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"positions\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"indices\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"planeGeometryTriangulation\", function () {\n      var _this2;\n\n      var _ref = _this.layer.getLayerConfig(),\n          _ref$width = _ref.width,\n          width = _ref$width === void 0 ? 1 : _ref$width,\n          _ref$height = _ref.height,\n          height = _ref$height === void 0 ? 1 : _ref$height,\n          _ref$widthSegments = _ref.widthSegments,\n          widthSegments = _ref$widthSegments === void 0 ? 1 : _ref$widthSegments,\n          _ref$heightSegments = _ref.heightSegments,\n          heightSegments = _ref$heightSegments === void 0 ? 1 : _ref$heightSegments,\n          _ref$center = _ref.center,\n          center = _ref$center === void 0 ? [120, 30] : _ref$center,\n          terrainTexture = _ref.terrainTexture;\n\n      var _this$initPlane = (_this2 = _this).initPlane.apply(_this2, [width, height, widthSegments, heightSegments].concat(_toConsumableArray(center))),\n          indices = _this$initPlane.indices,\n          positions = _this$initPlane.positions;\n\n      _this.positions = positions;\n      _this.indices = indices;\n\n      if (terrainTexture) {\n        _this.loadTerrainTexture();\n      }\n\n      return {\n        vertices: positions,\n        indices: indices,\n        size: 5\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"planeGeometryUpdateTriangulation\", function () {\n      return {\n        vertices: _this.positions,\n        indices: _this.indices,\n        size: 5\n      };\n    });\n\n    return _this;\n  }\n\n  _createClass(PlaneModel, [{\n    key: \"initPlane\",\n    value: function initPlane() {\n      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var lng = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 120;\n      var lat = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 30;\n      var widthHalf = width / 2;\n      var heightHalf = height / 2;\n      var gridX = Math.floor(widthSegments);\n      var gridY = Math.floor(heightSegments);\n      var gridX1 = gridX + 1;\n      var gridY1 = gridY + 1;\n      var segmentWidth = width / gridX;\n      var segmentHeight = height / gridY;\n      var indices = [];\n      var positions = [];\n\n      for (var iy = 0; iy < gridY1; iy++) {\n        var y = iy * segmentHeight - heightHalf;\n\n        for (var ix = 0; ix < gridX1; ix++) {\n          var x = ix * segmentWidth - widthHalf;\n\n          if (this.mapService.version === Version['GAODE2.x']) {\n            var _ref2 = this.mapService.lngLatToCoord([x + lng, -y + lat]),\n                _ref3 = _slicedToArray(_ref2, 2),\n                a = _ref3[0],\n                b = _ref3[1];\n\n            positions.push(a, b, 0);\n          } else {\n            positions.push(x + lng, -y + lat, 0);\n          }\n\n          positions.push(ix / gridX);\n          positions.push(1 - iy / gridY);\n        }\n      }\n\n      for (var _iy = 0; _iy < gridY; _iy++) {\n        for (var _ix = 0; _ix < gridX; _ix++) {\n          var _a = _ix + gridX1 * _iy;\n\n          var _b = _ix + gridX1 * (_iy + 1);\n\n          var c = _ix + 1 + gridX1 * (_iy + 1);\n          var d = _ix + 1 + gridX1 * _iy;\n          indices.push(_a, _b, d);\n          indices.push(_b, c, d);\n        }\n      }\n\n      return {\n        indices: indices,\n        positions: positions\n      };\n    }\n  }, {\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref4 = this.layer.getLayerConfig(),\n          opacity = _ref4.opacity,\n          mapTexture = _ref4.mapTexture,\n          _ref4$terrainClipHeig = _ref4.terrainClipHeight,\n          terrainClipHeight = _ref4$terrainClipHeig === void 0 ? 0 : _ref4$terrainClipHeig,\n          terrainTexture = _ref4.terrainTexture;\n\n      if (this.mapTexture !== mapTexture) {\n        this.mapTexture = mapTexture;\n        this.texture.destroy();\n        this.updateTexture(mapTexture);\n      }\n\n      return {\n        u_opacity: opacity || 1,\n        u_mapFlag: mapTexture ? 1 : 0,\n        u_terrainClipHeight: terrainTexture ? terrainClipHeight : -1,\n        u_texture: this.texture\n      };\n    }\n  }, {\n    key: \"clearModels\",\n    value: function clearModels() {\n      this.texture.destroy();\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      var _ref5 = this.layer.getLayerConfig(),\n          _ref5$mask = _ref5.mask,\n          mask = _ref5$mask === void 0 ? false : _ref5$mask,\n          _ref5$maskInside = _ref5.maskInside,\n          maskInside = _ref5$maskInside === void 0 ? true : _ref5$maskInside,\n          mapTexture = _ref5.mapTexture;\n\n      this.mapTexture = mapTexture;\n      var createTexture2D = this.rendererService.createTexture2D;\n      this.texture = createTexture2D({\n        height: 0,\n        width: 0\n      });\n      this.updateTexture(mapTexture);\n      return [this.layer.buildLayerModel({\n        moduleName: 'geometry_plane',\n        vertexShader: planeVert,\n        fragmentShader: planeFrag,\n        triangulation: this.planeGeometryTriangulation,\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: true\n        },\n        blend: this.getBlend(),\n        stencil: getMask(mask, maskInside)\n      })];\n    }\n  }, {\n    key: \"getImageData\",\n    value: function getImageData(img) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      var width = img.width,\n          height = img.height;\n      canvas.width = width;\n      canvas.height = height;\n      ctx.drawImage(img, 0, 0, width, height);\n      var imageData = ctx.getImageData(0, 0, width, height);\n      return imageData;\n    }\n  }, {\n    key: \"loadTerrainTexture\",\n    value: function loadTerrainTexture() {\n      var _this3 = this;\n\n      var _ref6 = this.layer.getLayerConfig(),\n          _ref6$mask = _ref6.mask,\n          mask = _ref6$mask === void 0 ? false : _ref6$mask,\n          _ref6$maskInside = _ref6.maskInside,\n          maskInside = _ref6$maskInside === void 0 ? true : _ref6$maskInside,\n          _ref6$widthSegments = _ref6.widthSegments,\n          widthSegments = _ref6$widthSegments === void 0 ? 1 : _ref6$widthSegments,\n          _ref6$heightSegments = _ref6.heightSegments,\n          heightSegments = _ref6$heightSegments === void 0 ? 1 : _ref6$heightSegments,\n          terrainTexture = _ref6.terrainTexture,\n          _ref6$rgb2height = _ref6.rgb2height,\n          rgb2height = _ref6$rgb2height === void 0 ? function (r, g, b) {\n        return r + g + b;\n      } : _ref6$rgb2height;\n\n      var terrainImage = new Image();\n      terrainImage.crossOrigin = 'anonymous';\n\n      terrainImage.onload = function () {\n        var imgWidth = terrainImage.width;\n        var imgHeight = terrainImage.height;\n\n        var imageData = _this3.getImageData(terrainImage).data;\n\n        var gridX = Math.floor(widthSegments);\n        var gridY = Math.floor(heightSegments);\n        var gridX1 = gridX + 1;\n        var gridY1 = gridY + 1;\n        var widthStep = imgWidth / gridX;\n        var heihgtStep = imgHeight / gridY;\n\n        for (var iy = 0; iy < gridY1; iy++) {\n          var imgIndexY = Math.floor(iy * heihgtStep);\n          var imgLen = imgIndexY * imgWidth;\n\n          for (var ix = 0; ix < gridX1; ix++) {\n            var imgIndexX = Math.floor(ix * widthStep);\n            var imgDataIndex = (imgLen + imgIndexX) * 4;\n            var r = imageData[imgDataIndex];\n            var g = imageData[imgDataIndex + 1];\n            var b = imageData[imgDataIndex + 2];\n            var z = (iy * gridX1 + ix) * 5 + 2;\n            _this3.positions[z] = rgb2height(r, g, b);\n          }\n        }\n\n        _this3.layer.models = [_this3.layer.buildLayerModel({\n          moduleName: 'geometry_plane',\n          vertexShader: planeVert,\n          fragmentShader: planeFrag,\n          triangulation: _this3.planeGeometryUpdateTriangulation,\n          primitive: gl.TRIANGLES,\n          depth: {\n            enable: true\n          },\n          blend: _this3.getBlend(),\n          stencil: getMask(mask, maskInside)\n        })];\n\n        _this3.layerService.renderLayers();\n      };\n\n      terrainImage.src = terrainTexture;\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return this.initModels();\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture(mapTexture) {\n      var _this4 = this;\n\n      var createTexture2D = this.rendererService.createTexture2D;\n\n      if (mapTexture) {\n        var img = new Image();\n        img.crossOrigin = 'anonymous';\n\n        img.onload = function () {\n          _this4.texture = createTexture2D({\n            data: img,\n            width: img.width,\n            height: img.height,\n            wrapS: gl.CLAMP_TO_EDGE,\n            wrapT: gl.CLAMP_TO_EDGE\n          });\n\n          _this4.layerService.updateLayerRenderList();\n\n          _this4.layerService.renderLayers();\n        };\n\n        img.src = mapTexture;\n      } else {\n        this.texture = createTexture2D({\n          width: 0,\n          height: 0\n        });\n      }\n    }\n  }, {\n    key: \"getConfigSchema\",\n    value: function getConfigSchema() {\n      return {\n        properties: {\n          opacity: {\n            type: 'number',\n            minimum: 0,\n            maximum: 1\n          }\n        }\n      };\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'uv',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Uv',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4]];\n          }\n        }\n      });\n    }\n  }]);\n\n  return PlaneModel;\n}(BaseModel);\n\nexport { PlaneModel as default };","map":null,"metadata":{},"sourceType":"module"}