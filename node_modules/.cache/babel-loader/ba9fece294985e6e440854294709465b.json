{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/* eslint-disable no-underscore-dangle */\nimport { Point, Line, Path } from '../../geometry'; // takes care of math. error for case when jump is too close to end of line\n\nvar CLOSE_PROXIMITY_PADDING = 1;\nvar F13 = 1 / 3;\nvar F23 = 2 / 3;\n\nfunction setupUpdating(view) {\n  var updateList = view.graph._jumpOverUpdateList; // first time setup for this paper\n\n  if (updateList == null) {\n    updateList = view.graph._jumpOverUpdateList = [];\n    /**\n     * Handler for a batch:stop event to force\n     * update of all registered links with jump over connector\n     */\n\n    view.graph.on('cell:mouseup', function () {\n      var list = view.graph._jumpOverUpdateList;\n\n      for (var i = 0; i < list.length; i += 1) {\n        list[i].update();\n      }\n    });\n    view.graph.on('model:reseted', function () {\n      updateList = view.graph._jumpOverUpdateList = [];\n    });\n  } // add this link to a list so it can be updated when some other link is updated\n\n\n  if (updateList.indexOf(view) < 0) {\n    updateList.push(view); // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n\n    var clean = function clean() {\n      return updateList.splice(updateList.indexOf(view), 1);\n    };\n\n    view.cell.once('change:connector', clean);\n    view.cell.once('removed', clean);\n  }\n}\n\nfunction createLines(sourcePoint, targetPoint) {\n  var route = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var points = [sourcePoint].concat(_toConsumableArray(route), [targetPoint]);\n  var lines = [];\n  points.forEach(function (point, idx) {\n    var next = points[idx + 1];\n\n    if (next != null) {\n      lines.push(new Line(point, next));\n    }\n  });\n  return lines;\n}\n\nfunction findLineIntersections(line, crossCheckLines) {\n  var intersections = [];\n  crossCheckLines.forEach(function (crossCheckLine) {\n    var intersection = line.intersectsWithLine(crossCheckLine);\n\n    if (intersection) {\n      intersections.push(intersection);\n    }\n  });\n  return intersections;\n}\n\nfunction getDistence(p1, p2) {\n  return new Line(p1, p2).squaredLength();\n}\n/**\n * Split input line into multiple based on intersection points.\n */\n\n\nfunction createJumps(line, intersections, jumpSize) {\n  return intersections.reduce(function (memo, point, idx) {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (skippedPoints.includes(point)) {\n      return memo;\n    } // always grab the last line from buffer and modify it\n\n\n    var lastLine = memo.pop() || line; // calculate start and end of jump by moving by a given size of jump\n\n    var jumpStart = Point.create(point).move(lastLine.start, -jumpSize);\n    var jumpEnd = Point.create(point).move(lastLine.start, +jumpSize); // now try to look at the next intersection point\n\n    var nextPoint = intersections[idx + 1];\n\n    if (nextPoint != null) {\n      var distance = jumpEnd.distance(nextPoint);\n\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance);\n        skippedPoints.push(nextPoint);\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      var endDistance = jumpStart.distance(lastLine.end); // if the end is too close to possible jump, draw remaining line instead of a jump\n\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        memo.push(lastLine);\n        return memo;\n      }\n    }\n\n    var startDistance = jumpEnd.distance(lastLine.start);\n\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      memo.push(lastLine);\n      return memo;\n    } // finally create a jump line\n\n\n    var jumpLine = new Line(jumpStart, jumpEnd); // it's just simple line but with a `isJump` property\n\n    jumppedLines.push(jumpLine);\n    memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));\n    return memo;\n  }, []);\n}\n\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n  var path = new Path();\n  var segment; // first move to the start of a first line\n\n  segment = Path.createSegment('M', lines[0].start);\n  path.appendSegment(segment);\n  lines.forEach(function (line, index) {\n    if (jumppedLines.includes(line)) {\n      var angle;\n      var diff;\n      var control1;\n      var control2;\n\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90; // determine rotation of arc based on difference between points\n\n        diff = line.start.diff(line.end); // make sure the arc always points up (or right)\n\n        var xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;\n\n        if (xAxisRotate) {\n          angle += 180;\n        }\n\n        var center = line.getCenter();\n        var centerLine = new Line(center, line.end).rotate(angle, center);\n        var halfLine; // first half\n\n        halfLine = new Line(line.start, center);\n        control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);\n        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);\n        segment = Path.createSegment('C', control1, control2, centerLine.end);\n        path.appendSegment(segment); // second half\n\n        halfLine = new Line(center, line.end);\n        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);\n        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);\n        segment = Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'gap') {\n        segment = Path.createSegment('M', line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end);\n        var xOffset = jumpSize * 0.6;\n        var yOffset = jumpSize * 1.35; // determine rotation of arc based on difference between points\n\n        diff = line.start.diff(line.end); // make sure the arc always points up (or right)\n\n        var _xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;\n\n        if (_xAxisRotate) {\n          yOffset *= -1;\n        }\n\n        control1 = new Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);\n        control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);\n        segment = Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      }\n    } else {\n      var nextLine = lines[index + 1];\n\n      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {\n        segment = Path.createSegment('L', line.end);\n        path.appendSegment(segment);\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n      }\n    }\n  });\n  return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n  var prevDistance = curr.distance(prev) / 2;\n  var nextDistance = curr.distance(next) / 2;\n  var startMove = -Math.min(offset, prevDistance);\n  var endMove = -Math.min(offset, nextDistance);\n  var roundedStart = curr.clone().move(prev, startMove).round();\n  var roundedEnd = curr.clone().move(next, endMove).round();\n  var control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);\n  var control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);\n  var segment;\n  segment = Path.createSegment('L', roundedStart);\n  path.appendSegment(segment);\n  segment = Path.createSegment('C', control1, control2, roundedEnd);\n  path.appendSegment(segment);\n}\n\nvar jumppedLines;\nvar skippedPoints;\nexport var jumpover = function jumpover(sourcePoint, targetPoint, routePoints) {\n  var _this = this;\n\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  jumppedLines = [];\n  skippedPoints = [];\n  setupUpdating(this);\n  var jumpSize = options.size || 5;\n  var jumpType = options.type || 'arc';\n  var radius = options.radius || 0; // list of connector types not to jump over.\n\n  var ignoreConnectors = options.ignoreConnectors || ['smooth'];\n  var graph = this.graph;\n  var model = graph.model;\n  var allLinks = model.getEdges(); // there is just one link, draw it directly\n\n  if (allLinks.length === 1) {\n    return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);\n  }\n\n  var edge = this.cell;\n  var thisIndex = allLinks.indexOf(edge);\n  var defaultConnector = graph.options.connecting.connector || {}; // not all links are meant to be jumped over.\n\n  var edges = allLinks.filter(function (link, idx) {\n    var connector = link.getConnector() || defaultConnector; // avoid jumping over links with connector type listed in `ignored connectors`.\n\n    if (ignoreConnectors.includes(connector.name)) {\n      return false;\n    } // filter out links that are above this one and  have the same connector type\n    // otherwise there would double hoops for each intersection\n\n\n    if (idx > thisIndex) {\n      return connector.name !== 'jumpover';\n    }\n\n    return true;\n  }); // find views for all links\n\n  var linkViews = edges.map(function (edge) {\n    return graph.renderer.findViewByCell(edge);\n  }); // create lines for this link\n\n  var thisLines = createLines(sourcePoint, targetPoint, routePoints); // create lines for all other links\n\n  var linkLines = linkViews.map(function (linkView) {\n    if (linkView == null) {\n      return [];\n    }\n\n    if (linkView === _this) {\n      return thisLines;\n    }\n\n    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);\n  }); // transform lines for this link by splitting with jump lines at\n  // points of intersection with other links\n\n  var jumpingLines = [];\n  thisLines.forEach(function (line) {\n    // iterate all links and grab the intersections with this line\n    // these are then sorted by distance so the line can be split more easily\n    var intersections = edges.reduce(function (memo, link, i) {\n      // don't intersection with itself\n      if (link !== edge) {\n        var lineIntersections = findLineIntersections(line, linkLines[i]);\n        memo.push.apply(memo, _toConsumableArray(lineIntersections));\n      }\n\n      return memo;\n    }, []).sort(function (a, b) {\n      return getDistence(line.start, a) - getDistence(line.start, b);\n    });\n\n    if (intersections.length > 0) {\n      // split the line based on found intersection points\n      jumpingLines.push.apply(jumpingLines, _toConsumableArray(createJumps(line, intersections, jumpSize)));\n    } else {\n      // without any intersection the line goes uninterrupted\n      jumpingLines.push(line);\n    }\n  });\n  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n  jumppedLines = [];\n  skippedPoints = [];\n  return options.raw ? path : path.serialize();\n};","map":null,"metadata":{},"sourceType":"module"}