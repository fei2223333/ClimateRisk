{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport dagre from \"./dagre/index\";\nimport { isArray, isNumber, isObject, getEdgeTerminal } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 层次布局\n */\n\nexport var DagreLayout = /*#__PURE__*/function (_Base) {\n  _inherits(DagreLayout, _Base);\n\n  function DagreLayout(options) {\n    var _this;\n\n    _classCallCheck(this, DagreLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DagreLayout).call(this));\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n    _this.rankdir = \"TB\";\n    /** 节点水平间距(px) */\n\n    _this.nodesep = 50;\n    /** 每一层节点之间间距 */\n\n    _this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    _this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n\n    _this.sortByCombo = false;\n    /** 是否保留每条边上的dummy node */\n\n    _this.edgeLabelSpace = true;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.layoutNode = function (nodeId) {\n      var self = _assertThisInitialized(_assertThisInitialized(_this));\n\n      var nodes = self.nodes;\n      var node = nodes.find(function (node) {\n        return node.id === nodeId;\n      });\n\n      if (node) {\n        var layout = node.layout !== false;\n        return layout;\n      }\n\n      return true;\n    };\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(DagreLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        rankdir: \"TB\",\n        align: undefined,\n        nodeSize: undefined,\n        nodesepFunc: undefined,\n        ranksepFunc: undefined,\n        nodesep: 50,\n        ranksep: 50,\n        controlPoints: false // 是否保留布局连线的控制点\n\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var self = this;\n      var nodes = self.nodes,\n          nodeSize = self.nodeSize,\n          rankdir = self.rankdir,\n          combos = self.combos,\n          begin = self.begin;\n      if (!nodes) return;\n      var edges = self.edges || [];\n      var g = new dagre.graphlib.Graph({\n        multigraph: true,\n        compound: true\n      });\n      var nodeSizeFunc;\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if (isArray(d.size)) {\n              return d.size;\n            }\n\n            if (isObject(d.size)) {\n              return [d.size.width || 40, d.size.height || 40];\n            }\n\n            return [d.size, d.size];\n          }\n\n          return [40, 40];\n        };\n      } else if (isArray(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc() {\n          return nodeSize;\n        };\n      } else {\n        nodeSizeFunc = function nodeSizeFunc() {\n          return [nodeSize, nodeSize];\n        };\n      }\n\n      var horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n      var vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n\n      if (rankdir === \"LR\" || rankdir === \"RL\") {\n        horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n        vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n      }\n\n      g.setDefaultEdgeLabel(function () {\n        return {};\n      });\n      g.setGraph(self);\n      var comboMap = {};\n      nodes.filter(function (node) {\n        return node.layout !== false;\n      }).forEach(function (node) {\n        var size = nodeSizeFunc(node);\n        var verti = vertisep(node);\n        var hori = horisep(node);\n        var width = size[0] + 2 * hori;\n        var height = size[1] + 2 * verti;\n        var layer = node.layer;\n\n        if (isNumber(layer)) {\n          // 如果有layer属性，加入到node的label中\n          g.setNode(node.id, {\n            width: width,\n            height: height,\n            layer: layer\n          });\n        } else {\n          g.setNode(node.id, {\n            width: width,\n            height: height\n          });\n        }\n\n        if (_this2.sortByCombo && node.comboId) {\n          if (!comboMap[node.comboId]) {\n            comboMap[node.comboId] = true;\n            g.setNode(node.comboId, {});\n          }\n\n          g.setParent(node.id, node.comboId);\n        }\n      });\n\n      if (this.sortByCombo && combos) {\n        combos.forEach(function (combo) {\n          if (!combo.parentId) return;\n\n          if (!comboMap[combo.parentId]) {\n            comboMap[combo.parentId] = true;\n            g.setNode(combo.parentId, {});\n          }\n\n          g.setParent(combo.id, combo.parentId);\n        });\n      }\n\n      edges.forEach(function (edge) {\n        // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n        var source = getEdgeTerminal(edge, 'source');\n        var target = getEdgeTerminal(edge, 'target');\n\n        if (_this2.layoutNode(source) && _this2.layoutNode(target)) {\n          g.setEdge(source, target, {\n            weight: edge.weight || 1\n          });\n        }\n      }); // 考虑增量图中的原始图\n\n      var prevGraph = undefined;\n\n      if (self.preset) {\n        prevGraph = new dagre.graphlib.Graph({\n          multigraph: true,\n          compound: true\n        });\n        self.preset.nodes.forEach(function (node) {\n          prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);\n        });\n      }\n\n      dagre.layout(g, {\n        prevGraph: prevGraph,\n        edgeLabelSpace: self.edgeLabelSpace,\n        keepNodeOrder: Boolean(!!self.nodeOrder),\n        nodeOrder: self.nodeOrder\n      });\n      var dBegin = [0, 0];\n\n      if (begin) {\n        var minX = Infinity;\n        var minY = Infinity;\n        g.nodes().forEach(function (node) {\n          var coord = g.node(node);\n          if (minX > coord.x) minX = coord.x;\n          if (minY > coord.y) minY = coord.y;\n        });\n        g.edges().forEach(function (edge) {\n          var coord = g.edge(edge);\n          coord.points.forEach(function (point) {\n            if (minX > point.x) minX = point.x;\n            if (minY > point.y) minY = point.y;\n          });\n        });\n        dBegin[0] = begin[0] - minX;\n        dBegin[1] = begin[1] - minY;\n      }\n\n      g.nodes().forEach(function (node) {\n        var coord = g.node(node);\n        var i = nodes.findIndex(function (it) {\n          return it.id === node;\n        });\n        if (!nodes[i]) return;\n        nodes[i].x = coord.x + dBegin[0];\n        nodes[i].y = coord.y + dBegin[1]; // @ts-ignore: pass layer order to data for increment layout use\n\n        nodes[i]._order = coord._order;\n      });\n      g.edges().forEach(function (edge) {\n        var coord = g.edge(edge);\n        var i = edges.findIndex(function (it) {\n          var source = getEdgeTerminal(it, 'source');\n          var target = getEdgeTerminal(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n\n        if (self.edgeLabelSpace && self.controlPoints && edges[i].type !== \"loop\") {\n          edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n          edges[i].controlPoints.forEach(function (point) {\n            point.x += dBegin[0];\n            point.y += dBegin[1];\n          });\n        }\n      });\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"dagre\";\n    }\n  }]);\n\n  return DagreLayout;\n}(Base);\n\nfunction getFunc(func, value, defaultValue) {\n  var resultFunc;\n\n  if (func) {\n    resultFunc = func;\n  } else if (isNumber(value)) {\n    resultFunc = function resultFunc() {\n      return value;\n    };\n  } else {\n    resultFunc = function resultFunc() {\n      return defaultValue;\n    };\n  }\n\n  return resultFunc;\n}","map":null,"metadata":{},"sourceType":"module"}