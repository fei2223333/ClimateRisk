{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport var PriorityQueue = /*#__PURE__*/function () {\n  function PriorityQueue() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PriorityQueue);\n\n    this.comparator = options.comparator || PriorityQueue.defaultComparator;\n    this.index = {};\n    this.data = options.data || [];\n    this.heapify();\n  }\n  /**\n   * Returns `true` if the priority queue is empty, `false` otherwise.\n   */\n\n\n  _createClass(PriorityQueue, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.data.length === 0;\n    }\n    /**\n     * Inserts a value with priority to the queue. Optionally pass a unique\n     * id of this item. Passing unique IDs for each item you insert allows\n     * you to use the `updatePriority()` operation.\n     * @param priority\n     * @param value\n     * @param id\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(priority, value, id) {\n      var item = {\n        priority: priority,\n        value: value\n      };\n      var index = this.data.length - 1;\n\n      if (id) {\n        item.id = id;\n        this.index[id] = index;\n      }\n\n      this.data.push(item);\n      this.bubbleUp(index);\n      return this;\n    }\n    /**\n     * Returns the value of an item with the highest priority.\n     */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.data[0] ? this.data[0].value : null;\n    }\n    /**\n     * Returns the highest priority in the queue.\n     */\n\n  }, {\n    key: \"peekPriority\",\n    value: function peekPriority() {\n      return this.data[0] ? this.data[0].priority : null;\n    }\n  }, {\n    key: \"updatePriority\",\n    value: function updatePriority(id, priority) {\n      var index = this.index[id];\n\n      if (typeof index === 'undefined') {\n        throw new Error(\"Node with id '\".concat(id, \"' was not found in the heap.\"));\n      }\n\n      var data = this.data;\n      var oldPriority = data[index].priority;\n      var comp = this.comparator(priority, oldPriority);\n\n      if (comp < 0) {\n        data[index].priority = priority;\n        this.bubbleUp(index);\n      } else if (comp > 0) {\n        data[index].priority = priority;\n        this.bubbleDown(index);\n      }\n    }\n    /**\n     * Removes the item with the highest priority from the queue\n     *\n     * @returns The value of the removed item.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var data = this.data;\n      var peek = data[0];\n      var last = data.pop();\n      delete this.index[data.length];\n\n      if (data.length > 0) {\n        data[0] = last;\n\n        if (last.id) {\n          this.index[last.id] = 0;\n        }\n\n        this.bubbleDown(0);\n      }\n\n      return peek ? peek.value : null;\n    }\n  }, {\n    key: \"heapify\",\n    value: function heapify() {\n      for (var i = 0; i < this.data.length; i += 1) {\n        this.bubbleUp(i);\n      }\n    }\n  }, {\n    key: \"bubbleUp\",\n    value: function bubbleUp(index) {\n      var data = this.data;\n      var tmp;\n      var parent;\n      var current = index;\n\n      while (current > 0) {\n        parent = current - 1 >>> 1;\n\n        if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n          tmp = data[parent];\n          data[parent] = data[current];\n          var id = data[current].id;\n\n          if (id != null) {\n            this.index[id] = parent;\n          }\n\n          data[current] = tmp;\n          id = data[current].id;\n\n          if (id != null) {\n            this.index[id] = current;\n          }\n\n          current = parent;\n        } else {\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"bubbleDown\",\n    value: function bubbleDown(index) {\n      var data = this.data;\n      var last = data.length - 1;\n      var current = index; // eslint-disable-next-line\n\n      while (true) {\n        var left = (current << 1) + 1;\n        var right = left + 1;\n        var minIndex = current;\n\n        if (left <= last && this.comparator(data[left].priority, data[minIndex].priority) < 0) {\n          minIndex = left;\n        }\n\n        if (right <= last && this.comparator(data[right].priority, data[minIndex].priority) < 0) {\n          minIndex = right;\n        }\n\n        if (minIndex !== current) {\n          var tmp = data[minIndex];\n          data[minIndex] = data[current];\n          var id = data[current].id;\n\n          if (id != null) {\n            this.index[id] = minIndex;\n          }\n\n          data[current] = tmp;\n          id = data[current].id;\n\n          if (id != null) {\n            this.index[id] = current;\n          }\n\n          current = minIndex;\n        } else {\n          break;\n        }\n      }\n    }\n  }]);\n\n  return PriorityQueue;\n}();\n\n(function (PriorityQueue) {\n  PriorityQueue.defaultComparator = function (a, b) {\n    return a - b;\n  };\n})(PriorityQueue || (PriorityQueue = {}));","map":null,"metadata":{},"sourceType":"module"}