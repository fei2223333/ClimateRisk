{"ast":null,"code":"import { Point } from '../point';\nvar regexSupportedData = new RegExp(\"^[\\\\s\\\\dLMCZz,.]*$\");\nexport function isValid(data) {\n  if (typeof data !== 'string') {\n    return false;\n  }\n\n  return regexSupportedData.test(data);\n}\n/**\n * Returns the remainder of division of `n` by `m`. You should use this\n * instead of the built-in operation as the built-in operation does not\n * properly handle negative numbers.\n */\n\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n\nfunction draw(points, round, initialMove, close, exclude) {\n  var data = [];\n  var end = points[points.length - 1];\n  var rounded = round != null && round > 0;\n  var arcSize = round || 0; // Adds virtual waypoint in the center between start and end point\n\n  if (close && rounded) {\n    points = points.slice(); // eslint-disable-line\n\n    var p0 = points[0];\n    var wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);\n    points.splice(0, 0, wp);\n  }\n\n  var pt = points[0];\n  var i = 1; // Draws the line segments\n\n  if (initialMove) {\n    data.push('M', pt.x, pt.y);\n  } else {\n    data.push('L', pt.x, pt.y);\n  }\n\n  while (i < (close ? points.length : points.length - 1)) {\n    var tmp = points[mod(i, points.length)];\n    var dx = pt.x - tmp.x;\n    var dy = pt.y - tmp.y;\n\n    if (rounded && (dx !== 0 || dy !== 0) && (exclude == null || exclude.indexOf(i - 1) < 0)) {\n      // Draws a line from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the last point\n      var dist = Math.sqrt(dx * dx + dy * dy);\n      var nx1 = dx * Math.min(arcSize, dist / 2) / dist;\n      var ny1 = dy * Math.min(arcSize, dist / 2) / dist;\n      var x1 = tmp.x + nx1;\n      var y1 = tmp.y + ny1;\n      data.push('L', x1, y1); // Draws a curve from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the next point\n\n      var next = points[mod(i + 1, points.length)]; // Uses next non-overlapping point\n\n      while (i < points.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0) {\n        next = points[mod(i + 2, points.length)];\n        i += 1;\n      }\n\n      dx = next.x - tmp.x;\n      dy = next.y - tmp.y;\n      dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n      var nx2 = dx * Math.min(arcSize, dist / 2) / dist;\n      var ny2 = dy * Math.min(arcSize, dist / 2) / dist;\n      var x2 = tmp.x + nx2;\n      var y2 = tmp.y + ny2;\n      data.push('Q', tmp.x, tmp.y, x2, y2);\n      tmp = new Point(x2, y2);\n    } else {\n      data.push('L', tmp.x, tmp.y);\n    }\n\n    pt = tmp;\n    i += 1;\n  }\n\n  if (close) {\n    data.push('Z');\n  } else {\n    data.push('L', end.x, end.y);\n  }\n\n  return data.map(function (v) {\n    return typeof v === 'string' ? v : +v.toFixed(3);\n  }).join(' ');\n}\n\nexport function drawPoints(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var pts = [];\n\n  if (points && points.length) {\n    points.forEach(function (p) {\n      if (Array.isArray(p)) {\n        pts.push({\n          x: p[0],\n          y: p[1]\n        });\n      } else {\n        pts.push({\n          x: p.x,\n          y: p.y\n        });\n      }\n    });\n  }\n\n  return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);\n}\n/**\n * Converts the given arc to a series of curves.\n */\n\nexport function arcToCurves(x0, y0, r1, r2) {\n  var angle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var largeArcFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var sweepFlag = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var x = arguments.length > 7 ? arguments[7] : undefined;\n  var y = arguments.length > 8 ? arguments[8] : undefined;\n\n  if (r1 === 0 || r2 === 0) {\n    return [];\n  }\n\n  x -= x0; // eslint-disable-line\n\n  y -= y0; // eslint-disable-line\n\n  r1 = Math.abs(r1); // eslint-disable-line\n\n  r2 = Math.abs(r2); // eslint-disable-line\n\n  var ctx = -x / 2;\n  var cty = -y / 2;\n  var cpsi = Math.cos(angle * Math.PI / 180);\n  var spsi = Math.sin(angle * Math.PI / 180);\n  var rxd = cpsi * ctx + spsi * cty;\n  var ryd = -1 * spsi * ctx + cpsi * cty;\n  var rxdd = rxd * rxd;\n  var rydd = ryd * ryd;\n  var r1x = r1 * r1;\n  var r2y = r2 * r2;\n  var lamda = rxdd / r1x + rydd / r2y;\n  var sds;\n\n  if (lamda > 1) {\n    r1 = Math.sqrt(lamda) * r1; // eslint-disable-line\n\n    r2 = Math.sqrt(lamda) * r2; // eslint-disable-line\n\n    sds = 0;\n  } else {\n    var seif = 1;\n\n    if (largeArcFlag === sweepFlag) {\n      seif = -1;\n    }\n\n    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n  }\n\n  var txd = sds * r1 * ryd / r2;\n  var tyd = -1 * sds * r2 * rxd / r1;\n  var tx = cpsi * txd - spsi * tyd + x / 2;\n  var ty = spsi * txd + cpsi * tyd + y / 2;\n  var rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n  var s1 = rad >= 0 ? rad : 2 * Math.PI + rad;\n  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n  var dr = rad >= 0 ? rad : 2 * Math.PI + rad;\n\n  if (sweepFlag === 0 && dr > 0) {\n    dr -= 2 * Math.PI;\n  } else if (sweepFlag !== 0 && dr < 0) {\n    dr += 2 * Math.PI;\n  }\n\n  var sse = dr * 2 / Math.PI;\n  var seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n  var segr = dr / seg;\n  var t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);\n  var cpsir1 = cpsi * r1;\n  var cpsir2 = cpsi * r2;\n  var spsir1 = spsi * r1;\n  var spsir2 = spsi * r2;\n  var mc = Math.cos(s1);\n  var ms = Math.sin(s1);\n  var x2 = -t * (cpsir1 * ms + spsir2 * mc);\n  var y2 = -t * (spsir1 * ms - cpsir2 * mc);\n  var x3 = 0;\n  var y3 = 0;\n  var result = [];\n\n  for (var n = 0; n < seg; n += 1) {\n    s1 += segr;\n    mc = Math.cos(s1);\n    ms = Math.sin(s1);\n    x3 = cpsir1 * mc - spsir2 * ms + tx;\n    y3 = spsir1 * mc + cpsir2 * ms + ty;\n    var dx = -t * (cpsir1 * ms + spsir2 * mc);\n    var dy = -t * (spsir1 * ms - cpsir2 * mc); // CurveTo updates x0, y0 so need to restore it\n\n    var index = n * 6;\n    result[index] = Number(x2 + x0);\n    result[index + 1] = Number(y2 + y0);\n    result[index + 2] = Number(x3 - dx + x0);\n    result[index + 3] = Number(y3 - dy + y0);\n    result[index + 4] = Number(x3 + x0);\n    result[index + 5] = Number(y3 + y0);\n    x2 = x3 + dx;\n    y2 = y3 + dy;\n  }\n\n  return result.map(function (num) {\n    return +num.toFixed(2);\n  });\n}\nexport function drawArc(startX, startY, rx, ry) {\n  var xAxisRotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var largeArcFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var sweepFlag = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var stopX = arguments.length > 7 ? arguments[7] : undefined;\n  var stopY = arguments.length > 8 ? arguments[8] : undefined;\n  var data = [];\n  var points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);\n\n  if (points != null) {\n    for (var i = 0, ii = points.length; i < ii; i += 6) {\n      data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n    }\n  }\n\n  return data.join(' ');\n}","map":null,"metadata":{},"sourceType":"module"}