{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Path } from '../../geometry';\nimport * as Dom from '../dom/core';\nexport var Vector = /*#__PURE__*/function () {\n  function Vector(elem, attrs, children) {\n    _classCallCheck(this, Vector);\n\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector');\n    }\n\n    var node;\n\n    if (Vector.isVector(elem)) {\n      node = elem.node;\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument();\n      } else if (elem[0] === '<') {\n        var doc = Dom.createSvgDocument(elem); // only import the first child\n\n        node = document.importNode(doc.firstChild, true);\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem);\n      }\n    } else {\n      node = elem;\n    }\n\n    this.node = node;\n\n    if (attrs) {\n      this.setAttributes(attrs);\n    }\n\n    if (children) {\n      this.append(children);\n    }\n  }\n\n  _createClass(Vector, [{\n    key: \"transform\",\n    value: function transform(matrix, options) {\n      if (matrix == null) {\n        return Dom.transform(this.node);\n      }\n\n      Dom.transform(this.node, matrix, options);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx) {\n      var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (tx == null) {\n        return Dom.translate(this.node);\n      }\n\n      Dom.translate(this.node, tx, ty, options);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, cx, cy) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (angle == null) {\n        return Dom.rotate(this.node);\n      }\n\n      Dom.rotate(this.node, angle, cx, cy, options);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      if (sx == null) {\n        return Dom.scale(this.node);\n      }\n\n      Dom.scale(this.node, sx, sy);\n      return this;\n    }\n    /**\n     * Returns an SVGMatrix that specifies the transformation necessary\n     * to convert this coordinate system into `target` coordinate system.\n     */\n\n  }, {\n    key: \"getTransformToElement\",\n    value: function getTransformToElement(target) {\n      var ref = Vector.toNode(target);\n      return Dom.getTransformToElement(this.node, ref);\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(name) {\n      Dom.removeAttribute(this.node, name);\n      return this;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      return Dom.getAttribute(this.node, name);\n    }\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(name, value) {\n      Dom.setAttribute(this.node, name, value);\n      return this;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attrs) {\n      Dom.setAttributes(this.node, attrs);\n      return this;\n    }\n  }, {\n    key: \"attr\",\n    value: function attr(name, value) {\n      if (name == null) {\n        return Dom.attr(this.node);\n      }\n\n      if (typeof name === 'string' && value === undefined) {\n        return Dom.attr(this.node, name);\n      }\n\n      if (typeof name === 'object') {\n        Dom.attr(this.node, name);\n      } else {\n        Dom.attr(this.node, name, value);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"svg\",\n    value: function svg() {\n      return this.node instanceof SVGSVGElement ? this : Vector.create(this.node.ownerSVGElement);\n    }\n  }, {\n    key: \"defs\",\n    value: function defs() {\n      var context = this.svg() || this;\n      var defsNode = context.node.getElementsByTagName('defs')[0];\n\n      if (defsNode) {\n        return Vector.create(defsNode);\n      }\n\n      return Vector.create('defs').appendTo(context);\n    }\n  }, {\n    key: \"text\",\n    value: function text(content) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      Dom.text(this.node, content, options);\n      return this;\n    }\n  }, {\n    key: \"tagName\",\n    value: function tagName() {\n      return Dom.tagName(this.node);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return Vector.create(this.node.cloneNode(true));\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      Dom.remove(this.node);\n      return this;\n    }\n  }, {\n    key: \"empty\",\n    value: function empty() {\n      Dom.empty(this.node);\n      return this;\n    }\n  }, {\n    key: \"append\",\n    value: function append(elems) {\n      Dom.append(this.node, Vector.toNodes(elems));\n      return this;\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(target) {\n      Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);\n      return this;\n    }\n  }, {\n    key: \"prepend\",\n    value: function prepend(elems) {\n      Dom.prepend(this.node, Vector.toNodes(elems));\n      return this;\n    }\n  }, {\n    key: \"before\",\n    value: function before(elems) {\n      Dom.before(this.node, Vector.toNodes(elems));\n      return this;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(elem) {\n      if (this.node.parentNode) {\n        this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);\n      }\n\n      return Vector.create(elem);\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.node.firstChild ? Vector.create(this.node.firstChild) : null;\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.node.lastChild ? Vector.create(this.node.lastChild) : null;\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      var child = this.node.childNodes[index];\n      return child ? Vector.create(child) : null;\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(elem) {\n      var children = Array.prototype.slice.call(this.node.childNodes);\n      return children.indexOf(Vector.toNode(elem));\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector) {\n      var vels = [];\n      var nodes = Dom.find(this.node, selector);\n\n      if (nodes) {\n        for (var i = 0, ii = nodes.length; i < ii; i += 1) {\n          vels.push(Vector.create(nodes[i]));\n        }\n      }\n\n      return vels;\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(selector) {\n      var found = Dom.findOne(this.node, selector);\n      return found ? Vector.create(found) : null;\n    }\n  }, {\n    key: \"findParentByClass\",\n    value: function findParentByClass(className, terminator) {\n      var node = Dom.findParentByClass(this.node, className, terminator);\n      return node ? Vector.create(node) : null;\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(selector) {\n      var node = this.node;\n      var matches = this.node.matches;\n      var matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;\n      return matcher && matcher.call(node, selector);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(child) {\n      return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(node) {\n      var vel = Vector.create(node);\n      var parentNode = this.node.parentNode;\n\n      if (parentNode != null) {\n        parentNode.insertBefore(vel.node, this.node);\n      }\n\n      return vel.append(this);\n    }\n  }, {\n    key: \"parent\",\n    value: function parent(type) {\n      var parent = this; // eslint-disable-line @typescript-eslint/no-this-alias\n      // check for parent\n\n      if (parent.node.parentNode == null) {\n        return null;\n      } // get parent element\n\n\n      parent = Vector.create(parent.node.parentNode);\n\n      if (type == null) {\n        return parent;\n      } // loop trough ancestors if type is given\n\n\n      do {\n        if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {\n          return parent;\n        }\n      } while (parent = Vector.create(parent.node.parentNode));\n\n      return parent;\n    }\n  }, {\n    key: \"children\",\n    value: function children() {\n      var children = this.node.childNodes;\n      var vels = [];\n\n      for (var i = 0; i < children.length; i += 1) {\n        var currentChild = children[i];\n\n        if (currentChild.nodeType === 1) {\n          vels.push(Vector.create(children[i]));\n        }\n      }\n\n      return vels;\n    }\n  }, {\n    key: \"eachChild\",\n    value: function eachChild(fn, deep) {\n      var children = this.children();\n\n      for (var i = 0, l = children.length; i < l; i += 1) {\n        fn.call(children[i], children[i], i, children);\n\n        if (deep) {\n          children[i].eachChild(fn, deep);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"index\",\n    value: function index() {\n      return Dom.index(this.node);\n    }\n  }, {\n    key: \"hasClass\",\n    value: function hasClass(className) {\n      return Dom.hasClass(this.node, className);\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass(className) {\n      Dom.addClass(this.node, className);\n      return this;\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(className) {\n      Dom.removeClass(this.node, className);\n      return this;\n    }\n  }, {\n    key: \"toggleClass\",\n    value: function toggleClass(className, stateVal) {\n      Dom.toggleClass(this.node, className, stateVal);\n      return this;\n    }\n  }, {\n    key: \"toLocalPoint\",\n    value: function toLocalPoint(x, y) {\n      return Dom.toLocalPoint(this.node, x, y);\n    }\n  }, {\n    key: \"toGeometryShape\",\n    value: function toGeometryShape() {\n      return Dom.toGeometryShape(this.node);\n    }\n  }, {\n    key: \"translateCenterToPoint\",\n    value: function translateCenterToPoint(p) {\n      var bbox = this.getBBox({\n        target: this.svg()\n      });\n      var center = bbox.getCenter();\n      this.translate(p.x - center.x, p.y - center.y);\n      return this;\n    }\n  }, {\n    key: \"translateAndAutoOrient\",\n    value: function translateAndAutoOrient(position, reference, target) {\n      Dom.translateAndAutoOrient(this.node, position, reference, target);\n      return this;\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(options) {\n      return Dom.animate(this.node, options);\n    }\n  }, {\n    key: \"animateTransform\",\n    value: function animateTransform(options) {\n      return Dom.animateTransform(this.node, options);\n    }\n  }, {\n    key: \"animateAlongPath\",\n    value: function animateAlongPath(options, path) {\n      return Dom.animateAlongPath(this.node, options, path);\n    }\n    /**\n     * Normalize this element's d attribute. SVGPathElements without\n     * a path data attribute obtain a value of 'M 0 0'.\n     */\n\n  }, {\n    key: \"normalizePath\",\n    value: function normalizePath() {\n      var tagName = this.tagName();\n\n      if (tagName === 'path') {\n        this.attr('d', Path.normalize(this.attr('d')));\n      }\n\n      return this;\n    }\n    /**\n     * Returns the bounding box of the element after transformations are applied.\n     * If `withoutTransformations` is `true`, transformations of the element\n     * will not be considered when computing the bounding box. If `target` is\n     * specified, bounding box will be computed relatively to the target element.\n     */\n\n  }, {\n    key: \"bbox\",\n    value: function bbox(withoutTransformations, target) {\n      return Dom.bbox(this.node, withoutTransformations, target);\n    }\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return Dom.getBBox(this.node, {\n        recursive: options.recursive,\n        target: options.target ? Vector.toNode(options.target) : null\n      });\n    }\n    /**\n     * Samples the underlying SVG element (it currently works only on\n     * paths - where it is most useful anyway). Returns an array of objects\n     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n     * objects represent a point on the path. This basically creates a discrete\n     * representation of the path (which is possible a curve). The sampling\n     * interval defines the accuracy of the sampling. In other words, we travel\n     * from the beginning of the path to the end by interval distance (on the\n     * path, not between the resulting points) and collect the discrete points\n     * on the path. This is very useful in many situations. For example, SVG\n     * does not provide a built-in mechanism to find intersections between two\n     * paths. Using sampling, we can just generate bunch of points for each of\n     * the path and find the closest ones from each set.\n     */\n\n  }, {\n    key: \"sample\",\n    value: function sample() {\n      var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      if (this.node instanceof SVGPathElement) {\n        return Dom.sample(this.node, interval);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"toPath\",\n    value: function toPath() {\n      return Vector.create(Dom.toPath(this.node));\n    }\n  }, {\n    key: \"toPathData\",\n    value: function toPathData() {\n      return Dom.toPathData(this.node);\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return Vector.toStringTag;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.node.nodeName;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.node.id;\n    },\n    set: function set(id) {\n      this.node.id = id;\n    }\n  }]);\n\n  return Vector;\n}();\n\n(function (Vector) {\n  Vector.toStringTag = \"X6.\".concat(Vector.name);\n\n  function isVector(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Vector) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var vector = instance;\n\n    if ((tag == null || tag === Vector.toStringTag) && vector.node instanceof SVGElement && typeof vector.animate === 'function' && typeof vector.sample === 'function' && typeof vector.normalizePath === 'function' && typeof vector.toPath === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Vector.isVector = isVector;\n\n  function create(elem, attrs, children) {\n    return new Vector(elem, attrs, children);\n  }\n\n  Vector.create = create;\n\n  function createVectors(markup) {\n    if (markup[0] === '<') {\n      var svgDoc = Dom.createSvgDocument(markup);\n      var vels = [];\n\n      for (var i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        var childNode = svgDoc.childNodes[i];\n        vels.push(create(document.importNode(childNode, true)));\n      }\n\n      return vels;\n    }\n\n    return [create(markup)];\n  }\n\n  Vector.createVectors = createVectors;\n\n  function toNode(elem) {\n    if (isVector(elem)) {\n      return elem.node;\n    }\n\n    return elem;\n  }\n\n  Vector.toNode = toNode;\n\n  function toNodes(elems) {\n    if (Array.isArray(elems)) {\n      return elems.map(function (elem) {\n        return toNode(elem);\n      });\n    }\n\n    return [toNode(elems)];\n  }\n\n  Vector.toNodes = toNodes;\n})(Vector || (Vector = {}));","map":null,"metadata":{},"sourceType":"module"}