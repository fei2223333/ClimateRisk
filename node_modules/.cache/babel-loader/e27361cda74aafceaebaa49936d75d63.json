{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findMinMaxNodeXY = exports.traverseTreeUp = exports.scaleMatrix = exports.getAdjMatrix = exports.floydWarshall = exports.getDegree = exports.getEdgeTerminal = void 0;\n\nvar object_1 = require(\"./object\");\n\nvar getEdgeTerminal = function getEdgeTerminal(edge, type) {\n  var terminal = edge[type];\n\n  if ((0, object_1.isObject)(terminal)) {\n    return terminal.cell;\n  }\n\n  return terminal;\n};\n\nexports.getEdgeTerminal = getEdgeTerminal;\n\nvar getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  if (!edges) return degrees;\n  edges.forEach(function (e) {\n    var source = (0, exports.getEdgeTerminal)(e, 'source');\n    var target = (0, exports.getEdgeTerminal)(e, 'target');\n\n    if (source) {\n      degrees[nodeIdxMap[source]] += 1;\n    }\n\n    if (target) {\n      degrees[nodeIdxMap[target]] += 1;\n    }\n  });\n  return degrees;\n};\n\nexports.getDegree = getDegree;\n\nvar floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\n\nexports.floydWarshall = floydWarshall;\n\nvar getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n      edges = data.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = (0, exports.getEdgeTerminal)(e, 'source');\n      var target = (0, exports.getEdgeTerminal)(e, 'target');\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n\nexports.getAdjMatrix = getAdjMatrix;\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\n\nvar scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n\nexports.scaleMatrix = scaleMatrix;\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\nvar traverseUp = function traverseUp(data, fn) {\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (!fn(data)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\n\n\nvar traverseTreeUp = function traverseTreeUp(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};\n\nexports.traverseTreeUp = traverseTreeUp;\n\nvar findMinMaxNodeXY = function findMinMaxNodeXY(nodes) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var maxX = -Infinity;\n  var maxY = -Infinity;\n  nodes.forEach(function (node) {\n    if (minX > node.x) minX = node.x;\n    if (minY > node.y) minY = node.y;\n    if (maxX < node.x) maxX = node.x;\n    if (maxY < node.y) maxY = node.y;\n  });\n  return {\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY\n  };\n};\n\nexports.findMinMaxNodeXY = findMinMaxNodeXY;","map":null,"metadata":{},"sourceType":"script"}