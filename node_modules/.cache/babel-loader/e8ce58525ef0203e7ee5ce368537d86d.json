{"ast":null,"code":"import { Point, Path, Polyline } from '../../geometry';\nimport { NumberExt, FunctionExt } from '../../util';\nexport var ref = {// We do not set `ref` attribute directly on an element.\n  // The attribute itself does not qualify for relative positioning.\n}; // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n// otherwise, `refX` is the left coordinate of the bounding box\n\nexport var refX = {\n  position: positionWrapper('x', 'width', 'origin')\n};\nexport var refY = {\n  position: positionWrapper('y', 'height', 'origin')\n}; // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n// coordinate of the reference element.\n\nexport var refDx = {\n  position: positionWrapper('x', 'width', 'corner')\n};\nexport var refDy = {\n  position: positionWrapper('y', 'height', 'corner')\n}; // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n// the reference element size\n// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\nexport var refWidth = {\n  set: setWrapper('width', 'width')\n};\nexport var refHeight = {\n  set: setWrapper('height', 'height')\n};\nexport var refRx = {\n  set: setWrapper('rx', 'width')\n};\nexport var refRy = {\n  set: setWrapper('ry', 'height')\n};\nexport var refRInscribed = {\n  set: function (attrName) {\n    var widthFn = setWrapper(attrName, 'width');\n    var heightFn = setWrapper(attrName, 'height');\n    return function (value, options) {\n      var refBBox = options.refBBox;\n      var fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n      return FunctionExt.call(fn, this, value, options);\n    };\n  }('r')\n};\nexport var refRCircumscribed = {\n  set: function set(val, _ref) {\n    var refBBox = _ref.refBBox;\n    var value = parseFloat(val);\n    var percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n    var rValue;\n\n    if (Number.isFinite(value)) {\n      if (percentage || value >= 0 && value <= 1) {\n        rValue = value * diagonalLength;\n      } else {\n        rValue = Math.max(value + diagonalLength, 0);\n      }\n    }\n\n    return {\n      r: rValue\n    };\n  }\n};\nexport var refCx = {\n  set: setWrapper('cx', 'width')\n};\nexport var refCy = {\n  set: setWrapper('cy', 'height')\n};\nexport var refDResetOffset = {\n  set: dWrapper({\n    resetOffset: true\n  })\n};\nexport var refDKeepOffset = {\n  set: dWrapper({\n    resetOffset: false\n  })\n};\nexport var refPointsResetOffset = {\n  set: pointsWrapper({\n    resetOffset: true\n  })\n};\nexport var refPointsKeepOffset = {\n  set: pointsWrapper({\n    resetOffset: false\n  })\n}; // aliases\n// -------\n\nexport var refR = refRInscribed;\nexport var refD = refDResetOffset;\nexport var refPoints = refPointsResetOffset; // Allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\n\nexport var refX2 = refX;\nexport var refY2 = refY;\nexport var refWidth2 = refWidth;\nexport var refHeight2 = refHeight; // utils\n// -----\n\nfunction positionWrapper(axis, dimension, origin) {\n  return function (val, _ref2) {\n    var refBBox = _ref2.refBBox;\n\n    if (val == null) {\n      return null;\n    }\n\n    var value = parseFloat(val);\n    var percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    var delta;\n\n    if (Number.isFinite(value)) {\n      var refOrigin = refBBox[origin];\n\n      if (percentage || value > 0 && value < 1) {\n        delta = refOrigin[axis] + refBBox[dimension] * value;\n      } else {\n        delta = refOrigin[axis] + value;\n      }\n    }\n\n    var point = new Point();\n    point[axis] = delta || 0;\n    return point;\n  };\n}\n\nfunction setWrapper(attrName, dimension) {\n  return function (val, _ref3) {\n    var refBBox = _ref3.refBBox;\n    var value = parseFloat(val);\n    var percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    var attrs = {};\n\n    if (Number.isFinite(value)) {\n      var attrValue = percentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n      attrs[attrName] = attrValue;\n    }\n\n    return attrs;\n  };\n}\n\nfunction shapeWrapper(shapeConstructor, options) {\n  var cacheName = 'x6-shape';\n  var resetOffset = options && options.resetOffset;\n  return function (value, _ref4) {\n    var view = _ref4.view,\n        elem = _ref4.elem,\n        refBBox = _ref4.refBBox;\n    var $elem = view.$(elem);\n    var cache = $elem.data(cacheName);\n\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      var cachedShape = shapeConstructor(value);\n      cache = {\n        value: value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox()\n      };\n      $elem.data(cacheName, cache);\n    }\n\n    var shape = cache.shape.clone();\n    var shapeBBox = cache.shapeBBox.clone();\n    var shapeOrigin = shapeBBox.getOrigin();\n    var refOrigin = refBBox.getOrigin();\n    shapeBBox.x = refOrigin.x;\n    shapeBBox.y = refOrigin.y;\n    var fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin); // `maxRectScaleToFit` can give Infinity if width or height is 0\n\n    var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n    var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n    shape.scale(sx, sy, shapeOrigin);\n\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n    }\n\n    return shape;\n  };\n} // `d` attribute for SVGPaths\n\n\nfunction dWrapper(options) {\n  function pathConstructor(value) {\n    return Path.parse(value);\n  }\n\n  var shape = shapeWrapper(pathConstructor, options);\n  return function (value, args) {\n    var path = shape(value, args);\n    return {\n      d: path.serialize()\n    };\n  };\n} // `points` attribute for SVGPolylines and SVGPolygons\n\n\nfunction pointsWrapper(options) {\n  var shape = shapeWrapper(function (points) {\n    return new Polyline(points);\n  }, options);\n  return function (value, args) {\n    var polyline = shape(value, args);\n    return {\n      points: polyline.serialize()\n    };\n  };\n}","map":null,"metadata":{},"sourceType":"module"}