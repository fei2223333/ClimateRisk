{"ast":null,"code":"import _toConsumableArray from \"/Users/shuge/Documents/project/rekit-project/ServiceWebsite/Spine/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/* eslint-disable no-control-regex */\nimport { NumberExt } from '../number';\nimport { Text } from '../text';\nimport { attr } from './attr';\nimport { Vector } from '../vector';\nimport { createSvgElement, empty, remove } from './elem';\nimport { Platform } from '../platform';\n\nfunction createTextPathNode(attrs, elem) {\n  var vel = Vector.create(elem);\n  var textPath = Vector.create('textPath');\n  var d = attrs.d;\n\n  if (d && attrs['xlink:href'] === undefined) {\n    var path = Vector.create('path').attr('d', d).appendTo(vel.defs());\n    textPath.attr('xlink:href', \"#\".concat(path.id));\n  }\n\n  if (typeof attrs === 'object') {\n    textPath.attr(attrs);\n  }\n\n  return textPath.node;\n}\n\nfunction annotateTextLine(lineNode, lineAnnotations, options) {\n  var eol = options.eol;\n  var baseSize = options.baseSize;\n  var lineHeight = options.lineHeight;\n  var maxFontSize = 0;\n  var tspanNode;\n  var fontMetrics = {};\n  var lastJ = lineAnnotations.length - 1;\n\n  for (var j = 0; j <= lastJ; j += 1) {\n    var annotation = lineAnnotations[j];\n    var fontSize = null;\n\n    if (typeof annotation === 'object') {\n      var annotationAttrs = annotation.attrs;\n      var vTSpan = Vector.create('tspan', annotationAttrs);\n      tspanNode = vTSpan.node;\n      var t = annotation.t;\n\n      if (eol && j === lastJ) {\n        t += eol;\n      }\n\n      tspanNode.textContent = t; // Per annotation className\n\n      var annotationClass = annotationAttrs.class;\n\n      if (annotationClass) {\n        vTSpan.addClass(annotationClass);\n      } // set the list of indices of all the applied annotations\n      // in the `annotations` attribute. This list is a comma\n      // separated list of indices.\n\n\n      if (options.includeAnnotationIndices) {\n        vTSpan.attr('annotations', annotation.annotations.join(','));\n      } // Check for max font size\n\n\n      fontSize = parseFloat(annotationAttrs['font-size']);\n      if (fontSize === undefined) fontSize = baseSize;\n      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n    } else {\n      if (eol && j === lastJ) {\n        annotation += eol;\n      }\n\n      tspanNode = document.createTextNode(annotation || ' ');\n\n      if (baseSize && baseSize > maxFontSize) {\n        maxFontSize = baseSize;\n      }\n    }\n\n    lineNode.appendChild(tspanNode);\n  }\n\n  if (maxFontSize) {\n    fontMetrics.maxFontSize = maxFontSize;\n  }\n\n  if (lineHeight) {\n    fontMetrics.lineHeight = lineHeight;\n  } else if (maxFontSize) {\n    fontMetrics.lineHeight = maxFontSize * 1.2;\n  }\n\n  return fontMetrics;\n}\n\nvar emRegex = /em$/;\n\nfunction emToPx(em, fontSize) {\n  var numerical = parseFloat(em);\n\n  if (emRegex.test(em)) {\n    return numerical * fontSize;\n  }\n\n  return numerical;\n}\n\nfunction calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n  if (!Array.isArray(linesMetrics)) {\n    return 0;\n  }\n\n  var n = linesMetrics.length;\n  if (!n) return 0;\n  var lineMetrics = linesMetrics[0];\n  var flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  var rLineHeights = 0;\n  var lineHeightPx = emToPx(lineHeight, baseSizePx);\n\n  for (var i = 1; i < n; i += 1) {\n    lineMetrics = linesMetrics[i];\n    var iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n    rLineHeights += iLineHeight;\n  }\n\n  var llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  var dy;\n\n  switch (alignment) {\n    case 'middle':\n      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n      break;\n\n    case 'bottom':\n      dy = -(0.25 * llMaxFont) - rLineHeights;\n      break;\n\n    default:\n    case 'top':\n      dy = 0.8 * flMaxFont;\n      break;\n  }\n\n  return dy;\n}\n\nexport function text(elem, content) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  content = Text.sanitize(content); // eslint-disable-line\n\n  var eol = options.eol;\n  var textPath = options.textPath;\n  var verticalAnchor = options.textVerticalAnchor;\n  var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top'; // Horizontal shift applied to all the lines but the first.\n\n  var x = options.x;\n\n  if (x === undefined) {\n    x = elem.getAttribute('x') || 0;\n  } // Annotations\n\n\n  var iai = options.includeAnnotationIndices;\n  var annotations = options.annotations;\n\n  if (annotations && !Array.isArray(annotations)) {\n    annotations = [annotations];\n  } // Shift all the <tspan> but first by one line (`1em`)\n\n\n  var defaultLineHeight = options.lineHeight;\n  var autoLineHeight = defaultLineHeight === 'auto';\n  var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n  empty(elem);\n  attr(elem, {\n    // Preserve spaces, do not consecutive spaces to get collapsed to one.\n    'xml:space': 'preserve',\n    // An empty text gets rendered into the DOM in webkit-based browsers.\n    // In order to unify this behaviour across all browsers\n    // we rather hide the text element when it's empty.\n    display: content || options.displayEmpty ? null : 'none'\n  }); // Set default font-size if none\n\n  var strFontSize = attr(elem, 'font-size');\n  var fontSize = parseFloat(strFontSize);\n\n  if (!fontSize) {\n    fontSize = 16;\n\n    if ((namedVerticalAnchor || annotations) && !strFontSize) {\n      attr(elem, 'font-size', \"\".concat(fontSize));\n    }\n  }\n\n  var containerNode;\n\n  if (textPath) {\n    // Now all the `<tspan>`s will be inside the `<textPath>`.\n    if (typeof textPath === 'string') {\n      textPath = {\n        d: textPath\n      };\n    }\n\n    containerNode = createTextPathNode(textPath, elem);\n  } else {\n    containerNode = document.createDocumentFragment();\n  }\n\n  var dy;\n  var offset = 0;\n  var annotatedY;\n  var lines = content.split('\\n');\n  var linesMetrics = [];\n  var lastI = lines.length - 1;\n\n  for (var i = 0; i <= lastI; i += 1) {\n    dy = lineHeight;\n    var lineClassName = 'v-line';\n    var lineNode = createSvgElement('tspan');\n    var lineMetrics = void 0;\n    var line = lines[i];\n\n    if (line) {\n      if (annotations) {\n        // Find the *compacted* annotations for this line.\n        var lineAnnotations = Text.annotate(line, annotations, {\n          offset: -offset,\n          includeAnnotationIndices: iai\n        });\n        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n          eol: i !== lastI && eol,\n          baseSize: fontSize,\n          lineHeight: autoLineHeight ? null : lineHeight,\n          includeAnnotationIndices: iai\n        }); // Get the line height based on the biggest font size\n        // in the annotations for this line.\n\n        var iLineHeight = lineMetrics.lineHeight;\n\n        if (iLineHeight && autoLineHeight && i !== 0) {\n          dy = iLineHeight;\n        }\n\n        if (i === 0) {\n          annotatedY = lineMetrics.maxFontSize * 0.8;\n        }\n      } else {\n        if (eol && i !== lastI) {\n          line += eol;\n        }\n\n        lineNode.textContent = line;\n      }\n    } else {\n      // Make sure the textContent is never empty. If it is, add a dummy\n      // character and make it invisible, making the following lines correctly\n      // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n      lineNode.textContent = '-';\n      lineClassName += ' v-empty-line';\n      var lineNodeStyle = lineNode.style;\n      lineNodeStyle.fillOpacity = 0;\n      lineNodeStyle.strokeOpacity = 0;\n\n      if (annotations) {\n        lineMetrics = {};\n      }\n    }\n\n    if (lineMetrics) {\n      linesMetrics.push(lineMetrics);\n    }\n\n    if (i > 0) {\n      lineNode.setAttribute('dy', dy);\n    } // Firefox requires 'x' to be set on the first line\n\n\n    if (i > 0 || textPath) {\n      lineNode.setAttribute('x', x);\n    }\n\n    lineNode.className.baseVal = lineClassName;\n    containerNode.appendChild(lineNode);\n    offset += line.length + 1; // + 1 = newline character.\n  } // Y Alignment calculation\n\n\n  if (namedVerticalAnchor) {\n    if (annotations) {\n      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n    } else if (verticalAnchor === 'top') {\n      // A shortcut for top alignment. It does not depend on font-size nor line-height\n      dy = '0.8em';\n    } else {\n      var rh; // remaining height\n\n      if (lastI > 0) {\n        rh = parseFloat(lineHeight) || 1;\n        rh *= lastI;\n        if (!emRegex.test(lineHeight)) rh /= fontSize;\n      } else {\n        // Single-line text\n        rh = 0;\n      }\n\n      switch (verticalAnchor) {\n        case 'middle':\n          dy = \"\".concat(0.3 - rh / 2, \"em\");\n          break;\n\n        case 'bottom':\n          dy = \"\".concat(-rh - 0.3, \"em\");\n          break;\n\n        default:\n          break;\n      }\n    }\n  } else if (verticalAnchor === 0) {\n    dy = '0em';\n  } else if (verticalAnchor) {\n    dy = verticalAnchor;\n  } else {\n    // No vertical anchor is defined\n    dy = 0; // Backwards compatibility - we change the `y` attribute instead of `dy`.\n\n    if (elem.getAttribute('y') == null) {\n      elem.setAttribute('y', \"\".concat(annotatedY || '0.8em'));\n    }\n  }\n\n  var firstLine = containerNode.firstChild;\n  firstLine.setAttribute('dy', dy);\n  elem.appendChild(containerNode);\n}\n\nfunction splitText(text, separator, eol, hyphen) {\n  var words = [];\n  var separators = [];\n\n  if (separator != null) {\n    var parts = text.split(separator);\n    words.push.apply(words, _toConsumableArray(parts));\n\n    if (typeof separator === 'string') {\n      for (var i = 0, l = parts.length - 1; i < l; i += 1) {\n        separators.push(separator);\n      }\n    } else {\n      var seps = text.match(new RegExp(separator, 'g'));\n\n      for (var _i = 0, _l = parts.length - 1; _i < _l; _i += 1) {\n        separators.push(seps ? seps[_i] : '');\n      }\n    }\n  } else {\n    var word = '';\n\n    for (var _i2 = 0, _l2 = text.length; _i2 < _l2; _i2 += 1) {\n      var char = text[_i2];\n\n      if (char === ' ') {\n        words.push(word);\n        separators.push(' ');\n        word = '';\n      } else if (char.match(/[^\\x00-\\xff]/)) {\n        // split double byte character\n        if (word.length) {\n          words.push(word);\n          separators.push('');\n        }\n\n        words.push(char);\n        separators.push('');\n        word = '';\n      } else {\n        word += char;\n      }\n    }\n\n    if (word.length) {\n      words.push(word);\n    }\n  } // end-of-line\n\n\n  for (var _i3 = 0; _i3 < words.length; _i3 += 1) {\n    var _word = words[_i3];\n\n    if (_word.indexOf(eol) >= 0 && _word.length > 1) {\n      var _parts = _word.split(eol);\n\n      for (var j = 0, k = _parts.length - 1; j < k; j += 1) {\n        _parts.splice(2 * j + 1, 0, eol);\n      }\n\n      var valids = _parts.filter(function (part) {\n        return part !== '';\n      });\n\n      words.splice.apply(words, [_i3, 1].concat(_toConsumableArray(valids)));\n\n      var _seps = valids.map(function () {\n        return '';\n      });\n\n      _seps.pop();\n\n      separators.splice.apply(separators, [_i3, 0].concat(_toConsumableArray(_seps)));\n    }\n  } // hyphen\n\n\n  for (var _i4 = 0; _i4 < words.length; _i4 += 1) {\n    var _word2 = words[_i4];\n\n    var index = _word2.search(hyphen);\n\n    if (index > 0 && index < _word2.length - 1) {\n      words.splice(_i4, 1, _word2.substring(0, index + 1), _word2.substring(index + 1));\n      separators.splice(_i4, 0, '');\n    }\n  }\n\n  return {\n    words: words,\n    separators: separators\n  };\n}\n\nexport function breakText(text, size) {\n  var styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var width = size.width;\n  var height = size.height;\n  var svgDocument = options.svgDocument || createSvgElement('svg');\n  var telem = createSvgElement('text');\n  var tspan = createSvgElement('tspan');\n  var tnode = document.createTextNode('');\n  attr(telem, styles);\n  telem.appendChild(tspan); // Prevent flickering\n\n  telem.style.opacity = '0'; // Prevent FF from throwing an uncaught exception when `getBBox()`\n  // called on element that is not in the render tree (is not measurable).\n  // <tspan>.getComputedTextLength() returns always 0 in this case.\n  // Note that the `textElement` resp. `textSpan` can become hidden\n  // when it's appended to the DOM and a `display: none` CSS stylesheet\n  // rule gets applied.\n\n  telem.style.display = 'block';\n  tspan.style.display = 'block';\n  tspan.appendChild(tnode);\n  svgDocument.appendChild(telem);\n  var shouldAppend = svgDocument.parentNode == null;\n\n  if (shouldAppend) {\n    document.body.appendChild(svgDocument);\n  }\n\n  var eol = options.eol || '\\n';\n  var separator = options.separator || ' ';\n  var hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\\w\\d]/;\n  var breakWord = options.breakWord !== false;\n  var full = [];\n  var lineSeprators = {};\n  var lines = [];\n  var partIndex; // let hyphenIndex\n\n  var lineHeight;\n  var currentSeparator;\n\n  var _splitText = splitText(text, options.separator, eol, hyphen),\n      words = _splitText.words,\n      separators = _splitText.separators;\n\n  for (var wordIndex = 0, lineIndex = 0, wordCount = words.length; wordIndex < wordCount; wordIndex += 1) {\n    var word = words[wordIndex]; // empty word\n\n    if (!word) {\n      continue;\n    } // end of line\n\n\n    if (word === eol) {\n      full[lineIndex] = true; // start a new line\n\n      lineIndex += 1;\n      lines[lineIndex] = '';\n      continue;\n    }\n\n    if (lines[lineIndex] != null) {\n      currentSeparator = separators[wordIndex - 1] || '';\n      tnode.data = \"\".concat(lines[lineIndex]).concat(currentSeparator).concat(word);\n    } else {\n      tnode.data = word;\n    }\n\n    if (tspan.getComputedTextLength() <= width) {\n      // update line\n      lines[lineIndex] = tnode.data;\n      lineSeprators[lineIndex] = separators[wordIndex]; // when is partitioning, put rest of the word onto next line\n\n      if (partIndex) {\n        full[lineIndex] = true;\n        lineIndex += 1;\n        partIndex = 0;\n      }\n    } else {\n      if (breakWord) {\n        // word is too long to put in one line or is partitioning\n        if (!lines[lineIndex] || partIndex) {\n          var isPartition = !!partIndex;\n          var isCharacter = word.length === 1;\n          partIndex = word.length - 1;\n\n          if (isPartition || isCharacter) {\n            // word has only one character.\n            if (isCharacter) {\n              if (!lines[lineIndex]) {\n                // can't fit this text within our rect\n                lines = [];\n                break;\n              } // partitioning didn't help on the non-empty line\n              // try again, but this time start with a new line\n              // cancel partitions created\n\n\n              words.splice(wordIndex, 2, word + words[wordIndex + 1]);\n              separators.splice(wordIndex + 1, 1);\n              full[lineIndex] = true;\n              lineIndex += 1;\n              wordCount -= 1;\n              wordIndex -= 1;\n              continue;\n            } // update the partitioning words\n\n\n            words[wordIndex] = word.substring(0, partIndex);\n            words[wordIndex + 1] = word.substring(partIndex) + words[wordIndex + 1];\n          } else {\n            // partitioning the long word into two words\n            words.splice(wordIndex, 1, word.substring(0, partIndex), word.substring(partIndex));\n            separators.splice(wordIndex, 0, '');\n            wordCount += 1; // if the previous line is not full\n\n            if (lineIndex && !full[lineIndex - 1]) {\n              lineIndex -= 1;\n            }\n          }\n\n          wordIndex -= 1;\n          continue;\n        }\n      } else if (!lines[lineIndex]) {\n        lines[lineIndex] = word;\n        full[lineIndex] = true;\n        lineIndex += 1;\n        continue;\n      }\n\n      lineIndex += 1;\n      wordIndex -= 1;\n    } // check whether the height of the entire text exceeds the rect height\n\n\n    if (height != null) {\n      // ensure line height\n      if (lineHeight == null) {\n        var heightValue = void 0; // use the same defaults as in V.prototype.text\n\n        if (styles.lineHeight === 'auto') {\n          heightValue = {\n            value: 1.5,\n            unit: 'em'\n          };\n        } else {\n          heightValue = NumberExt.parseCssNumeric(styles.lineHeight, ['em']) || {\n            value: 1,\n            unit: 'em'\n          };\n        }\n\n        lineHeight = heightValue.value;\n\n        if (heightValue.unit === 'em') {\n          if (Platform.IS_FIREFOX) {\n            lineHeight *= tspan.getBBox().height;\n          } else {\n            lineHeight *= telem.getBBox().height;\n          }\n        }\n      }\n\n      if (lineHeight * lines.length > height) {\n        // remove overflowing lines\n        var lastLineIndex = Math.floor(height / lineHeight) - 1;\n        var lastLine = lines[lastLineIndex];\n        var overflowLine = lines[lastLineIndex + 1];\n        lines.splice(lastLineIndex + 1);\n\n        if (lastLine == null) {\n          break;\n        } // add ellipsis\n\n\n        var ellipsis = options.ellipsis;\n\n        if (!ellipsis) {\n          break;\n        }\n\n        if (typeof ellipsis !== 'string') {\n          ellipsis = \"\\u2026\";\n        }\n\n        var fullLastLine = lastLine;\n\n        if (overflowLine && breakWord) {\n          fullLastLine += currentSeparator + overflowLine;\n        }\n\n        var lastCharIndex = fullLastLine.length;\n        var fixedLastLine = void 0;\n        var lastChar = void 0;\n\n        do {\n          lastChar = fullLastLine[lastCharIndex];\n          fixedLastLine = fullLastLine.substring(0, lastCharIndex);\n\n          if (!lastChar) {\n            fixedLastLine += lineSeprators[lastLineIndex];\n          } else if (lastChar.match(separator)) {\n            fixedLastLine += lastChar;\n          }\n\n          fixedLastLine += ellipsis;\n          tnode.data = fixedLastLine;\n\n          if (tspan.getComputedTextLength() <= width) {\n            lines[lastLineIndex] = fixedLastLine;\n            break;\n          }\n\n          lastCharIndex -= 1;\n        } while (lastCharIndex >= 0);\n\n        break;\n      }\n    }\n  }\n\n  if (shouldAppend) {\n    remove(svgDocument);\n  } else {\n    remove(telem);\n  }\n\n  return lines.join(eol);\n}","map":null,"metadata":{},"sourceType":"module"}