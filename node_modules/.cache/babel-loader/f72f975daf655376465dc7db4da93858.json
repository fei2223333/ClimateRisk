{"ast":null,"code":"import graphlib from './graphlib';\nimport List from './data/list';\nvar Graph = graphlib.Graph;\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\n// module.exports = greedyFAS;\n\nvar DEFAULT_WEIGHT_FN = function DEFAULT_WEIGHT_FN() {\n  return 1;\n};\n\nvar greedyFAS = function greedyFAS(g, weightFn) {\n  var _a;\n\n  if (g.nodeCount() <= 1) return [];\n  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx); // Expand multi-edges\n  // @ts-ignore\n\n  return (_a = results.map(function (e) {\n    return g.outEdges(e.v, e.w);\n  })) === null || _a === void 0 ? void 0 : _a.flat();\n};\n\nvar doGreedyFAS = function doGreedyFAS(g, buckets, zeroIdx) {\n  var results = [];\n  var sources = buckets[buckets.length - 1];\n  var sinks = buckets[0];\n  var entry;\n\n  while (g.nodeCount()) {\n    while (entry = sinks.dequeue()) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n\n    while (entry = sources.dequeue()) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n\n    if (g.nodeCount()) {\n      for (var i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n};\n\nvar removeNode = function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {\n  var _a, _b;\n\n  var results = collectPredecessors ? [] : undefined;\n  (_a = g.inEdges(entry.v)) === null || _a === void 0 ? void 0 : _a.forEach(function (edge) {\n    var weight = g.edge(edge);\n    var uEntry = g.node(edge.v);\n\n    if (collectPredecessors) {\n      results.push({\n        v: edge.v,\n        w: edge.w\n      });\n    }\n\n    if (uEntry.out === undefined) uEntry.out = 0;\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n  (_b = g.outEdges(entry.v)) === null || _b === void 0 ? void 0 : _b.forEach(function (edge) {\n    var weight = g.edge(edge);\n    var w = edge.w;\n    var wEntry = g.node(w);\n    if (wEntry.in === undefined) wEntry.in = 0;\n    wEntry.in -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n  g.removeNode(entry.v);\n  return results;\n};\n\nvar buildState = function buildState(g, weightFn) {\n  var fasGraph = new Graph();\n  var maxIn = 0;\n  var maxOut = 0;\n  g.nodes().forEach(function (v) {\n    fasGraph.setNode(v, {\n      v: v,\n      \"in\": 0,\n      out: 0\n    });\n  }); // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n\n  g.edges().forEach(function (e) {\n    var prevWeight = fasGraph.edge(e.v, e.w) || 0;\n    var weight = weightFn === null || weightFn === void 0 ? void 0 : weightFn(e);\n    var edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);\n    maxIn = Math.max(maxIn, fasGraph.node(e.w)[\"in\"] += weight);\n  });\n  var buckets = [];\n  var rangeMax = maxOut + maxIn + 3;\n\n  for (var i = 0; i < rangeMax; i++) {\n    buckets.push(new List());\n  }\n\n  var zeroIdx = maxIn + 1;\n  fasGraph.nodes().forEach(function (v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v));\n  });\n  return {\n    buckets: buckets,\n    zeroIdx: zeroIdx,\n    graph: fasGraph\n  };\n};\n\nvar assignBucket = function assignBucket(buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry[\"in\"]) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry[\"in\"] + zeroIdx].enqueue(entry);\n  }\n};\n\nexport default greedyFAS;","map":null,"metadata":{},"sourceType":"module"}