{"ast":null,"code":"import _classCallCheck from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shuge/Documents/project/rekit-project/Spine/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport * as d3Force from \"d3-force\";\nimport forceInABox from \"./force-in-a-box\";\nimport { isArray, isFunction, isNumber, isObject } from \"../../util\";\nimport { Base } from \"../base\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * 经典力导布局 force-directed\n */\n\nexport var ForceLayout = /*#__PURE__*/function (_Base) {\n  _inherits(ForceLayout, _Base);\n\n  function ForceLayout(options) {\n    var _this;\n\n    _classCallCheck(this, ForceLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ForceLayout).call(this));\n    /** 向心力作用点 */\n\n    _this.center = [0, 0];\n    /** 节点作用力 */\n\n    _this.nodeStrength = null;\n    /** 边的作用力, 默认为根据节点的入度出度自适应 */\n\n    _this.edgeStrength = null;\n    /** 是否防止节点相互覆盖 */\n\n    _this.preventOverlap = false;\n    /** 聚类节点作用力 */\n\n    _this.clusterNodeStrength = null;\n    /** 聚类边作用力 */\n\n    _this.clusterEdgeStrength = null;\n    /** 聚类边长度 */\n\n    _this.clusterEdgeDistance = null;\n    /** 聚类节点大小 / 直径，直径越大，越分散 */\n\n    _this.clusterNodeSize = null;\n    /** 用于 foci 的力 */\n\n    _this.clusterFociStrength = null;\n    /** 默认边长度 */\n\n    _this.linkDistance = 50;\n    /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\n\n    _this.alphaDecay = 0.028;\n    /** 停止迭代的阈值 */\n\n    _this.alphaMin = 0.001;\n    /** 当前阈值 */\n\n    _this.alpha = 0.3;\n    /** 防止重叠的力强度 */\n\n    _this.collideStrength = 1;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    _this.workerEnabled = false;\n\n    _this.tick = function () {};\n    /** 布局完成回调 */\n\n\n    _this.onLayoutEnd = function () {};\n    /** 是否正在布局 */\n\n\n    _this.ticking = undefined;\n\n    if (options) {\n      _this.updateCfg(options);\n    }\n\n    return _this;\n  }\n\n  _createClass(ForceLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        center: [0, 0],\n        nodeStrength: null,\n        edgeStrength: null,\n        preventOverlap: false,\n        nodeSize: undefined,\n        nodeSpacing: undefined,\n        linkDistance: 50,\n        forceSimulation: null,\n        alphaDecay: 0.028,\n        alphaMin: 0.001,\n        alpha: 0.3,\n        collideStrength: 1,\n        clustering: false,\n        clusterNodeStrength: -1,\n        clusterEdgeStrength: 0.1,\n        clusterEdgeDistance: 100,\n        clusterFociStrength: 0.8,\n        clusterNodeSize: 10,\n        tick: function tick() {},\n        onLayoutEnd: function onLayoutEnd() {},\n        // 是否启用web worker。前提是在web worker里执行布局，否则无效\n        workerEnabled: false\n      };\n    }\n    /**\n     * 初始化\n     * @param {object} data 数据\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(data) {\n      var self = this;\n      self.nodes = data.nodes || [];\n      var edges = data.edges || [];\n      self.edges = edges.map(function (edge) {\n        var res = {};\n        var expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\n        Object.keys(edge).forEach(function (key) {\n          if (!(expectKeys.indexOf(key) > -1)) {\n            res[key] = edge[key];\n          }\n        });\n        return res;\n      });\n      self.ticking = false;\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(reloadData) {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges; // 如果正在布局，忽略布局请求\n\n      if (self.ticking) {\n        return;\n      }\n\n      var simulation = self.forceSimulation;\n      var alphaMin = self.alphaMin;\n      var alphaDecay = self.alphaDecay;\n      var alpha = self.alpha;\n\n      if (!simulation) {\n        try {\n          // 定义节点的力\n          var nodeForce = d3Force.forceManyBody();\n\n          if (self.nodeStrength) {\n            nodeForce.strength(self.nodeStrength);\n          }\n\n          simulation = d3Force.forceSimulation().nodes(nodes);\n\n          if (self.clustering) {\n            var clusterForce = forceInABox();\n            clusterForce.centerX(self.center[0]).centerY(self.center[1]).template(\"force\").strength(self.clusterFociStrength);\n\n            if (edges) {\n              clusterForce.links(edges);\n            }\n\n            if (nodes) {\n              clusterForce.nodes(nodes);\n            }\n\n            clusterForce.forceLinkDistance(self.clusterEdgeDistance).forceLinkStrength(self.clusterEdgeStrength).forceCharge(self.clusterNodeStrength).forceNodeSize(self.clusterNodeSize);\n            self.clusterForce = clusterForce;\n            simulation.force(\"group\", clusterForce);\n          }\n\n          simulation.force(\"center\", d3Force.forceCenter(self.center[0], self.center[1])).force(\"charge\", nodeForce).alpha(alpha).alphaDecay(alphaDecay).alphaMin(alphaMin);\n\n          if (self.preventOverlap) {\n            self.overlapProcess(simulation);\n          } // 如果有边，定义边的力\n\n\n          if (edges) {\n            // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n            var edgeForce = d3Force.forceLink().id(function (d) {\n              return d.id;\n            }).links(edges);\n\n            if (self.edgeStrength) {\n              edgeForce.strength(self.edgeStrength);\n            }\n\n            if (self.linkDistance) {\n              edgeForce.distance(self.linkDistance);\n            }\n\n            self.edgeForce = edgeForce;\n            simulation.force(\"link\", edgeForce);\n          }\n\n          if (self.workerEnabled && !isInWorker()) {\n            // 如果不是运行在web worker里，不用web worker布局\n            self.workerEnabled = false;\n            console.warn(\"workerEnabled option is only supported when running in web worker.\");\n          }\n\n          if (!self.workerEnabled) {\n            simulation.on(\"tick\", function () {\n              self.tick();\n            }).on(\"end\", function () {\n              self.ticking = false;\n              if (self.onLayoutEnd) self.onLayoutEnd();\n            });\n            self.ticking = true;\n          } else {\n            // worker is enabled\n            simulation.stop();\n            var totalTicks = getSimulationTicks(simulation);\n\n            for (var currentTick = 1; currentTick <= totalTicks; currentTick++) {\n              simulation.tick(); // currentTick starts from 1.\n\n              postMessage({\n                nodes: nodes,\n                currentTick: currentTick,\n                totalTicks: totalTicks,\n                type: LAYOUT_MESSAGE.TICK\n              }, undefined);\n            }\n\n            self.ticking = false;\n          }\n\n          self.forceSimulation = simulation;\n          self.ticking = true;\n        } catch (e) {\n          self.ticking = false;\n          console.warn(e);\n        }\n      } else {\n        if (reloadData) {\n          if (self.clustering && self.clusterForce) {\n            self.clusterForce.nodes(nodes);\n            self.clusterForce.links(edges);\n          }\n\n          simulation.nodes(nodes);\n          if (edges && self.edgeForce) self.edgeForce.links(edges);else if (edges && !self.edgeForce) {\n            // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n            var _edgeForce = d3Force.forceLink().id(function (d) {\n              return d.id;\n            }).links(edges);\n\n            if (self.edgeStrength) {\n              _edgeForce.strength(self.edgeStrength);\n            }\n\n            if (self.linkDistance) {\n              _edgeForce.distance(self.linkDistance);\n            }\n\n            self.edgeForce = _edgeForce;\n            simulation.force(\"link\", _edgeForce);\n          }\n        }\n\n        if (self.preventOverlap) {\n          self.overlapProcess(simulation);\n        }\n\n        simulation.alpha(alpha).restart();\n        this.ticking = true;\n      }\n    }\n    /**\n     * 防止重叠\n     * @param {object} simulation 力模拟模型\n     */\n\n  }, {\n    key: \"overlapProcess\",\n    value: function overlapProcess(simulation) {\n      var self = this;\n      var nodeSize = self.nodeSize;\n      var nodeSpacing = self.nodeSpacing;\n      var nodeSizeFunc;\n      var nodeSpacingFunc;\n      var collideStrength = self.collideStrength;\n\n      if (isNumber(nodeSpacing)) {\n        nodeSpacingFunc = function nodeSpacingFunc() {\n          return nodeSpacing;\n        };\n      } else if (isFunction(nodeSpacing)) {\n        nodeSpacingFunc = nodeSpacing;\n      } else {\n        nodeSpacingFunc = function nodeSpacingFunc() {\n          return 0;\n        };\n      }\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if (isArray(d.size)) {\n              var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n              return res / 2 + nodeSpacingFunc(d);\n            }\n\n            if (isObject(d.size)) {\n              var _res = d.size.width > d.size.height ? d.size.width : d.size.height;\n\n              return _res / 2 + nodeSpacingFunc(d);\n            }\n\n            return d.size / 2 + nodeSpacingFunc(d);\n          }\n\n          return 10 + nodeSpacingFunc(d);\n        };\n      } else if (isFunction(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          var size = nodeSize(d);\n          return size + nodeSpacingFunc(d);\n        };\n      } else if (isArray(nodeSize)) {\n        var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n        var radius = larger / 2;\n\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return radius + nodeSpacingFunc(d);\n        };\n      } else if (isNumber(nodeSize)) {\n        var _radius = nodeSize / 2;\n\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return _radius + nodeSpacingFunc(d);\n        };\n      } else {\n        nodeSizeFunc = function nodeSizeFunc() {\n          return 10;\n        };\n      } // forceCollide's parameter is a radius\n\n\n      simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\n    }\n    /**\n     * 更新布局配置，但不执行布局\n     * @param {object} cfg 需要更新的配置项\n     */\n\n  }, {\n    key: \"updateCfg\",\n    value: function updateCfg(cfg) {\n      var self = this;\n\n      if (self.ticking) {\n        self.forceSimulation.stop();\n        self.ticking = false;\n      }\n\n      self.forceSimulation = null;\n      Object.assign(self, cfg);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var self = this;\n\n      if (self.ticking) {\n        self.forceSimulation.stop();\n        self.ticking = false;\n      }\n\n      self.nodes = null;\n      self.edges = null;\n      self.destroyed = true;\n    }\n  }]);\n\n  return ForceLayout;\n}(Base); // Return total ticks of d3-force simulation\n\nfunction getSimulationTicks(simulation) {\n  var alphaMin = simulation.alphaMin();\n  var alphaTarget = simulation.alphaTarget();\n  var alpha = simulation.alpha();\n  var totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) / Math.log(1 - simulation.alphaDecay());\n  var totalTicks = Math.ceil(totalTicksFloat);\n  return totalTicks;\n} // 判断是否运行在web worker里\n\n\nfunction isInWorker() {\n  // eslint-disable-next-line no-undef\n  return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}","map":null,"metadata":{},"sourceType":"module"}